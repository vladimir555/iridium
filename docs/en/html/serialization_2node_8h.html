<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iridium: source/iridium/parsing/serialization/node.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iridium<span id="projectnumber">&#160;0.9.95</span>
   </div>
   <div id="projectbrief">Lightweight C++ framework (logging, serialization, threads, processes, I/O, testing)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_73db56d11ff6760bdab318ef9b789ffb.html">iridium</a></li><li class="navelem"><a class="el" href="dir_3598e8d03f058449899ac524faf1a451.html">parsing</a></li><li class="navelem"><a class="el" href="dir_9060e3896eb62ee73102da690e7293ec.html">serialization</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">node.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;string&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &quot;<a class="el" href="node_8h_source.html">iridium/parsing/node.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="implementation_2node_8h_source.html">iridium/parsing/implementation/node.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="va__args_8h_source.html">iridium/macros/va_args.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for node.h:</div>
<div class="dyncontent">
<div class="center"><img src="serialization_2node_8h__incl.png" border="0" usemap="#asource_2iridium_2parsing_2serialization_2node_8h" alt=""/></div>
<map name="asource_2iridium_2parsing_2serialization_2node_8h" id="asource_2iridium_2parsing_2serialization_2node_8h">
<area shape="rect" title=" " alt="" coords="316,5,465,46"/>
<area shape="rect" title=" " alt="" coords="55,492,108,518"/>
<area shape="poly" title=" " alt="" coords="316,30,221,39,169,50,120,65,75,86,40,114,27,131,17,150,10,171,8,194,8,351,13,388,27,423,45,453,63,478,59,482,40,456,22,425,8,389,3,352,3,194,5,170,12,148,22,128,36,110,73,82,118,60,168,44,220,34,316,25"/>
<area shape="rect" title=" " alt="" coords="660,492,738,518"/>
<area shape="poly" title=" " alt="" coords="466,32,542,47,583,60,621,77,655,98,682,124,700,156,707,194,707,352,703,477,698,477,701,352,701,194,695,158,678,127,651,102,618,81,581,65,541,52,465,37"/>
<area shape="rect" href="node_8h.html" title="Defines the INode typedef, a specialization of INodeType&lt;std::string&gt;. This serves as the primary typ..." alt="" coords="316,183,465,208"/>
<area shape="poly" title=" " alt="" coords="393,46,393,167,388,167,388,46"/>
<area shape="rect" href="implementation_2node_8h.html" title="Defines the CNode typedef, a concrete node implementation based on CNodeType&lt;std::string&gt;...." alt="" coords="152,94,349,135"/>
<area shape="poly" title=" " alt="" coords="360,49,297,88,294,83,358,44"/>
<area shape="rect" href="va__args_8h.html" title="Provides a set of preprocessor macros to emulate variadic macro dispatch based on argument count...." alt="" coords="742,102,909,127"/>
<area shape="poly" title=" " alt="" coords="466,39,750,95,748,101,465,44"/>
<area shape="rect" href="node__type_8h.html" title="Defines the INodeType&lt;TValue&gt; template interface for generic tree nodes. This interface is fundamenta..." alt="" coords="322,256,414,282"/>
<area shape="poly" title=" " alt="" coords="389,209,379,242,374,240,384,208"/>
<area shape="poly" title=" " alt="" coords="322,284,270,303,218,332,179,367,145,407,97,480,93,477,141,404,175,364,214,328,267,298,320,279"/>
<area shape="rect" title=" " alt="" coords="587,492,626,518"/>
<area shape="poly" title=" " alt="" coords="415,268,455,271,499,281,543,299,579,328,601,364,611,404,614,444,613,477,608,477,609,444,606,405,596,366,575,332,540,304,498,286,454,277,414,273"/>
<area shape="rect" href="convert_8h.html" title="Public interface for the Iridium type conversion framework. Provides access to conversion functions a..." alt="" coords="442,330,566,371"/>
<area shape="poly" title=" " alt="" coords="390,280,459,320,456,324,387,285"/>
<area shape="rect" href="prototype_8h.html" title=" " alt="" coords="246,338,418,363"/>
<area shape="poly" title=" " alt="" coords="365,284,346,325,341,322,360,281"/>
<area shape="rect" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods..." alt="" coords="165,419,294,444"/>
<area shape="poly" title=" " alt="" coords="330,285,273,307,250,319,235,332,228,348,224,367,226,404,221,404,219,367,223,347,231,328,247,315,271,302,328,280"/>
<area shape="rect" href="implementation_2convert_8h.html" title="Core implementation details for the Iridium type conversion framework. Defines the primary convert fu..." alt="" coords="382,419,549,444"/>
<area shape="poly" title=" " alt="" coords="497,372,480,406,476,403,492,370"/>
<area shape="poly" title=" " alt="" coords="400,448,124,499,123,493,399,442"/>
<area shape="poly" title=" " alt="" coords="506,442,645,485,644,490,504,447"/>
<area shape="poly" title=" " alt="" coords="491,442,575,485,572,490,488,447"/>
<area shape="rect" title=" " alt="" coords="503,492,564,518"/>
<area shape="poly" title=" " alt="" coords="478,443,514,479,510,483,475,446"/>
<area shape="rect" title=" " alt="" coords="338,492,395,518"/>
<area shape="poly" title=" " alt="" coords="450,447,397,485,394,481,447,443"/>
<area shape="rect" title=" " alt="" coords="212,492,281,518"/>
<area shape="poly" title=" " alt="" coords="429,447,297,490,295,485,427,442"/>
<area shape="rect" title=" " alt="" coords="419,492,480,518"/>
<area shape="poly" title=" " alt="" coords="465,445,458,477,453,476,460,444"/>
<area shape="poly" title=" " alt="" coords="318,366,259,411,256,407,315,361"/>
<area shape="poly" title=" " alt="" coords="235,444,243,477,238,478,230,445"/>
<area shape="rect" href="implementation_2node__type_8h.html" title="Defines the CNodeType&lt;TValue&gt; template class, a concrete implementation of INodeType&lt;TValue&gt;...." alt="" coords="200,183,293,208"/>
<area shape="poly" title=" " alt="" coords="252,135,251,167,245,167,247,135"/>
<area shape="poly" title=" " alt="" coords="227,211,199,231,173,258,140,315,115,376,98,433,88,478,83,477,93,432,110,374,135,313,169,255,195,227,224,207"/>
<area shape="poly" title=" " alt="" coords="269,207,336,246,333,250,266,211"/>
<area shape="poly" title=" " alt="" coords="294,205,374,227,469,256,555,291,587,309,610,328,629,356,637,382,637,411,632,445,621,479,616,477,627,444,632,410,632,383,624,358,606,332,584,314,552,296,467,261,373,232,293,211"/>
<area shape="poly" title=" " alt="" coords="229,211,204,231,185,258,179,276,178,296,184,336,198,374,215,404,210,407,194,376,179,338,172,296,174,275,180,255,200,227,225,207"/>
<area shape="rect" title=" " alt="" coords="195,256,298,282"/>
<area shape="poly" title=" " alt="" coords="249,209,249,241,244,241,244,209"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="serialization_2node_8h__dep__incl.png" border="0" usemap="#asource_2iridium_2parsing_2serialization_2node_8hdep" alt=""/></div>
<map name="asource_2iridium_2parsing_2serialization_2node_8hdep" id="asource_2iridium_2parsing_2serialization_2node_8hdep">
<area shape="rect" title=" " alt="" coords="1492,5,1640,46"/>
<area shape="rect" href="db_2config_8h.html" title="Defines database configuration structures using a serialization framework. This header specifies the ..." alt="" coords="350,102,521,127"/>
<area shape="poly" title=" " alt="" coords="1477,36,521,109,521,104,1477,31"/>
<area shape="rect" href="request_8h.html" title=" " alt="" coords="1202,94,1368,135"/>
<area shape="poly" title=" " alt="" coords="1488,54,1350,96,1348,91,1487,48"/>
<area shape="rect" href="response_8h.html" title=" " alt="" coords="1392,94,1559,135"/>
<area shape="poly" title=" " alt="" coords="1537,59,1498,95,1494,92,1533,55"/>
<area shape="rect" href="logging_2config_8h.html" title=" " alt="" coords="1583,94,1730,135"/>
<area shape="poly" title=" " alt="" coords="1599,55,1638,92,1635,95,1596,59"/>
<area shape="rect" href="serialization_2node_8cpp.html" title=" " alt="" coords="1805,94,1956,135"/>
<area shape="poly" title=" " alt="" coords="1653,48,1810,91,1809,96,1651,53"/>
<area shape="rect" href="test__runner_8h.html" title=" " alt="" coords="2986,183,3131,223"/>
<area shape="poly" title=" " alt="" coords="1647,49,1696,68,1744,92,1759,103,1769,114,1779,124,1794,132,1866,147,1991,160,2336,179,2708,191,2985,198,2985,203,2708,197,2336,184,1990,165,1865,152,1792,137,1775,128,1765,118,1755,107,1741,96,1694,73,1645,54"/>
<area shape="rect" href="db_2config_8cpp.html" title=" " alt="" coords="242,190,426,216"/>
<area shape="poly" title=" " alt="" coords="412,139,350,192,346,188,409,135"/>
<area shape="rect" href="factory_8h.html" title=" " alt="" coords="450,190,624,216"/>
<area shape="poly" title=" " alt="" coords="462,135,525,188,521,192,459,139"/>
<area shape="rect" href="implementation_2connector_8h.html" title="Defines the CConnector base class for concrete database connector implementations...." alt="" coords="5,183,218,223"/>
<area shape="poly" title=" " alt="" coords="376,134,186,185,184,180,374,129"/>
<area shape="rect" href="factory_8cpp.html" title=" " alt="" coords="342,286,529,312"/>
<area shape="poly" title=" " alt="" coords="515,228,450,288,447,284,511,224"/>
<area shape="rect" href="implementation_2connector_8cpp.html" title=" " alt="" coords="5,279,218,320"/>
<area shape="poly" title=" " alt="" coords="114,239,114,278,109,278,109,239"/>
<area shape="rect" href="request_8cpp.html" title=" " alt="" coords="1202,183,1368,223"/>
<area shape="poly" title=" " alt="" coords="1288,150,1288,182,1282,182,1282,150"/>
<area shape="rect" href="response_8cpp.html" title=" " alt="" coords="1392,183,1559,223"/>
<area shape="poly" title=" " alt="" coords="1478,150,1478,182,1473,182,1473,150"/>
<area shape="rect" href="logging_2config_8cpp.html" title=" " alt="" coords="1755,183,1902,223"/>
<area shape="poly" title=" " alt="" coords="1711,140,1791,180,1789,185,1708,144"/>
<area shape="rect" href="logger_8h.html" title="Defines the main Logger singleton class, LogStream and LogStreamDummy helper structs,..." alt="" coords="1583,183,1730,223"/>
<area shape="poly" title=" " alt="" coords="1660,150,1660,182,1654,182,1654,150"/>
<area shape="rect" href="context_8cpp.html" title=" " alt="" coords="230,382,438,423"/>
<area shape="poly" title=" " alt="" coords="1568,226,1362,233,1056,238,762,249,655,260,617,266,593,274,577,285,567,299,558,314,542,329,481,362,417,384,416,379,478,357,539,325,554,311,563,296,573,282,590,269,616,261,654,254,762,244,1056,233,1361,227,1568,220"/>
<area shape="rect" href="context__manager_8cpp.html" title=" " alt="" coords="1205,279,1413,320"/>
<area shape="poly" title=" " alt="" coords="1570,230,1382,281,1381,276,1568,225"/>
<area shape="rect" href="implementation_2pipe_8cpp.html" title=" " alt="" coords="1437,279,1645,320"/>
<area shape="poly" title=" " alt="" coords="1623,235,1567,281,1563,276,1620,231"/>
<area shape="rect" href="session__manager_8cpp.html" title=" " alt="" coords="458,664,666,704"/>
<area shape="poly" title=" " alt="" coords="1568,226,1473,230,1363,233,1309,237,1261,244,1222,256,1195,273,1179,293,1168,313,1163,334,1161,354,1167,396,1179,439,1192,482,1198,525,1196,547,1190,568,1180,589,1163,610,1138,623,1093,635,963,654,808,669,667,679,667,674,808,664,962,649,1092,629,1136,618,1159,606,1175,586,1186,566,1191,546,1193,525,1187,483,1174,440,1162,397,1156,354,1157,333,1163,311,1174,290,1191,269,1220,251,1260,239,1308,231,1362,227,1473,225,1568,221"/>
<area shape="rect" href="stream__buffer_8cpp.html" title=" " alt="" coords="1669,279,1877,320"/>
<area shape="poly" title=" " alt="" coords="1694,231,1751,276,1747,281,1691,235"/>
<area shape="rect" href="content__storage_8cpp.html" title=" " alt="" coords="1901,271,2087,327"/>
<area shape="poly" title=" " alt="" coords="1743,225,1901,269,1900,274,1741,231"/>
<area shape="rect" href="logger_8cpp.html" title=" " alt="" coords="2111,279,2258,320"/>
<area shape="poly" title=" " alt="" coords="1746,221,1847,235,1925,242,2003,251,2100,269,2127,276,2126,281,2099,274,2002,256,1925,248,1846,240,1746,226"/>
<area shape="rect" href="parser__json_8cpp.html" title=" " alt="" coords="2283,271,2436,327"/>
<area shape="poly" title=" " alt="" coords="1746,221,1894,237,2011,241,2126,248,2271,269,2283,271,2282,277,2270,274,2125,253,2010,247,1894,242,1745,226"/>
<area shape="rect" href="shell_8cpp.html" title=" " alt="" coords="2461,279,2610,320"/>
<area shape="poly" title=" " alt="" coords="1746,221,1853,233,1944,238,2100,240,2255,244,2344,252,2449,269,2479,276,2478,281,2448,274,2344,258,2254,249,2100,245,1944,244,1853,238,1746,226"/>
<area shape="rect" href="test__runner__fork_8cpp.html" title=" " alt="" coords="898,375,1080,431"/>
<area shape="poly" title=" " alt="" coords="1568,226,1455,233,1320,238,1192,249,1140,259,1099,274,1069,295,1043,322,1005,376,1001,373,1039,319,1065,291,1097,269,1138,254,1191,243,1320,233,1454,228,1567,221"/>
<area shape="rect" href="test__runner__raw_8cpp.html" title=" " alt="" coords="2667,375,2849,431"/>
<area shape="poly" title=" " alt="" coords="1746,221,1838,226,1949,227,2200,223,2326,224,2443,230,2544,244,2587,255,2623,269,2642,281,2653,294,2676,325,2728,373,2725,377,2672,329,2648,297,2638,285,2621,274,2585,260,2543,250,2442,236,2325,230,2200,229,1949,232,1838,231,1746,226"/>
<area shape="rect" href="tester_8cpp.html" title=" " alt="" coords="2986,382,3131,423"/>
<area shape="poly" title=" " alt="" coords="1746,220,2056,223,2565,226,2826,230,3052,237,3217,250,3269,258,3295,269,3305,284,3307,298,3304,313,3295,329,3279,346,3261,361,3220,383,3175,396,3131,403,3131,397,3173,391,3218,378,3258,357,3276,342,3291,325,3299,311,3302,298,3300,286,3291,273,3267,264,3217,255,3052,243,2825,235,2565,231,2055,229,1746,225"/>
<area shape="rect" href="tester_8h.html" title=" " alt="" coords="2686,279,2831,320"/>
<area shape="poly" title=" " alt="" coords="1746,221,1886,235,2005,241,2209,239,2306,238,2411,240,2529,250,2667,269,2698,276,2697,281,2666,274,2528,255,2411,246,2306,243,2209,245,2005,246,1885,241,1745,226"/>
<area shape="rect" href="implementation_2async__queue_8h.html" title="Defines the CAsyncQueue&lt;TItem&gt; class, an implementation of the IAsyncQueue&lt;TItem&gt; interface...." alt="" coords="604,279,809,320"/>
<area shape="poly" title=" " alt="" coords="1568,226,1458,239,1364,246,1203,251,1044,255,951,262,843,274,799,281,798,276,842,269,951,257,1044,250,1203,246,1363,241,1457,234,1567,221"/>
<area shape="rect" href="implementation_2thread_8cpp.html" title=" " alt="" coords="753,479,931,519"/>
<area shape="poly" title=" " alt="" coords="1568,226,1485,234,1414,236,1293,232,1235,232,1175,237,1109,250,1032,274,985,293,950,312,921,338,888,377,873,402,861,430,848,479,843,477,856,428,868,400,884,373,917,334,947,308,983,288,1031,269,1108,245,1175,231,1235,226,1293,227,1414,231,1485,229,1567,221"/>
<area shape="rect" href="worker_8cpp.html" title=" " alt="" coords="968,567,1148,608"/>
<area shape="poly" title=" " alt="" coords="1568,226,1464,231,1342,233,1282,237,1228,244,1183,256,1151,273,1141,288,1130,318,1105,403,1065,568,1060,566,1100,401,1125,316,1137,286,1147,269,1181,251,1227,239,1281,231,1341,228,1464,225,1567,221"/>
<area shape="poly" title=" " alt="" coords="2832,322,3001,379,2999,384,2830,328"/>
<area shape="poly" title=" " alt="" coords="620,327,407,385,405,379,619,322"/>
<area shape="poly" title=" " alt="" coords="776,323,914,372,912,377,774,328"/>
<area shape="poly" title=" " alt="" coords="745,328,787,373,818,428,838,477,833,479,813,431,783,377,741,332"/>
<area shape="rect" href="implementation_2thread_8h.html" title="Defines the CThread class, a concrete implementation of the IThread interface. This class manages a s..." alt="" coords="608,382,772,423"/>
<area shape="poly" title=" " alt="" coords="703,335,696,383,691,382,698,334"/>
<area shape="rect" href="implementation_2worker_8h.html" title="Defines worker class implementations (CWorkerPusher, CWorkerPopper, CWorker) that manage a thread to ..." alt="" coords="563,479,729,519"/>
<area shape="poly" title=" " alt="" coords="646,330,619,350,598,376,592,390,591,402,598,430,611,455,628,476,624,480,606,458,593,432,586,402,587,389,593,374,615,346,643,325"/>
<area shape="rect" href="worker__pool_8h.html" title=" " alt="" coords="291,567,489,608"/>
<area shape="poly" title=" " alt="" coords="656,329,619,351,584,377,529,427,478,481,407,569,402,565,474,478,525,424,580,373,616,347,653,325"/>
<area shape="poly" title=" " alt="" coords="610,432,578,453,554,480,543,503,538,527,537,579,546,626,557,663,552,664,541,627,532,579,532,527,538,501,549,477,575,449,607,428"/>
<area shape="poly" title=" " alt="" coords="736,429,812,476,809,480,733,434"/>
<area shape="poly" title=" " alt="" coords="677,438,658,479,653,477,672,436"/>
<area shape="rect" href="implementation_2sink_8cpp.html" title=" " alt="" coords="563,567,729,608"/>
<area shape="poly" title=" " alt="" coords="649,535,649,567,644,567,644,535"/>
<area shape="rect" href="sink__file_8cpp.html" title=" " alt="" coords="754,567,944,608"/>
<area shape="poly" title=" " alt="" coords="707,523,804,564,802,569,705,528"/>
<area shape="poly" title=" " alt="" coords="745,518,968,565,967,570,744,523"/>
<area shape="poly" title=" " alt="" coords="575,527,449,569,448,564,573,522"/>
<area shape="poly" title=" " alt="" coords="441,614,527,661,525,665,438,618"/>
<area shape="rect" href="worker__pool_8cpp.html" title=" " alt="" coords="274,656,434,712"/>
<area shape="poly" title=" " alt="" coords="380,624,367,656,362,654,375,622"/>
<area shape="rect" href="test__runner__fork_8h.html" title=" " alt="" coords="2855,271,3037,327"/>
<area shape="poly" title=" " alt="" coords="3025,235,2980,273,2977,269,3022,231"/>
<area shape="rect" href="test__runner__raw_8h.html" title=" " alt="" coords="3062,279,3281,320"/>
<area shape="poly" title=" " alt="" coords="3095,231,3150,276,3146,281,3092,235"/>
<area shape="rect" href="test__runner_8cpp.html" title=" " alt="" coords="3356,279,3502,320"/>
<area shape="poly" title=" " alt="" coords="3146,222,3338,269,3363,276,3361,281,3336,274,3145,227"/>
<area shape="poly" title=" " alt="" coords="2840,330,2670,348,2453,362,1940,384,1438,397,1080,403,1080,398,1438,392,1940,379,2453,357,2670,342,2839,325"/>
<area shape="poly" title=" " alt="" coords="2989,336,3038,380,3035,384,2986,340"/>
<area shape="poly" title=" " alt="" coords="3077,326,2850,382,2849,377,3076,321"/>
<area shape="poly" title=" " alt="" coords="3140,332,3082,384,3078,380,3137,328"/>
</map>
</div>
</div>
<p><a href="serialization_2node_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt; TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a typed view or wrapper around an underlying <code><a class="el" href="namespaceiridium_1_1parsing.html#a88d6a61f1143b2f33166598a41993b7e" title="Defines INode as a specialization of the INodeType interface with std::string as its value type....">INode</a></code> object. This class template facilitates typed access (get/set) to the value of a node and manages its relationship within a larger node structure (via path and parent). It's a fundamental building block for attributes and simple value-holding nodes defined using the serialization macros.  <a href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_3_01void_01_4.html">iridium::parsing::serialization::NodeView&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Provides a typed view or wrapper around an underlying INode object. This class template facilitates t...">NodeView</a></code> for typeless nodes (<code>void</code> value type). This is typically used as a base class for structured nodes defined by <code>DEFINE_NODE_BEGIN</code> or <code>DEFINE_ROOT_NODE_BEGIN</code>, or to represent a parent node whose specific type is not needed for path construction. It primarily manages the <code><a class="el" href="namespaceiridium_1_1parsing.html#a88d6a61f1143b2f33166598a41993b7e" title="Defines INode as a specialization of the INodeType interface with std::string as its value type....">INode</a></code> pointer and its path.  <a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html">iridium::parsing::serialization::NodeViewList&lt; TNodeView &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a list of <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Provides a typed view or wrapper around an underlying INode object. This class template facilitates t...">NodeView</a></code> objects of a specific type <code>TNodeView</code>. This class provides an interface to iterate over and modify a list of complex child nodes or a list of attributes within a data structure defined by the serialization macros.  <a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html">iridium::parsing::serialization::NodeViewPtr&lt; TNodeView &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for a lazily-initialized shared pointer to a <code>TNodeView</code>. This is used for optional or recursive node definitions within data structures defined by the serialization macros (e.g., <code>DEFINE_NODE_PTR</code>). The actual <code>TNodeView</code> is typically created only when <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html#a3859d99c5505ade8c5d2e951240f1690" title="Gets the shared pointer to the TNodeView. If the TNodeView was not yet created (e....">get()</a></code> is called and the underlying node exists.  <a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiridium.html">iridium</a></td></tr>
<tr class="memdesc:namespaceiridium"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines interfaces for I/O context management and named pipe management. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiridium_1_1parsing.html">iridium::parsing</a></td></tr>
<tr class="memdesc:namespaceiridium_1_1parsing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides interfaces, utilities, and concrete classes for parsing and composing structured data. This namespace often deals with representing data as a tree of nodes (e.g., <code><a class="el" href="namespaceiridium_1_1parsing.html#a88d6a61f1143b2f33166598a41993b7e" title="Defines INode as a specialization of the INodeType interface with std::string as its value type....">INode</a></code>). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiridium_1_1parsing_1_1serialization.html">iridium::parsing::serialization</a></td></tr>
<tr class="memdesc:namespaceiridium_1_1parsing_1_1serialization"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides classes, macros, and utilities for defining serializable/deserializable data structures. This namespace focuses on a node-based representation where data structures are defined as a hierarchy of nodes, each potentially having attributes, values, and child nodes or lists of nodes. The system uses <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Provides a typed view or wrapper around an underlying INode object. This class template facilitates t...">NodeView</a></code> classes as wrappers around an underlying <code><a class="el" href="namespaceiridium_1_1parsing.html#a88d6a61f1143b2f33166598a41993b7e" title="Defines INode as a specialization of the INodeType interface with std::string as its value type....">INode</a></code> tree to provide typed access and modification, and employs a suite of macros (<code>DEFINE_ROOT_NODE_BEGIN</code>, <code>DEFINE_ATTRIBUTE</code>, etc.) to declaratively define these structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7f018fdfb6121484592a761b4ab9eb18" id="r_a7f018fdfb6121484592a761b4ab9eb18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f018fdfb6121484592a761b4ab9eb18">DEFINE_ROOT_NODE_BEGIN_2</a>(class_name,  name_delimeter_symbol)</td></tr>
<tr class="memdesc:a7f018fdfb6121484592a761b4ab9eb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the definition of a root node structure for serialization/deserialization. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;void&gt;</code>. It includes constructors for creating a new node or wrapping an existing <code>INode::TSharedPtr</code>. The node name is automatically derived from <code>class_name</code> using <code>convertCamelToSplittedBySymbol</code>.  <br /></td></tr>
<tr class="separator:a7f018fdfb6121484592a761b4ab9eb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4794eb438b9b61fcf728aa00f7fd2" id="r_ac0d4794eb438b9b61fcf728aa00f7fd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d4794eb438b9b61fcf728aa00f7fd2">DEFINE_ROOT_NODE_BEGIN_1</a>(class_name)</td></tr>
<tr class="memdesc:ac0d4794eb438b9b61fcf728aa00f7fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the definition of a root node structure with a default name delimiter (<code>-</code>). This is a convenience macro that calls <code>DEFINE_ROOT_NODE_BEGIN_2</code> with &lsquo;&rsquo;-'<code>as the delimiter. \~russian @def <a class="el" href="#ac0d4794eb438b9b61fcf728aa00f7fd2" title="Begins the definition of a root node structure with a default name delimiter (-). This is a convenien...">DEFINE_ROOT_NODE_BEGIN_1(class_name)</a> @brief Начинает определение структуры корневого узла с разделителем имени по умолчанию (</code>-<code>). Это вспомогательный макрос, который вызывает</code>DEFINE_ROOT_NODE_BEGIN_2<code>с</code>'-'` в качестве разделителя.  <br /></td></tr>
<tr class="separator:ac0d4794eb438b9b61fcf728aa00f7fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f5e72dee27b1c9479d82a20f96f62" id="r_aac8f5e72dee27b1c9479d82a20f96f62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(...)</td></tr>
<tr class="memdesc:aac8f5e72dee27b1c9479d82a20f96f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooser macro that dispatches to <code>DEFINE_ROOT_NODE_BEGIN_1</code> or <code>DEFINE_ROOT_NODE_BEGIN_2</code> based on the number of arguments provided. Allows defining a root node with either a default name delimiter or a custom one.  <br /></td></tr>
<tr class="separator:aac8f5e72dee27b1c9479d82a20f96f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e724573d774904e29ede08ef7b17a" id="r_a7b4e724573d774904e29ede08ef7b17a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</td></tr>
<tr class="memdesc:a7b4e724573d774904e29ede08ef7b17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the definition of a root node structure started by <code>DEFINE_ROOT_NODE_BEGIN</code>. Simply provides the closing brace for the generated struct.  <br /></td></tr>
<tr class="separator:a7b4e724573d774904e29ede08ef7b17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47703aa4ae66d8d0699aa10e8cbe314" id="r_ad47703aa4ae66d8d0699aa10e8cbe314"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47703aa4ae66d8d0699aa10e8cbe314">DEFINE_NODE_BEGIN</a>(class_name)</td></tr>
<tr class="memdesc:ad47703aa4ae66d8d0699aa10e8cbe314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the definition of a nested structured node within a parent node structure. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;void&gt;</code>. This struct is initialized with a reference to its parent <code>NodeView&lt;void&gt;</code>. The node name is derived from <code>class_name</code> using the parent's <code>NAME_DELIMETER_SYMBOL</code>.  <br /></td></tr>
<tr class="separator:ad47703aa4ae66d8d0699aa10e8cbe314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac524ec1b1c08d1e9ec08f6231d693e85" id="r_ac524ec1b1c08d1e9ec08f6231d693e85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac524ec1b1c08d1e9ec08f6231d693e85">DEFINE_NODE_END</a>(class_name)</td></tr>
<tr class="memdesc:ac524ec1b1c08d1e9ec08f6231d693e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the definition of a nested structured node and declares an instance of it. Provides the closing brace for the struct defined by <code>DEFINE_NODE_BEGIN</code> and declares a member variable of that struct type, named <code>class_name</code>, initialized with <code>*this</code> (the parent).  <br /></td></tr>
<tr class="separator:ac524ec1b1c08d1e9ec08f6231d693e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255a5c50208823b8aa86af76d4f4a161" id="r_a255a5c50208823b8aa86af76d4f4a161"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a255a5c50208823b8aa86af76d4f4a161">DEFINE_ATTRIBUTE_2</a>(type,  class_name)</td></tr>
<tr class="memdesc:a255a5c50208823b8aa86af76d4f4a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mandatory attribute (a simple value node) within a parent node structure. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;type&gt;</code> and declares a member variable <code>class_name</code> of this struct type. The attribute name is derived from <code>class_name</code>.  <br /></td></tr>
<tr class="separator:a255a5c50208823b8aa86af76d4f4a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be6ba3083277ace59f6fb019fb10b06" id="r_a3be6ba3083277ace59f6fb019fb10b06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be6ba3083277ace59f6fb019fb10b06">DEFINE_ATTRIBUTE_3</a>(type,  class_name,  default_value)</td></tr>
<tr class="memdesc:a3be6ba3083277ace59f6fb019fb10b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an optional attribute with a default value within a parent node structure. Similar to <code>DEFINE_ATTRIBUTE_2</code> but provides a default value if the attribute is not present in the source.  <br /></td></tr>
<tr class="separator:a3be6ba3083277ace59f6fb019fb10b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6809e071cbeb286389a6ea722e126" id="r_a6ae6809e071cbeb286389a6ea722e126"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(...)</td></tr>
<tr class="memdesc:a6ae6809e071cbeb286389a6ea722e126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooser macro that dispatches to <code>DEFINE_ATTRIBUTE_2</code> or <code>DEFINE_ATTRIBUTE_3</code> based on the number of arguments. Allows defining attributes either as mandatory or with a default value.  <br /></td></tr>
<tr class="separator:a6ae6809e071cbeb286389a6ea722e126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c49dbc67050d59e4b5e7d095067a81a" id="r_a1c49dbc67050d59e4b5e7d095067a81a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a>(class_name)</td></tr>
<tr class="memdesc:a1c49dbc67050d59e4b5e7d095067a81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the definition of a list of complex child nodes. Generates two structs: <code>T##class_name</code> (for individual list items, inheriting <code>NodeView&lt;void&gt;</code>) and <code>T##class_name##List</code> (for the list itself, inheriting <code>NodeViewList&lt;T##class_name&gt;</code>). The inner struct <code>T##class_name</code> is then defined by subsequent <code>DEFINE_ATTRIBUTE</code> or <code>DEFINE_NODE_BEGIN/END</code> calls before <code>DEFINE_NODE_LIST_END</code>. Note: A <code>todo</code> in the source mentions a potential bug with node naming for lists (e.g., "NameList" instead of "Name").  <br /></td></tr>
<tr class="separator:a1c49dbc67050d59e4b5e7d095067a81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547f0c86e3c410b26dcf1d13d1fcec7" id="r_a1547f0c86e3c410b26dcf1d13d1fcec7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a>(class_name)</td></tr>
<tr class="memdesc:a1547f0c86e3c410b26dcf1d13d1fcec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the definition of a list of complex child nodes and declares an instance of the list. Closes the <code>T##class_name</code> struct definition and defines the <code>T##class_name##List</code> struct, then declares a member variable <code>class_name</code> of type <code>T##class_name##List</code>.  <br /></td></tr>
<tr class="separator:a1547f0c86e3c410b26dcf1d13d1fcec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e63d356bdf5ea6b486ecf63c2c3b5a" id="r_a39e63d356bdf5ea6b486ecf63c2c3b5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e63d356bdf5ea6b486ecf63c2c3b5a">DEFINE_ATTRIBUTE_LIST</a>(type,  class_name)</td></tr>
<tr class="memdesc:a39e63d356bdf5ea6b486ecf63c2c3b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a list of simple attributes (value nodes) within a parent node structure. Generates <code>T##class_name</code> (inheriting <code>NodeView&lt;type&gt;</code>) for list items and <code>T##class_name##List</code> (inheriting <code>NodeViewList&lt;T##class_name&gt;</code>) for the list itself, then declares a member <code>class_name</code> of the list type.  <br /></td></tr>
<tr class="separator:a39e63d356bdf5ea6b486ecf63c2c3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac671d110728b8a4bd1ea52fc352c9120" id="r_ac671d110728b8a4bd1ea52fc352c9120"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a>(class_name)</td></tr>
<tr class="memdesc:ac671d110728b8a4bd1ea52fc352c9120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a member that is an instance of an externally defined root node structure. This allows composition of separately defined serializable structures. The member <code>class_name</code> will be of type <code>T##class_name</code>, which is expected to be defined elsewhere using <code>DEFINE_ROOT_NODE_BEGIN/END</code>.  <br /></td></tr>
<tr class="separator:ac671d110728b8a4bd1ea52fc352c9120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb3ac4bd4064c6b5bcc1014dd33080" id="r_aedcb3ac4bd4064c6b5bcc1014dd33080"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedcb3ac4bd4064c6b5bcc1014dd33080">DEFINE_NODE_PTR</a>(class_name)</td></tr>
<tr class="memdesc:aedcb3ac4bd4064c6b5bcc1014dd33080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member that is a lazily-initialized pointer (<code>NodeViewPtr</code>) to a nested structured node. Useful for optional or recursive node definitions. Generates a typedef <code>T##class_name##Ptr</code> and a member <code>class_name##_ptr</code> of this pointer type. <code>T##class_name</code> is expected to be defined using <code>DEFINE_NODE_BEGIN/END</code> or <code>DEFINE_ROOT_NODE_BEGIN/END</code> (if referencing another root type).  <br /></td></tr>
<tr class="separator:aedcb3ac4bd4064c6b5bcc1014dd33080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aa0a9c796142dba37f95ea182326e8" id="r_a39aa0a9c796142dba37f95ea182326e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39aa0a9c796142dba37f95ea182326e8">DEFINE_NODE_LIST_PTR</a>(class_name)</td></tr>
<tr class="memdesc:a39aa0a9c796142dba37f95ea182326e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member that is a lazily-initialized pointer (<code>NodeViewPtr</code>) to a list of complex child nodes. Useful for optional or recursive lists of nodes. Generates <code>T##class_name##ListPtr</code> typedef and a member <code>class_name##_list_ptr</code>. <code>T##class_name##List</code> is expected to be generated by <code>DEFINE_NODE_LIST_BEGIN/END</code>.  <br /></td></tr>
<tr class="separator:a39aa0a9c796142dba37f95ea182326e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe218db8e82dcf8ee1396b32af09e119" id="r_abe218db8e82dcf8ee1396b32af09e119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">iridium::parsing::serialization::convertCamelToSplittedBySymbol</a> (std::string const &amp;camel, char const &amp;delimeter_symbol)</td></tr>
<tr class="memdesc:abe218db8e82dcf8ee1396b32af09e119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string from CamelCase to a delimited format (e.g., snake_case or kebab-case). This is used by the serialization macros to automatically generate node names from class/struct member names. For example, <code>MySettingName</code> with delimiter &lsquo;&rsquo;-'<code>becomes</code>"my-setting-name"<code>. \~russian @brief Преобразует строку из CamelCase в формат с разделителями (например, snake_case или kebab-case). Используется макросами сериализации для автоматической генерации имен узлов из имен членов класса/структуры. Например,</code>MySettingName<code>с разделителем</code>'-'<code>превращается в</code>"my-setting-name"`.  <br /></td></tr>
<tr class="separator:abe218db8e82dcf8ee1396b32af09e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6ae6809e071cbeb286389a6ea722e126" name="a6ae6809e071cbeb286389a6ea722e126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6809e071cbeb286389a6ea722e126">&#9670;&#160;</a></span>DEFINE_ATTRIBUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ATTRIBUTE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="va__args_8h.html#a273c1a8de1c0ca2ed53c521bf0cd5744">DEFINE_MACRO_CHOOSER</a>(<a class="code hl_define" href="#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>, __VA_ARGS__)(__VA_ARGS__)</div>
<div class="ttc" id="aserialization_2node_8h_html_a6ae6809e071cbeb286389a6ea722e126"><div class="ttname"><a href="#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE(...)</div><div class="ttdoc">Chooser macro that dispatches to DEFINE_ATTRIBUTE_2 or DEFINE_ATTRIBUTE_3 based on the number of argu...</div><div class="ttdef"><b>Definition</b> node.h:684</div></div>
<div class="ttc" id="ava__args_8h_html_a273c1a8de1c0ca2ed53c521bf0cd5744"><div class="ttname"><a href="va__args_8h.html#a273c1a8de1c0ca2ed53c521bf0cd5744">DEFINE_MACRO_CHOOSER</a></div><div class="ttdeci">#define DEFINE_MACRO_CHOOSER(target_,...)</div><div class="ttdoc">Core dispatch macro that selects a specific macro implementation (e.g., target_1, target_2) based on ...</div><div class="ttdef"><b>Definition</b> va_args.h:114</div></div>
</div><!-- fragment -->
<p>Chooser macro that dispatches to <code>DEFINE_ATTRIBUTE_2</code> or <code>DEFINE_ATTRIBUTE_3</code> based on the number of arguments. Allows defining attributes either as mandatory or with a default value. </p>

</div>
</div>
<a id="a255a5c50208823b8aa86af76d4f4a161" name="a255a5c50208823b8aa86af76d4f4a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255a5c50208823b8aa86af76d4f4a161">&#9670;&#160;</a></span>DEFINE_ATTRIBUTE_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ATTRIBUTE_2</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt; { \</div>
<div class="line">        T##class_name(<a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt;void&gt;</a> <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">        <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;type&gt; \</div>
<div class="line">        (parent, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">        <span class="keyword">using </span><a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt;::operator =; \</div>
<div class="line">    } class_name = *<span class="keyword">this</span>;</div>
<div class="ttc" id="aclassiridium_1_1parsing_1_1serialization_1_1_node_view_html"><div class="ttname"><a href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a></div><div class="ttdoc">Provides a typed view or wrapper around an underlying INode object. This class template facilitates t...</div><div class="ttdef"><b>Definition</b> node.h:52</div></div>
<div class="ttc" id="anamespaceiridium_html"><div class="ttname"><a href="namespaceiridium.html">iridium</a></div><div class="ttdoc">Defines interfaces for I/O context management and named pipe management.</div><div class="ttdef"><b>Definition</b> assert.h:19</div></div>
</div><!-- fragment -->
<p>Defines a mandatory attribute (a simple value node) within a parent node structure. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;type&gt;</code> and declares a member variable <code>class_name</code> of this struct type. The attribute name is derived from <code>class_name</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The data type of the attribute (e.g., <code>std::string</code>, <code>int</code>, <code>bool</code>). </td></tr>
    <tr><td class="paramname">class_name</td><td>The name of the member variable and base for the attribute node name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be6ba3083277ace59f6fb019fb10b06" name="a3be6ba3083277ace59f6fb019fb10b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be6ba3083277ace59f6fb019fb10b06">&#9670;&#160;</a></span>DEFINE_ATTRIBUTE_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ATTRIBUTE_3</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt; { \</div>
<div class="line">        T##class_name(<a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt;void&gt;</a> <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">        <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;type&gt; \</div>
<div class="line">        (parent, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL), default_value) {} \</div>
<div class="line">        <span class="keyword">using </span><a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt;::operator =; \</div>
<div class="line">    } class_name = *<span class="keyword">this</span>;</div>
</div><!-- fragment -->
<p>Defines an optional attribute with a default value within a parent node structure. Similar to <code>DEFINE_ATTRIBUTE_2</code> but provides a default value if the attribute is not present in the source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The data type of the attribute. </td></tr>
    <tr><td class="paramname">class_name</td><td>The name of the member variable and base for the attribute node name. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value for the attribute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39e63d356bdf5ea6b486ecf63c2c3b5a" name="a39e63d356bdf5ea6b486ecf63c2c3b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e63d356bdf5ea6b486ecf63c2c3b5a">&#9670;&#160;</a></span>DEFINE_ATTRIBUTE_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ATTRIBUTE_LIST</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt; { \</div>
<div class="line">        T##class_name(<a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt;void&gt;</a> <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">            <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;type&gt; \</div>
<div class="line">                (parent, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">        <span class="keyword">using </span><a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;type&gt;::operator =; \</div>
<div class="line">        T##class_name( \</div>
<div class="line">            iridium::parsing::INode::TSharedPtr <span class="keyword">const</span> &amp;node, \</div>
<div class="line">            std::string <span class="keyword">const</span> &amp;path): \</div>
<div class="line">                <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;type&gt; \</div>
<div class="line">                    (node, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL), path) {} \</div>
<div class="line">        T##class_name(): \</div>
<div class="line">            iridium::parsing::serialization::NodeView&lt;type&gt; \</div>
<div class="line">                (iridium::parsing::serialization::<a class="code hl_function" href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">convertCamelToSplittedBySymbol</a>(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">    }; \</div>
<div class="line">    <span class="keyword">struct </span>T##class_name##List : <span class="keyword">public</span> iridium::parsing::serialization::NodeViewList&lt;T##class_name&gt; { \</div>
<div class="line">        T##class_name##List(iridium::parsing::serialization::NodeView&lt;void&gt; <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">        iridium::parsing::serialization::NodeViewList&lt;T##class_name&gt; \</div>
<div class="line">        (parent, iridium::parsing::serialization::<a class="code hl_function" href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">convertCamelToSplittedBySymbol</a>(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">    } class_name = *<span class="keyword">this</span>;</div>
<div class="ttc" id="anamespaceiridium_1_1parsing_1_1serialization_html_abe218db8e82dcf8ee1396b32af09e119"><div class="ttname"><a href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">iridium::parsing::serialization::convertCamelToSplittedBySymbol</a></div><div class="ttdeci">std::string convertCamelToSplittedBySymbol(std::string const &amp;camel, char const &amp;delimiter_symbol)</div><div class="ttdoc">Converts a string from CamelCase to a delimited format (e.g., snake_case or kebab-case)....</div><div class="ttdef"><b>Definition</b> node.cpp:88</div></div>
</div><!-- fragment -->
<p>Defines a list of simple attributes (value nodes) within a parent node structure. Generates <code>T##class_name</code> (inheriting <code>NodeView&lt;type&gt;</code>) for list items and <code>T##class_name##List</code> (inheriting <code>NodeViewList&lt;T##class_name&gt;</code>) for the list itself, then declares a member <code>class_name</code> of the list type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The data type of the attributes in the list. </td></tr>
    <tr><td class="paramname">class_name</td><td>The name of the member variable for the list and base for attribute node names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad47703aa4ae66d8d0699aa10e8cbe314" name="ad47703aa4ae66d8d0699aa10e8cbe314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47703aa4ae66d8d0699aa10e8cbe314">&#9670;&#160;</a></span>DEFINE_NODE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name : <span class="keyword">protected</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;void&gt; { \</div>
<div class="line">        T##class_name(<a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt;void&gt;</a> <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">        <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">        (parent, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {}</div>
</div><!-- fragment -->
<p>Begins the definition of a nested structured node within a parent node structure. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;void&gt;</code>. This struct is initialized with a reference to its parent <code>NodeView&lt;void&gt;</code>. The node name is derived from <code>class_name</code> using the parent's <code>NAME_DELIMETER_SYMBOL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the generated struct member (e.g., <code>NestedData</code> results in <code>TNestedData NestedData;</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac524ec1b1c08d1e9ec08f6231d693e85" name="ac524ec1b1c08d1e9ec08f6231d693e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac524ec1b1c08d1e9ec08f6231d693e85">&#9670;&#160;</a></span>DEFINE_NODE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    } class_name = *<span class="keyword">this</span>;</div>
</div><!-- fragment -->
<p>Ends the definition of a nested structured node and declares an instance of it. Provides the closing brace for the struct defined by <code>DEFINE_NODE_BEGIN</code> and declares a member variable of that struct type, named <code>class_name</code>, initialized with <code>*this</code> (the parent). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The name of the member variable to be declared (should match the <code>class_name</code> in <code>DEFINE_NODE_BEGIN</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac671d110728b8a4bd1ea52fc352c9120" name="ac671d110728b8a4bd1ea52fc352c9120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac671d110728b8a4bd1ea52fc352c9120">&#9670;&#160;</a></span>DEFINE_NODE_EXTERNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_EXTERNAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    T##class_name class_name = *<span class="keyword">this</span>;</div>
</div><!-- fragment -->
<p>Declares a member that is an instance of an externally defined root node structure. This allows composition of separately defined serializable structures. The member <code>class_name</code> will be of type <code>T##class_name</code>, which is expected to be defined elsewhere using <code>DEFINE_ROOT_NODE_BEGIN/END</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The name of the member variable and the base name of its type (e.g., <code>OtherConfig</code> implies type <code>TOtherConfig</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c49dbc67050d59e4b5e7d095067a81a" name="a1c49dbc67050d59e4b5e7d095067a81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c49dbc67050d59e4b5e7d095067a81a">&#9670;&#160;</a></span>DEFINE_NODE_LIST_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_LIST_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name##List; \</div>
<div class="line">    <span class="keyword">struct </span>T##class_name: <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;void&gt; { \</div>
<div class="line">        T##class_name( \</div>
<div class="line">        iridium::parsing::INode::TSharedPtr <span class="keyword">const</span> &amp;node, \</div>
<div class="line">        std::string <span class="keyword">const</span> &amp;path): \</div>
<div class="line">        <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">        (node, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL), path) {} \</div>
<div class="line">        T##class_name(): <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">        (<a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
</div><!-- fragment -->
<p>Begins the definition of a list of complex child nodes. Generates two structs: <code>T##class_name</code> (for individual list items, inheriting <code>NodeView&lt;void&gt;</code>) and <code>T##class_name##List</code> (for the list itself, inheriting <code>NodeViewList&lt;T##class_name&gt;</code>). The inner struct <code>T##class_name</code> is then defined by subsequent <code>DEFINE_ATTRIBUTE</code> or <code>DEFINE_NODE_BEGIN/END</code> calls before <code>DEFINE_NODE_LIST_END</code>. Note: A <code>todo</code> in the source mentions a potential bug with node naming for lists (e.g., "NameList" instead of "Name"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the list items and the list member itself (e.g., <code>Item</code> leads to <code>TItem</code> and <code>TItemList Item;</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1547f0c86e3c410b26dcf1d13d1fcec7" name="a1547f0c86e3c410b26dcf1d13d1fcec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1547f0c86e3c410b26dcf1d13d1fcec7">&#9670;&#160;</a></span>DEFINE_NODE_LIST_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_LIST_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    }; \</div>
<div class="line">    <span class="keyword">struct </span>T##class_name##List: <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html">iridium::parsing::serialization::NodeViewList</a>&lt;T##class_name&gt; { \</div>
<div class="line">        T##class_name##List(<a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView&lt;void&gt;</a> <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">        <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::<a class="code hl_function" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html#a4399b2754b3fbb51c83122b222aec249">NodeViewList</a>&lt;T##class_name&gt; \</div>
<div class="line">        (parent, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::<a class="code hl_function" href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">convertCamelToSplittedBySymbol</a>(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">    } class_name = *<span class="keyword">this</span>;</div>
<div class="ttc" id="aclassiridium_1_1parsing_1_1serialization_1_1_node_view_list_html"><div class="ttname"><a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html">iridium::parsing::serialization::NodeViewList</a></div><div class="ttdoc">Represents a list of NodeView objects of a specific type TNodeView. This class provides an interface ...</div><div class="ttdef"><b>Definition</b> node.h:226</div></div>
<div class="ttc" id="aclassiridium_1_1parsing_1_1serialization_1_1_node_view_list_html_a4399b2754b3fbb51c83122b222aec249"><div class="ttname"><a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_list.html#a4399b2754b3fbb51c83122b222aec249">iridium::parsing::serialization::NodeViewList::NodeViewList</a></div><div class="ttdeci">NodeViewList(NodeView&lt; void &gt; const &amp;parent, std::string const &amp;name)</div><div class="ttdoc">Constructor for NodeViewList. Initializes by finding all child nodes of parent that match name.</div><div class="ttdef"><b>Definition</b> node.h:450</div></div>
</div><!-- fragment -->
<p>Ends the definition of a list of complex child nodes and declares an instance of the list. Closes the <code>T##class_name</code> struct definition and defines the <code>T##class_name##List</code> struct, then declares a member variable <code>class_name</code> of type <code>T##class_name##List</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The name of the member variable for the list (should match <code>class_name</code> in <code>DEFINE_NODE_LIST_BEGIN</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39aa0a9c796142dba37f95ea182326e8" name="a39aa0a9c796142dba37f95ea182326e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aa0a9c796142dba37f95ea182326e8">&#9670;&#160;</a></span>DEFINE_NODE_LIST_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_LIST_PTR</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html">iridium::parsing::serialization::NodeViewPtr&lt;T##class_name##List&gt;</a> T##class_name##ListPtr; \</div>
<div class="line">    T##class_name##ListPtr class_name##_list_ptr = *<span class="keyword">this</span>;</div>
<div class="ttc" id="aclassiridium_1_1parsing_1_1serialization_1_1_node_view_ptr_html"><div class="ttname"><a href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html">iridium::parsing::serialization::NodeViewPtr</a></div><div class="ttdoc">A wrapper for a lazily-initialized shared pointer to a TNodeView. This is used for optional or recurs...</div><div class="ttdef"><b>Definition</b> node.h:311</div></div>
</div><!-- fragment -->
<p>Defines a member that is a lazily-initialized pointer (<code>NodeViewPtr</code>) to a list of complex child nodes. Useful for optional or recursive lists of nodes. Generates <code>T##class_name##ListPtr</code> typedef and a member <code>class_name##_list_ptr</code>. <code>T##class_name##List</code> is expected to be generated by <code>DEFINE_NODE_LIST_BEGIN/END</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the node list type (<code>T##class_name##List</code>) and the pointer member. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedcb3ac4bd4064c6b5bcc1014dd33080" name="aedcb3ac4bd4064c6b5bcc1014dd33080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcb3ac4bd4064c6b5bcc1014dd33080">&#9670;&#160;</a></span>DEFINE_NODE_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_NODE_PTR</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view_ptr.html">iridium::parsing::serialization::NodeViewPtr&lt;T##class_name&gt;</a> T##class_name##Ptr; \</div>
<div class="line">    T##class_name##Ptr class_name##_ptr = *<span class="keyword">this</span>;</div>
</div><!-- fragment -->
<p>Defines a member that is a lazily-initialized pointer (<code>NodeViewPtr</code>) to a nested structured node. Useful for optional or recursive node definitions. Generates a typedef <code>T##class_name##Ptr</code> and a member <code>class_name##_ptr</code> of this pointer type. <code>T##class_name</code> is expected to be defined using <code>DEFINE_NODE_BEGIN/END</code> or <code>DEFINE_ROOT_NODE_BEGIN/END</code> (if referencing another root type). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the node type (<code>T##class_name</code>) and the pointer member. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac8f5e72dee27b1c9479d82a20f96f62" name="aac8f5e72dee27b1c9479d82a20f96f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8f5e72dee27b1c9479d82a20f96f62">&#9670;&#160;</a></span>DEFINE_ROOT_NODE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ROOT_NODE_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="va__args_8h.html#a273c1a8de1c0ca2ed53c521bf0cd5744">DEFINE_MACRO_CHOOSER</a>(<a class="code hl_define" href="#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>, __VA_ARGS__)(__VA_ARGS__)</div>
<div class="ttc" id="aserialization_2node_8h_html_aac8f5e72dee27b1c9479d82a20f96f62"><div class="ttname"><a href="#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN(...)</div><div class="ttdoc">Chooser macro that dispatches to DEFINE_ROOT_NODE_BEGIN_1 or DEFINE_ROOT_NODE_BEGIN_2 based on the nu...</div><div class="ttdef"><b>Definition</b> node.h:595</div></div>
</div><!-- fragment -->
<p>Chooser macro that dispatches to <code>DEFINE_ROOT_NODE_BEGIN_1</code> or <code>DEFINE_ROOT_NODE_BEGIN_2</code> based on the number of arguments provided. Allows defining a root node with either a default name delimiter or a custom one. </p>

</div>
</div>
<a id="ac0d4794eb438b9b61fcf728aa00f7fd2" name="ac0d4794eb438b9b61fcf728aa00f7fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d4794eb438b9b61fcf728aa00f7fd2">&#9670;&#160;</a></span>DEFINE_ROOT_NODE_BEGIN_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ROOT_NODE_BEGIN_1</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#a7f018fdfb6121484592a761b4ab9eb18">DEFINE_ROOT_NODE_BEGIN_2</a>(class_name, <span class="charliteral">&#39;-&#39;</span>)</div>
<div class="ttc" id="aserialization_2node_8h_html_a7f018fdfb6121484592a761b4ab9eb18"><div class="ttname"><a href="#a7f018fdfb6121484592a761b4ab9eb18">DEFINE_ROOT_NODE_BEGIN_2</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN_2(class_name, name_delimeter_symbol)</div><div class="ttdoc">Begins the definition of a root node structure for serialization/deserialization. Generates a struct ...</div><div class="ttdef"><b>Definition</b> node.h:561</div></div>
</div><!-- fragment -->
<p>Begins the definition of a root node structure with a default name delimiter (<code>-</code>). This is a convenience macro that calls <code>DEFINE_ROOT_NODE_BEGIN_2</code> with &lsquo;&rsquo;-'<code>as the delimiter. \~russian @def <a class="el" href="#ac0d4794eb438b9b61fcf728aa00f7fd2" title="Begins the definition of a root node structure with a default name delimiter (-). This is a convenien...">DEFINE_ROOT_NODE_BEGIN_1(class_name)</a> @brief Начинает определение структуры корневого узла с разделителем имени по умолчанию (</code>-<code>). Это вспомогательный макрос, который вызывает</code>DEFINE_ROOT_NODE_BEGIN_2<code>с</code>'-'` в качестве разделителя. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the generated struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f018fdfb6121484592a761b4ab9eb18" name="a7f018fdfb6121484592a761b4ab9eb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f018fdfb6121484592a761b4ab9eb18">&#9670;&#160;</a></span>DEFINE_ROOT_NODE_BEGIN_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ROOT_NODE_BEGIN_2</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>class_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name_delimeter_symbol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>T##class_name : <span class="keyword">protected</span> <a class="code hl_class" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html">iridium::parsing::serialization::NodeView</a>&lt;void&gt; { \</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span> NAME_DELIMETER_SYMBOL = name_delimeter_symbol; \</div>
<div class="line">        T##class_name(iridium::parsing::INode::TSharedPtr <span class="keyword">const</span> &amp;node): \</div>
<div class="line">            <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">                (node, <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">            T##class_name(): <a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">                (<a class="code hl_namespace" href="namespaceiridium.html">iridium</a>::parsing::serialization::convertCamelToSplittedBySymbol(#class_name, NAME_DELIMETER_SYMBOL)) {} \</div>
<div class="line">            iridium::parsing::INode::TSharedPtr getNode()<span class="keyword"> const </span>{ \</div>
<div class="line">                <span class="keywordflow">return</span> <a class="code hl_function" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html#a73d0a8cf0b3dcc5ab8ca22f36e084983">iridium::parsing::serialization::NodeView&lt;void&gt;::getNode</a>(); \</div>
<div class="line">            } \</div>
<div class="line">        T##class_name(iridium::parsing::serialization::NodeView&lt;void&gt; <span class="keyword">const</span> &amp;parent): \</div>
<div class="line">            iridium::parsing::serialization::NodeView&lt;void&gt; \</div>
<div class="line">                (parent, iridium::parsing::serialization::<a class="code hl_function" href="namespaceiridium_1_1parsing_1_1serialization.html#abe218db8e82dcf8ee1396b32af09e119">convertCamelToSplittedBySymbol</a>(#class_name, NAME_DELIMETER_SYMBOL)) {}</div>
<div class="ttc" id="aclassiridium_1_1parsing_1_1serialization_1_1_node_view_html_a73d0a8cf0b3dcc5ab8ca22f36e084983"><div class="ttname"><a href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html#a73d0a8cf0b3dcc5ab8ca22f36e084983">iridium::parsing::serialization::NodeView::getNode</a></div><div class="ttdeci">INode::TSharedPtr getNode() const</div><div class="ttdoc">Gets the underlying INode shared pointer.</div><div class="ttdef"><b>Definition</b> node.h:365</div></div>
</div><!-- fragment -->
<p>Begins the definition of a root node structure for serialization/deserialization. Generates a struct <code>T##class_name</code> that inherits from <code>NodeView&lt;void&gt;</code>. It includes constructors for creating a new node or wrapping an existing <code>INode::TSharedPtr</code>. The node name is automatically derived from <code>class_name</code> using <code>convertCamelToSplittedBySymbol</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_name</td><td>The base name for the generated struct (e.g., <code>MyConfig</code> results in <code>TMyConfig</code>). </td></tr>
    <tr><td class="paramname">name_delimeter_symbol</td><td>The delimiter character used to convert <code>class_name</code> from CamelCase to the actual node name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4e724573d774904e29ede08ef7b17a" name="a7b4e724573d774904e29ede08ef7b17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4e724573d774904e29ede08ef7b17a">&#9670;&#160;</a></span>DEFINE_ROOT_NODE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_ROOT_NODE_END</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    };</div>
</div><!-- fragment -->
<p>Ends the definition of a root node structure started by <code>DEFINE_ROOT_NODE_BEGIN</code>. Simply provides the closing brace for the generated struct. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
