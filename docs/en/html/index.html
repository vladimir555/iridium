<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iridium: Iridium</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iridium<span id="projectnumber">&#160;0.9.95</span>
   </div>
   <div id="projectbrief">Lightweight C++ framework (logging, serialization, threads, processes, I/O, testing)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iridium </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_mainpage__en"></a> </p><div style="float: left; margin-right: 15px; max-height: 50px;"> <div class="image">
<img src="logo.png" alt="" width="100px"/>
</div>
 </div><p>Welcome to the Iridium Library documentation!</p>
<p>This documentation provides information on how to use various components of the Iridium library. Explore the sections below to learn about its features.</p>
<h1 class="doxsection"><a class="anchor" id="sec_parsers_serializers"></a>
Parsers and Serializers</h1>
<p>The Iridium library provides a flexible mechanism for parsing data from string representations into a structured node tree, and for serializing (composing) these node trees back into strings. This is primarily achieved through the <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Interface for a generic parser.">iridium::parsing::IParser</a></span> interface.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_iparser"></a>
The IParser Interface</h2>
<p>The <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Interface for a generic parser.">iridium::parsing::IParser</a></span> interface (defined in <span class="tt"><a class="el" href="parser_8h.html" title="Defines the IParser interface for parsing and composing structured data. This interface provides meth...">iridium/parsing/parser.h</a></span>) is the core component for parsing and serialization. It exposes two main methods:</p><ul>
<li><span class="tt">parse(const std::string&amp; source)</span>: Takes a string as input and returns an <span class="tt">iridium::parsing::INode::TSharedPtr</span>, which is the root of a tree structure representing the parsed data.</li>
<li><span class="tt">compose(iridium::parsing::INode::TConstSharedPtr const&amp; root_node)</span>: Takes the root node of a tree structure and returns its string representation.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_obtaining_parser"></a>
Obtaining a Parser</h2>
<p>Specific parser implementations are provided for different data formats. For example, to create a JSON parser, you can use its static <span class="tt">create()</span> method:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span> <span class="comment">// For CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span> <span class="comment">// For IParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span>   <span class="comment">// For INode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (jsonParser) {</div>
<div class="line">        <span class="comment">// Use the parser...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;JSON Parser created successfully.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anode_8h_html"><div class="ttname"><a href="node_8h.html">node.h</a></div><div class="ttdoc">Defines the INode typedef, a specialization of INodeType&lt;std::string&gt;. This serves as the primary typ...</div></div>
<div class="ttc" id="aparser_8h_html"><div class="ttname"><a href="parser_8h.html">parser.h</a></div><div class="ttdoc">Defines the IParser interface for parsing and composing structured data. This interface provides meth...</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_parsing_example"></a>
Parsing Example (JSON)</h2>
<p>Here's how you can parse a JSON string into an <span class="tt">INode</span> tree:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string jsonString = R<span class="stringliteral">&quot;({ &quot;name&quot;: &quot;IridiumApp&quot;, &quot;version&quot;: 1.0, &quot;modules&quot;: [&quot;parsing&quot;, &quot;logging&quot;] })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonString);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;JSON parsed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// You can now inspect the rootNode tree structure.</span></div>
<div class="line">            <span class="comment">// For example, to get the &#39;name&#39; attribute:</span></div>
<div class="line">            iridium::parsing::INode::TSharedPtr nameNode = rootNode-&gt;getChild(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (nameNode) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Application Name: &quot;</span> &lt;&lt; nameNode-&gt;getValue() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Parsing returned a null node (empty input or other non-error case).&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_serializing_example"></a>
Serialization Example (JSON)</h2>
<p>To serialize an <span class="tt">INode</span> tree (for example, one you constructed programmatically or obtained from parsing) back into a JSON string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// For CNode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a simple node structure programmatically</span></div>
<div class="line">    iridium::parsing::INode::TSharedPtr root = iridium::parsing::implementation::CNode::create(<span class="stringliteral">&quot;config&quot;</span>);</div>
<div class="line">    root-&gt;addChild(<span class="stringliteral">&quot;setting1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line">    iridium::parsing::INode::TSharedPtr subNode = root-&gt;addChild(<span class="stringliteral">&quot;advanced_settings&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;timeout&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;retries&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::string composedJson = jsonParser-&gt;compose(root);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Composed JSON: &quot;</span> &lt;&lt; composedJson &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Composition failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aimplementation_2node_8h_html"><div class="ttname"><a href="implementation_2node_8h.html">node.h</a></div><div class="ttdoc">Defines the CNode typedef, a concrete node implementation based on CNodeType&lt;std::string&gt;....</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_serialization_macros"></a>
Typed Serialization with NodeView</h2>
<p>For more complex C++ data structures, the Iridium library offers a powerful serialization/deserialization framework based on <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="A view class for a node with a specific value type. Provides a convenient way to access and modify no...">iridium::parsing::serialization::NodeView</a></span> and a set_of macros (like <span class="tt"><a class="el" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></span>, <span class="tt"><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></span>, <span class="tt"><a class="el" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></span>, etc.). These tools allow you to define C++ structs and classes that can be easily converted to and from an <span class="tt">INode</span> tree, and subsequently to/from string formats like JSON.</p>
<p>This system provides typed access to the node tree and automates much of the boilerplate code for serialization and deserialization. For detailed usage and examples, please refer to the header file <span class="tt"><a class="el" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a></span>.</p>
<p>Here's a more concrete example of how to use these macros:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a>&quot;</span> <span class="comment">// For serialization macros</span></div>
<div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span> <span class="comment">// For CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// For CNode (used by macros)</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For convert (used by macros)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span> <span class="comment">// Used by NodeViewList</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Required for the macros to compile if string conversions are needed.</span></div>
<div class="line"><span class="comment">// Normally, you&#39;d have these specializations for your custom types if they aren&#39;t basic.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a simple data item structure</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MyDataItem) <span class="comment">// Root node for direct use or nesting, uses &#39;-&#39; delimiter by default</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::string, Name, <span class="stringliteral">&quot;DefaultName&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, Value, 0)</div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a more complex settings structure</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MySettings) <span class="comment">// Root node, uses &#39;-&#39; delimiter</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ConfigName, <span class="stringliteral">&quot;DefaultConfig&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">bool</span>, IsEnabled, true)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a nested node using a previously defined root node structure</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a>(MyDataItem) <span class="comment">// Member name will be &#39;MyDataItem&#39;, node name &#39;my-data-item&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a list of MyDataItem</span></div>
<div class="line">    <span class="comment">// The list member will be named &#39;ItemList&#39;, and each item node will be named &#39;item&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a>(Item) <span class="comment">// This defines TItem and TItemList</span></div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ItemName, <span class="stringliteral">&quot;DefaultItem&quot;</span>)</div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, ItemId, 0)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a>(Item) <span class="comment">// Member name &#39;Item&#39; of type TItemList</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create an instance of the JSON parser</span></div>
<div class="line">    <span class="keyword">auto</span> jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Serialization Example ---</span></div>
<div class="line">    MySettings settingsToSerialize;</div>
<div class="line">    settingsToSerialize.ConfigName = <span class="stringliteral">&quot;UserSettings&quot;</span>;</div>
<div class="line">    settingsToSerialize.IsEnabled = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    settingsToSerialize.MyDataItem.Name = <span class="stringliteral">&quot;Special Item&quot;</span>;</div>
<div class="line">    settingsToSerialize.MyDataItem.Value = 123;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add items to the list</span></div>
<div class="line">    MySettings::TItem item1; <span class="comment">// Note: TItem is nested in MySettings due to DEFINE_NODE_LIST_BEGIN</span></div>
<div class="line">    item1.ItemName = <span class="stringliteral">&quot;FirstListItem&quot;</span>;</div>
<div class="line">    item1.ItemId = 1;</div>
<div class="line">    settingsToSerialize.Item.add(item1);</div>
<div class="line"> </div>
<div class="line">    MySettings::TItem item2;</div>
<div class="line">    item2.ItemName = <span class="stringliteral">&quot;SecondListItem&quot;</span>;</div>
<div class="line">    item2.ItemId = 2;</div>
<div class="line">    settingsToSerialize.Item.add(item2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// Get the INode from our settings object and compose it to JSON</span></div>
<div class="line">        std::string jsonOutput = jsonParser-&gt;compose(settingsToSerialize.getNode());</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Serialized JSON:&quot;</span> &lt;&lt; std::endl &lt;&lt; jsonOutput &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Expected output structure:</span></div>
<div class="line">        <span class="comment">// {</span></div>
<div class="line">        <span class="comment">//   &quot;config-name&quot;: &quot;UserSettings&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;is-enabled&quot;: &quot;true&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;my-data-item&quot;: {</span></div>
<div class="line">        <span class="comment">//     &quot;name&quot;: &quot;Special Item&quot;,</span></div>
<div class="line">        <span class="comment">//     &quot;value&quot;: &quot;123&quot;</span></div>
<div class="line">        <span class="comment">//   },</span></div>
<div class="line">        <span class="comment">//   &quot;item&quot;: [</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;FirstListItem&quot;, &quot;item-id&quot;: &quot;1&quot; },</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;SecondListItem&quot;, &quot;item-id&quot;: &quot;2&quot; }</span></div>
<div class="line">        <span class="comment">//   ]</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Serialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Deserialization Example ---</span></div>
<div class="line">    std::string jsonInput = R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">        &quot;config-name&quot;: &quot;LoadedSettings&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;is-enabled&quot;: &quot;false&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;my-data-item&quot;: {</span></div>
<div class="line"><span class="stringliteral">            &quot;name&quot;: &quot;LoadedItem&quot;,</span></div>
<div class="line"><span class="stringliteral">            &quot;value&quot;: &quot;456&quot;</span></div>
<div class="line"><span class="stringliteral">        },</span></div>
<div class="line"><span class="stringliteral">        &quot;item&quot;: [</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem1&quot;, &quot;item-id&quot;: &quot;10&quot; },</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem2&quot;, &quot;item-id&quot;: &quot;20&quot; }</span></div>
<div class="line"><span class="stringliteral">        ]</span></div>
<div class="line"><span class="stringliteral">    })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonInput);</div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            MySettings deserializedSettings(rootNode); <span class="comment">// Construct MySettings from the INode</span></div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Deserialized Settings:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Config Name: &quot;</span> &lt;&lt; deserializedSettings.ConfigName.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Is Enabled: &quot;</span> &lt;&lt; (deserializedSettings.IsEnabled.get() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Name: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Name.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Value: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Value.get() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;List Items:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : deserializedSettings.Item) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  - Name: &quot;</span> &lt;&lt; item.ItemName.get() &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; item.ItemId.get() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing input JSON returned a null node.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Deserialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconvert_8h_html"><div class="ttname"><a href="convert_8h.html">convert.h</a></div><div class="ttdoc">Provides a generic type conversion framework.</div></div>
<div class="ttc" id="aserialization_2node_8h_html"><div class="ttname"><a href="serialization_2node_8h.html">node.h</a></div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1547f0c86e3c410b26dcf1d13d1fcec7"><div class="ttname"><a href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_END(class_name)</div><div class="ttdef"><b>Definition</b> node.h:464</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1c49dbc67050d59e4b5e7d095067a81a"><div class="ttname"><a href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_BEGIN(class_name)</div><div class="ttdef"><b>Definition</b> node.h:452</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a6ae6809e071cbeb286389a6ea722e126"><div class="ttname"><a href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE(...)</div><div class="ttdef"><b>Definition</b> node.h:447</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a7b4e724573d774904e29ede08ef7b17a"><div class="ttname"><a href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_END()</div><div class="ttdef"><b>Definition</b> node.h:414</div></div>
<div class="ttc" id="aserialization_2node_8h_html_aac8f5e72dee27b1c9479d82a20f96f62"><div class="ttname"><a href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN(...)</div><div class="ttdef"><b>Definition</b> node.h:410</div></div>
<div class="ttc" id="aserialization_2node_8h_html_ac671d110728b8a4bd1ea52fc352c9120"><div class="ttname"><a href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a></div><div class="ttdeci">#define DEFINE_NODE_EXTERNAL(class_name)</div><div class="ttdef"><b>Definition</b> node.h:495</div></div>
</div><!-- fragment --><p>This example demonstrates defining structures with attributes, nested nodes, and lists of nodes. It then shows how to populate an instance of such a structure, serialize it to JSON, and deserialize JSON back into the structure using the <span class="tt">IParser</span> interface in conjunction with the node views generated by the macros. The <span class="tt">getNode()</span> method on the macro-defined struct provides the <span class="tt">INode</span> needed for <span class="tt">compose</span>, and the struct's constructor can take an <span class="tt">INode</span> (from <span class="tt">parse</span>) to populate itself. Remember that the actual node names in the JSON (e.g., "config-name") are derived from the C++ member names by converting CamelCase and inserting a delimiter (default is '-').</p>
<h1 class="doxsection"><a class="anchor" id="sec_logging"></a>
Logger Usage and Configuration</h1>
<p>The Iridium library includes a flexible logging facility to help instrument your application and diagnose issues. It supports multiple output destinations (sinks), configurable log levels, and asynchronous logging.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_logging_macros"></a>
Basic Logging</h2>
<p>The easiest way to log messages is by using the provided logging macros:</p><ul>
<li><span class="tt"><a class="el" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; "Trace message";</span> (Trace level, often includes file/line, typically for debug builds)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; "Debug message";</span> (Debug level, typically for debug builds)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; "Informational message";</span> (Info level)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; "Warning message";</span> (Warning level)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; "Error message";</span> (Error level)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ac4c513cbda38bfa3bace1f2420511271">LOGF</a> &lt;&lt; "Fatal message";</span> (Fatal level)</li>
</ul>
<p>These macros create a temporary log stream object. You can stream data into them using the <span class="tt">&lt;&lt;</span> operator, similar to <span class="tt">std::cout</span>. When the statement ends, the log message is automatically formatted and sent to the configured log sinks.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span> <span class="comment">// Main header for logging</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Basic configuration (default console output) is usually set up if no custom config is provided.</span></div>
<div class="line">    <span class="comment">// For more control, see configuration examples below.</span></div>
<div class="line">    <span class="comment">// iridium::logging::setConfig(iridium::logging::config::createDefault()); // Example of setting default</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> count = 42;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;Application started. Current count: &quot;</span> &lt;&lt; count;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This is a debug message. It might not appear in release builds.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (count &gt; 100) {</div>
<div class="line">        <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;Count is higher than expected: &quot;</span> &lt;&lt; count;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// LOGE &lt;&lt; &quot;An example error occurred.&quot;;</span></div>
<div class="line">    <span class="comment">// LOGF &lt;&lt; &quot;A fatal error occurred, application might terminate.&quot;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html"><div class="ttname"><a href="logger_8h.html">logger.h</a></div></div>
<div class="ttc" id="alogger_8h_html_a13fd5c842ec8d93baac58bb616497fe8"><div class="ttname"><a href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a></div><div class="ttdeci">#define LOGI</div><div class="ttdef"><b>Definition</b> logger.h:194</div></div>
<div class="ttc" id="alogger_8h_html_a62b5282578b939fd77b7bb1d00c4f15a"><div class="ttname"><a href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a></div><div class="ttdeci">#define LOGD</div><div class="ttdef"><b>Definition</b> logger.h:189</div></div>
<div class="ttc" id="alogger_8h_html_ac6f0b43ab85743ce5de50d53bda6de62"><div class="ttname"><a href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a></div><div class="ttdeci">#define LOGW</div><div class="ttdef"><b>Definition</b> logger.h:198</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_logger_configuration"></a>
Logger Configuration</h2>
<p>The logger is configured using the <span class="tt">iridium::logging::config::TLogger</span> structure, which is defined in <span class="tt"><a class="el" href="logging_2config_8h.html">iridium/logging/config.h</a></span>. This structure can be populated programmatically or potentially loaded from a configuration file (if parsed into an <span class="tt">INode</span> tree).</p>
<p>Key fields in <span class="tt">iridium::logging::config::TLogger</span>:</p><ul>
<li><span class="tt">IsGmtTime</span> (bool): If <span class="tt">true</span>, timestamps are in GMT/UTC; otherwise, local time is used. Defaults to <span class="tt">false</span>.</li>
<li><span class="tt">Level</span> (<span class="tt">iridium::logging::TEvent::TLevel</span>): The global default log level. Specific sinks can override this. Defaults to <span class="tt">TRACE</span>.</li>
<li><span class="tt">Sink</span> (a list of <span class="tt">TLogger::TSink</span> objects): Defines one or more output destinations for log messages.</li>
</ul>
<p>Each <span class="tt">TLogger::TSink</span> object in the <span class="tt">Sink</span> list has the following key fields:</p><ul>
<li><span class="tt">Type</span> (<span class="tt">iridium::logging::config::TLogger::TSink::TSinkType</span>): Specifies the sink type. Common values:<ul>
<li><span class="tt">CONSOLE</span>: Output to the standard console.</li>
<li><span class="tt">FILE</span>: Output to a single file.</li>
<li><span class="tt">FILE_DAILY</span>: Output to a file that rotates daily.</li>
<li><span class="tt">FILE_TIMELY</span>: Output to a new file every time the logger starts.</li>
</ul>
</li>
<li><span class="tt">IsAsync</span> (bool): If <span class="tt">true</span>, this sink processes log messages asynchronously in a separate thread. Defaults to <span class="tt">false</span>.</li>
<li><span class="tt">Uri</span> (std::string): For file-based sinks (<span class="tt">FILE</span>, <span class="tt">FILE_DAILY</span>, <span class="tt">FILE_TIMELY</span>), this is the path to the log file.</li>
<li><span class="tt">Level</span> (<span class="tt">iridium::logging::TEvent::TLevel</span>): A specific log level for this sink. If set to <span class="tt">UNKNOWN</span>, it inherits the global logger level. Otherwise, it overrides the global level for this particular sink.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_logger_config_example"></a>
Programmatic Configuration Example</h2>
<p>Here's how to configure the logger programmatically:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logging_2config_8h.html">iridium/logging/config.h</a>&quot;</span> <span class="comment">// For TLogger, TEvent::TLevel, etc.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Create a TLogger configuration object</span></div>
<div class="line">    iridium::logging::config::TLogger loggerConfig;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set global properties</span></div>
<div class="line">    loggerConfig.IsGmtTime = <span class="keyword">false</span>;</div>
<div class="line">    loggerConfig.Level = iridium::logging::TEvent::TLevel::INFO; <span class="comment">// Global level</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Configure a Console Sink</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink consoleSink;</div>
<div class="line">    consoleSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::CONSOLE;</div>
<div class="line">    consoleSink.IsAsync = <span class="keyword">false</span>;</div>
<div class="line">    consoleSink.Level = iridium::logging::TEvent::TLevel::DEBUG; <span class="comment">// Console will show DEBUG and above</span></div>
<div class="line">    loggerConfig.Sink.add(consoleSink); <span class="comment">// Add to the list of sinks</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Configure a File Sink</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink fileSink;</div>
<div class="line">    fileSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::FILE;</div>
<div class="line">    fileSink.IsAsync = <span class="keyword">true</span>; <span class="comment">// Log to file asynchronously</span></div>
<div class="line">    fileSink.Uri = <span class="stringliteral">&quot;application.log&quot;</span>;</div>
<div class="line">    fileSink.Level = iridium::logging::TEvent::TLevel::WARNING; <span class="comment">// File will only get WARNING and above</span></div>
<div class="line">    loggerConfig.Sink.add(fileSink);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Apply the configuration</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a>(loggerConfig);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now the logger is configured.</span></div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; <span class="stringliteral">&quot;This TRACE message will not appear on console or file.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This DEBUG message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;This INFO message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;This WARNING message will appear on console AND in application.log.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; <span class="stringliteral">&quot;This ERROR message will also appear on console AND in application.log.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html_a4f7814d1bd32cecccb2f3fafbb3ade58"><div class="ttname"><a href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a></div><div class="ttdeci">#define LOGT</div><div class="ttdef"><b>Definition</b> logger.h:180</div></div>
<div class="ttc" id="alogger_8h_html_ae08358ff7da64345ad674296a5957823"><div class="ttname"><a href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a></div><div class="ttdeci">#define LOGE</div><div class="ttdef"><b>Definition</b> logger.h:202</div></div>
<div class="ttc" id="alogging_2config_8h_html"><div class="ttname"><a href="logging_2config_8h.html">config.h</a></div></div>
<div class="ttc" id="anamespaceiridium_1_1logging_html_a4fff5fa51c4d1b05c97ae08faf5efd18"><div class="ttname"><a href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a></div><div class="ttdeci">void setConfig(config::TLogger const &amp;config)</div><div class="ttdoc">Sets the global logger configuration.</div><div class="ttdef"><b>Definition</b> logger.cpp:169</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_default_config"></a>
Default Configuration</h2>
<p>The library provides a helper function to get a simple default configuration: <span class="tt">iridium::logging::config::TLogger defaultConfig = <a class="el" href="namespaceiridium_1_1logging_1_1config.html#a57a36466c8a3545a48ab706922b86672">iridium::logging::config::createDefault()</a>;</span></p>
<p>This default configuration typically sets up a synchronous console sink with the <span class="tt">TRACE</span> log level. You can modify this default configuration object before applying it with <span class="tt"><a class="el" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18" title="Sets the global logger configuration.">iridium::logging::setConfig()</a></span>.</p>
<p>Remember that logger configuration should ideally be done early in your application's lifecycle, before any significant logging occurs.</p>
<h1 class="doxsection"><a class="anchor" id="sec_custom_type_conversion"></a>
Integrating Custom Types with <span class="tt">iridium::convertion::convert</span></h1>
<p>The Iridium library provides a flexible way to integrate your custom data types with its systems, such as logging and the serialization macros. This is achieved by providing specializations for the <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a>&lt;TargetType, SourceType&gt;</span> template function for your custom type.</p>
<p>The library offers a pair of macros to help declare and implement these specializations:</p><ul>
<li><b><span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Macro to define a conversion between two types.">DEFINE_CONVERT(TTo, TFrom)</a></span></b>: This macro should be used in your header file (e.g., alongside your custom type definition). It declares to the compiler that a specific conversion specialization will be made available.</li>
<li><b><span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Macro to implement a conversion between two types using a function.">IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</a></span></b>: This macro is used in a source file (.cpp) to provide the actual implementation for the conversion. <span class="tt">TFunc</span> must be a function, functor, or lambda that takes a <span class="tt">TFrom const&amp;</span> argument and returns a <span class="tt">TTo</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_custom_convert_example_fn"></a>
Example: Custom <span class="tt">Point</span> Type</h2>
<p>Let's illustrate with a custom <span class="tt">Point</span> struct.</p>
<p><b>1. Define the Type and Declare Conversions (e.g., in <span class="tt">Point.h</span>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once </span><span class="comment">// Example header guard</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For DEFINE_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span> <span class="comment">// Required for std::string usage</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom struct</span></div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optional: For direct comparison in examples or tests</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> x == other.x &amp;&amp; y == other.y;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declare that we will provide specializations for converting</span></div>
<div class="line"><span class="comment">// Point to std::string and std::string to Point.</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(std::string, Point);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(Point, std::string);</div>
<div class="ttc" id="aconvert_8h_html_ab6323540b384b64371e62ea6e910317b"><div class="ttname"><a href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a></div><div class="ttdeci">#define DEFINE_CONVERT(TTo, TFrom)</div><div class="ttdoc">Macro to define a conversion between two types.</div><div class="ttdef"><b>Definition</b> convert.h:67</div></div>
</div><!-- fragment --><p><b>2. Implement the Conversions (e.g., in <span class="tt">Point.cpp</span>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Assuming Point struct and DEFINE_CONVERT declarations are here</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For IMPLEMENT_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// For std::invalid_argument, std::out_of_range</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper function to convert Point to std::string</span></div>
<div class="line"><span class="keyword">static</span> std::string localPointToString(<span class="keyword">const</span> Point&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + std::to_string(p.x) + <span class="stringliteral">&quot;,&quot;</span> + std::to_string(p.y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper function to convert std::string to Point</span></div>
<div class="line"><span class="keyword">static</span> Point localStringToPoint(<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s.length() &lt; 3 || s.front() != <span class="charliteral">&#39;(&#39;</span> || s.back() != <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing parentheses. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    std::string content = s.substr(1, s.length() - 2); <span class="comment">// Remove parentheses</span></div>
<div class="line">    <span class="keywordtype">size_t</span> comma_pos = content.find(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (comma_pos == std::string::npos) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing comma. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordtype">int</span> x_val = std::stoi(content.substr(0, comma_pos));</div>
<div class="line">        <span class="keywordtype">int</span> y_val = std::stoi(content.substr(comma_pos + 1));</div>
<div class="line">        <span class="keywordflow">return</span> {x_val, y_val};</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e_ia) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid integer in Point string: &quot;</span> + std::string(e_ia.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; e_oor) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Integer out of range in Point string: &quot;</span> + std::string(e_oor.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement the declared conversion specializations using the helper functions</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(std::string, Point, localPointToString);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(Point, std::string, localStringToPoint);</div>
<div class="ttc" id="aconvert_8h_html_aa14ff619763935045ee893f7f1e8668f"><div class="ttname"><a href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a></div><div class="ttdeci">#define IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</div><div class="ttdoc">Macro to implement a conversion between two types using a function.</div><div class="ttdef"><b>Definition</b> convert.h:78</div></div>
</div><!-- fragment --><p><b>3. Usage Example (e.g., in <span class="tt">main.cpp</span> or tests)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Your custom type&#39;s header</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span>   <span class="comment">// For LOGI (example usage)</span></div>
<div class="line"><span class="comment">// For serialization macros example (conceptual)</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/serialization/node.h&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// For std::cout</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main_custom_convert_demo() { <span class="comment">// Renamed to avoid collision if mainpage.md is compiled</span></div>
<div class="line">    Point p1 = {7, 14};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Logging Example:</span></div>
<div class="line">    <span class="comment">// The iridium::logging::LogStream typically uses iridium::convertion::convert&lt;std::string&gt;(value)</span></div>
<div class="line">    <span class="comment">// for types that don&#39;t have a direct std::ostream&amp; operator&lt;&lt; overload.</span></div>
<div class="line">    <span class="comment">// So, after defining the conversion, this should work:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;My custom point: &quot; &lt;&lt; p1;</span></div>
<div class="line">    <span class="comment">// For this example, we&#39;ll demonstrate the conversion explicitly:</span></div>
<div class="line">    std::string p1AsString = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(p1);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Point p1 converted to string: &quot;</span> &lt;&lt; p1AsString &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Deserialization Example (e.g., from a configuration string):</span></div>
<div class="line">    std::string inputString = <span class="stringliteral">&quot;(100,-200)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        Point p2 = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;Point&gt;</a>(inputString);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;String &#39;&quot;</span> &lt;&lt; inputString &lt;&lt; <span class="stringliteral">&quot;&#39; converted to Point: (&quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; p2.y &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error converting string to Point: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// How this applies to serialization macros:</span></div>
<div class="line">    <span class="comment">// If you define a serializable struct like this:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyStructure)</span></div>
<div class="line">    <span class="comment">//   DEFINE_ATTRIBUTE(Point, Position) // Uses Point</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// MyStructure data;</span></div>
<div class="line">    <span class="comment">// data.Position = {5,5}; // Set the Point</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // When serializing:</span></div>
<div class="line">    <span class="comment">// // auto jsonParser = iridium::parsing::implementation::CJSONParser::create();</span></div>
<div class="line">    <span class="comment">// // std::string json_output = jsonParser-&gt;compose(data.getNode());</span></div>
<div class="line">    <span class="comment">// // ...the &#39;Position&#39; node&#39;s value would be &quot;(5,5)&quot; due to Convert&lt;std::string, Point&gt;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // When deserializing:</span></div>
<div class="line">    <span class="comment">// // std::string json_input = R&quot;({ &quot;position&quot;: &quot;(10,20)&quot; })&quot;;</span></div>
<div class="line">    <span class="comment">// // MyStructure loaded_data(jsonParser-&gt;parse(json_input));</span></div>
<div class="line">    <span class="comment">// // ...the string &quot;(10,20)&quot; would be converted to a Point object for &#39;Position&#39;</span></div>
<div class="line">    <span class="comment">// //    due to Convert&lt;Point, std::string&gt;.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceiridium_1_1convertion_html_aaf31a5335a6afae5d2fdffcdd0b83483"><div class="ttname"><a href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert</a></div><div class="ttdeci">TResult convert(TValue const &amp;value)</div><div class="ttdoc">Converts a value from a source type to a target type.</div><div class="ttdef"><b>Definition</b> convert.h:37</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_custom_convert_fn_impact"></a>
Impact of Custom <span class="tt">convert</span> Specializations</h2>
<p><b>For Logging:</b> Once you provide a specialization <span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Macro to define a conversion between two types.">DEFINE_CONVERT(std::string, YourCustomType)</a></span> and its implementation, your custom objects can often be directly used in logging statements (e.g., <span class="tt"><a class="el" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; yourCustomObject;</span>). The logging framework will typically call <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a>&lt;std::string&gt;(yourCustomObject)</span> to get a string representation if no direct <span class="tt">operator&lt;&lt;(std::ostream&amp;, const YourCustomType&amp;)</span> is found or preferred.</p>
<p><b>For Serialization Macros:</b> When using serialization macros like <span class="tt"><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE(YourCustomType, myField)</a></span>:</p><ul>
<li>The specialization for <span class="tt">Convert&lt;std::string, YourCustomType&gt;</span> (implemented via <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Macro to implement a conversion between two types using a function.">IMPLEMENT_CONVERT</a></span>) is used to convert the <span class="tt">myField</span> member into its string representation when serializing the parent structure. This string is then stored as the value of the corresponding node (e.g., a JSON string attribute or an XML text node).</li>
<li>The specialization for <span class="tt">Convert&lt;YourCustomType, std::string&gt;</span> (implemented via <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Macro to implement a conversion between two types using a function.">IMPLEMENT_CONVERT</a></span>) is used during deserialization. If the parser reads a string value from the input data (e.g., from a JSON attribute) that needs to be converted to <span class="tt">YourCustomType</span> for <span class="tt">myField</span>, this specialization will be invoked.</li>
</ul>
<p>By providing these <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">convert</a></span> function specializations, you enable your custom data types to integrate smoothly with various parts of the Iridium library that rely on type conversion, particularly for string-based representations. Remember to declare the specializations with <span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Macro to define a conversion between two types.">DEFINE_CONVERT</a></span> in a header and implement them with <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Macro to implement a conversion between two types using a function.">IMPLEMENT_CONVERT</a></span> and your conversion logic in a source file.</p>
<h1 class="doxsection"><a class="anchor" id="sec_define_enum"></a>
Handling Enumerations with DEFINE_ENUM</h1>
<p>The Iridium library often provides a utility macro, <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span> (typically expected in a header like <span class="tt"><a class="el" href="enum_8h.html" title="Provides macros for defining and implementing type-safe enums with reflection capabilities.">iridium/enum.h</a></span> or a general utilities header), to simplify the definition of C++ <span class="tt">enum class</span> types and automatically integrate them with the <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a></span> system. This integration is crucial for easily logging enum values as human-readable strings and for serializing/deserializing them in configuration files or data interchange formats.</p>
<p><b>Key Functionality of <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span>:</b></p>
<p>When you use <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span>, it generally performs the following actions:</p><ol type="1">
<li><b>Defines the <span class="tt">enum class</span></b>: It creates the actual C++ <span class="tt">enum class</span> with the specified name and enumerators.</li>
<li><b>Generates String Conversions</b>: Most importantly, it automatically generates the necessary specializations for <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a></span> to allow:<ul>
<li>Converting an enum value to its string representation (e.g., <span class="tt">MyEnum::ValueOne</span> becomes <span class="tt">"ValueOne"</span>).</li>
<li>Converting a string representation back to an enum value (e.g., <span class="tt">"ValueOne"</span> becomes <span class="tt">MyEnum::ValueOne</span>).</li>
</ul>
</li>
</ol>
<p><b>Typical Syntax:</b></p>
<p>While the exact syntax can vary slightly based on the specific macro implementation, a common pattern is:</p>
<p><span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM(EnumTypeName, Enumerator1, Enumerator2, ..., [OptionalDefaultOrUnknownEnumerator])</a></span></p>
<ul>
<li><span class="tt">EnumTypeName</span>: The desired name for your <span class="tt">enum class</span>.</li>
<li><span class="tt">Enumerator1, Enumerator2, ...</span>: The list of enumerator names.</li>
<li><span class="tt">[OptionalDefaultOrUnknownEnumerator]</span>: Often, the last enumerator can be designated (e.g., named <span class="tt">Unknown</span> or <span class="tt">Default</span>) to serve as a fallback value if a string cannot be successfully parsed into one of the other defined enumerators. If not specified, attempting to convert an invalid string to the enum type might result in the first enumerator being returned, or potentially an error, depending on the macro's design.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_define_enum_example"></a>
Example Usage</h2>
<p>Let's illustrate with a couple of examples. (Ensure you include the header that provides <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span>, e.g., <span class="tt">#include "<a class="el" href="enum_8h.html" title="Provides macros for defining and implementing type-safe enums with reflection capabilities.">iridium/enum.h</a>"</span>)</p>
<div class="fragment"><div class="line"><span class="comment">// Note: The DEFINE_ENUM macro is provided by the Iridium library.</span></div>
<div class="line"><span class="comment">// You would typically include a header like &lt;iridium/enum.h&gt; to use it.</span></div>
<div class="line"><span class="comment">// mainpage_example_define_enum.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// It&#39;s assumed that &quot;iridium/enum.h&quot; or a similar header defining DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// and &quot;iridium/convertion/convert.h&quot; are available.</span></div>
<div class="line"><span class="comment">// For this example, we&#39;ll mock the macro&#39;s expected behavior for demonstration if needed,</span></div>
<div class="line"><span class="comment">// but ideally, it comes from the library.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 1: Simple Color Enumeration</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(MyColor,</div>
<div class="line">    Red,    <span class="comment">// Mapped to &quot;Red&quot;</span></div>
<div class="line">    Green,  <span class="comment">// Mapped to &quot;Green&quot;</span></div>
<div class="line">    Blue    <span class="comment">// Mapped to &quot;Blue&quot;</span></div>
<div class="line">) <span class="comment">// MyColor will have MyColor::Red, MyColor::Green, MyColor::Blue</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 2: Operation Status with an explicit Unknown/Default value</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(OperationStatus,</div>
<div class="line">    Success,</div>
<div class="line">    Pending,</div>
<div class="line">    Failed,</div>
<div class="line">    Unknown <span class="comment">// This can serve as a default if parsing a string fails</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/logging/logger.h&quot; // For LOGI (conceptual)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_define_enum_usage() {</div>
<div class="line">    MyColor favoriteColor = MyColor::Green;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert enum to string (e.g., for logging or serialization)</span></div>
<div class="line">    <span class="comment">// The DEFINE_ENUM macro is expected to have created the necessary</span></div>
<div class="line">    <span class="comment">// iridium::convertion::convert&lt;std::string, MyColor&gt; specialization.</span></div>
<div class="line">    std::string colorStr = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(favoriteColor);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Favorite color: &quot;</span> &lt;&lt; colorStr &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Green&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Conceptual logging:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;Current status: &quot; &lt;&lt; OperationStatus::Pending; // Would output &quot;Pending&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert string to enum (e.g., for deserialization from a config file)</span></div>
<div class="line">    std::string inputColorStr = <span class="stringliteral">&quot;Blue&quot;</span>;</div>
<div class="line">    MyColor parsedColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;MyColor&gt;</a>(inputColorStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed color from string &#39;&quot;</span> &lt;&lt; inputColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(parsedColor) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Blue&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example of parsing an invalid string for MyColor</span></div>
<div class="line">    std::string invalidColorStr = <span class="stringliteral">&quot;Purple&quot;</span>;</div>
<div class="line">    MyColor defaultOrFirstColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;MyColor&gt;</a>(invalidColorStr);</div>
<div class="line">    <span class="comment">// Behavior for invalid string depends on DEFINE_ENUM implementation.</span></div>
<div class="line">    <span class="comment">// It might default to the first enumerator (Red) or a specified &#39;Unknown&#39; value if the macro supports that.</span></div>
<div class="line">    <span class="comment">// Our conceptual placeholder defaults to &#39;Unknown&#39; if available, or first if not.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid color string &#39;&quot;</span> &lt;&lt; invalidColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(defaultOrFirstColor) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example with OperationStatus which has an &#39;Unknown&#39; default</span></div>
<div class="line">    std::string invalidStatusStr = <span class="stringliteral">&quot;NonExistentStatus&quot;</span>;</div>
<div class="line">    OperationStatus status = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;OperationStatus&gt;</a>(invalidStatusStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid status string &#39;&quot;</span> &lt;&lt; invalidStatusStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(status) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Unknown&quot;</span></div>
<div class="line"> </div>
<div class="line">    OperationStatus goodStatus = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;OperationStatus&gt;</a>(<span class="stringliteral">&quot;Success&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed valid status string &#39;Success&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(goodStatus) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Success&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aenum_8h_html_acf1825d3b8e6ea6b7e5f4dbc5bacae6d"><div class="ttname"><a href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a></div><div class="ttdeci">#define DEFINE_ENUM(TEnum,...)</div><div class="ttdoc">Defines a class that encapsulates a scoped enum, providing type safety and utility functions....</div><div class="ttdef"><b>Definition</b> enum.h:57</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_define_enum_impact"></a>
Impact of <span class="tt">DEFINE_ENUM</span></h2>
<p><b>Simplified Logging:</b> Because <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span> typically handles the creation of <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a>&lt;std::string, YourEnumType&gt;</span>, enum values can be directly used in logging statements, and they will be automatically converted to their human-readable string names: </p><div class="fragment"><div class="line"><span class="comment">// MyColor color = MyColor::Blue;</span></div>
<div class="line"><span class="comment">// LOGI &lt;&lt; &quot;Current color selection: &quot; &lt;&lt; color; // Would log &quot;Current color selection: Blue&quot;</span></div>
</div><!-- fragment --><p><b>Seamless Serialization:</b> Enums defined with <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span> integrate smoothly with Iridium's serialization macros. If you use such an enum as a type for an attribute: </p><div class="fragment"><div class="line"><span class="comment">// // Assuming MyColor is defined using DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyWidgetConfig)</span></div>
<div class="line"><span class="comment">//   DEFINE_ATTRIBUTE(MyColor, WidgetColor)</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyWidgetConfig config;</span></div>
<div class="line"><span class="comment">// config.WidgetColor = MyColor::Red;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// // Serializing &#39;config&#39; would store &quot;Red&quot; for the &#39;widget-color&#39; attribute.</span></div>
<div class="line"><span class="comment">// // Deserializing a structure where &#39;widget-color&#39; is &quot;Green&quot; would set config.WidgetColor to MyColor::Green.</span></div>
</div><!-- fragment --><p> The serialization system uses the auto-generated <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">convert</a></span> specializations to handle the transformation between the enum values and their string representations in the serialized data (e.g., JSON, XML).</p>
<p>Using <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span> thus reduces boilerplate, ensures consistency, and makes working with enumerations in Iridium much more convenient. Always refer to the specific <span class="tt"><a class="el" href="enum_8h.html" title="Provides macros for defining and implementing type-safe enums with reflection capabilities.">iridium/enum.h</a></span> or equivalent header in your version of the library for the exact capabilities and syntax of the <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines a class that encapsulates a scoped enum, providing type safety and utility functions....">DEFINE_ENUM</a></span> macro.</p>
<h1 class="doxsection"><a class="anchor" id="sec_threading"></a>
Multithreading Primitives</h1>
<p>The Iridium library provides several primitives to aid in multithreaded application development. These include tools for direct thread management, data synchronization, and task processing with worker threads and pools.</p>
<p>Note: Some concrete classes like <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>, <span class="tt"><a class="el" href="class_c_worker.html" title="A worker that processes items from an input queue and pushes them to an output queue.">CWorker</a></span>, and <span class="tt"><a class="el" href="class_c_worker_pool.html" title="A worker pool that processes items from an input queue and pushes them to an output queue.">CWorkerPool</a></span> reside in the <span class="tt"><a class="el" href="namespaceiridium_1_1threading_1_1implementation.html">iridium::threading::implementation</a></span> namespace. While they might have <span class="tt">::create()</span> factory methods suggesting usability, this namespacing typically indicates they are foundational blocks, possibly intended to be wrapped by higher-level abstractions in some cases. However, their direct usage is documented here as per common need.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_cthread"></a>
Using CThread for Direct Thread Management</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_thread.html">iridium::threading::implementation::CThread</a></span> allows you to create and manage a dedicated thread. It executes a task defined by an object implementing the <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html" title="An interface for objects that can be run in a separate thread.">iridium::threading::IRunnable</a></span> interface.</p>
<p><b><span class="tt">IRunnable</span> Interface:</b> To define the work for a <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>, you create a class that inherits from <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html" title="An interface for objects that can be run in a separate thread.">iridium::threading::IRunnable</a></span>. This interface requires you to implement:</p><ul>
<li><span class="tt">void initialize()</span>: Called once after the thread starts, for setup.</li>
<li><span class="tt">void finalize()</span>: Called once before the thread joins, for cleanup.</li>
<li><span class="tt">void run(std::atomic&lt;bool&gt;&amp; is_running)</span>: This is the main function executed by the thread. It should contain your task's logic and periodically check the <span class="tt">is_running</span> flag. When <span class="tt">is_running</span> becomes <span class="tt">false</span>, the <span class="tt">run</span> method should return to allow the thread to exit gracefully.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cthread.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2thread_8h.html">iridium/threading/implementation/thread.h</a>&quot;</span> <span class="comment">// For CThread</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="runnable_8h.html">iridium/threading/runnable.h</a>&quot;</span>       <span class="comment">// For IRunnable</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span>         <span class="comment">// For iridium::threading::sleep, IThread (for getNameStatic)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span> <span class="comment">// For std::chrono::milliseconds</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// For std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Implement IRunnable</span></div>
<div class="line"><span class="keyword">class </span>MyPeriodicTask : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Initializing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">run</a>(std::atomic&lt;bool&gt;&amp; is_running)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (is_running) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;): Working, count: &quot;</span> &lt;&lt; ++counter &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Simulate work by sleeping</span></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 5 &amp;&amp; is_running; ++i) { <span class="comment">// Check is_running more frequently during &quot;work&quot;</span></div>
<div class="line">                 <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(200);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Exiting run loop.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Finalizing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cthread() {</div>
<div class="line">    <span class="comment">// 2. Create an instance of your IRunnable</span></div>
<div class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;MyPeriodicTask&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create and manage the CThread</span></div>
<div class="line">    <span class="comment">// CThread::create takes (name, IRunnable::TSharedPtr)</span></div>
<div class="line">    <span class="keyword">auto</span> thread_obj = iridium::threading::implementation::CThread::create(<span class="stringliteral">&quot;MyWorker1&quot;</span>, task);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Initializing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;initialize(); <span class="comment">// Starts the thread and waits for it to be running</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Sleeping for 3 seconds while thread runs...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(3000);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Finalizing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;finalize(); <span class="comment">// Signals thread to stop and waits for it to join</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Thread finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Thread operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a5b8c613423cd12e98327a9279d8b9d64"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">iridium::pattern::IInitializable::initialize</a></div><div class="ttdeci">virtual void initialize()=0</div><div class="ttdoc">Performs the initialization logic for the object.</div></div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a93a1fb6f89e1e1f125455a8682e9ae59"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">iridium::pattern::IInitializable::finalize</a></div><div class="ttdeci">virtual void finalize()=0</div><div class="ttdoc">Performs the finalization logic for the object.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></div><div class="ttdoc">An interface for objects that can be run in a separate thread.</div><div class="ttdef"><b>Definition</b> runnable.h:20</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html_a8849596ba04c14d98b200c24491dcd97"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">iridium::threading::IRunnable::run</a></div><div class="ttdeci">virtual void run(std::atomic&lt; bool &gt; &amp;is_running)=0</div><div class="ttdoc">The main function to be executed in a separate thread.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_aebf89ec3258e418ee6141cb9a5adb285"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a></div><div class="ttdeci">static std::string const &amp; getNameStatic()</div><div class="ttdoc">Gets the name of the current thread.</div><div class="ttdef"><b>Definition</b> thread.cpp:50</div></div>
<div class="ttc" id="aimplementation_2thread_8h_html"><div class="ttname"><a href="implementation_2thread_8h.html">thread.h</a></div><div class="ttdoc">Defines the CThread class, a concrete implementation of the IThread interface. This class manages a s...</div></div>
<div class="ttc" id="anamespaceiridium_1_1threading_html_a77efc83dba79715684b3890184b31992"><div class="ttname"><a href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a></div><div class="ttdeci">void sleep(int const &amp;milliseconds)</div><div class="ttdoc">Pauses the execution of the current thread for a specified duration.</div><div class="ttdef"><b>Definition</b> thread.cpp:40</div></div>
<div class="ttc" id="arunnable_8h_html"><div class="ttname"><a href="runnable_8h.html">runnable.h</a></div></div>
<div class="ttc" id="athread_8h_html"><div class="ttname"><a href="thread_8h.html">thread.h</a></div><div class="ttdoc">Defines the IThread interface and related threading utility functions. This includes the core interfa...</div></div>
</div><!-- fragment --><p> In this example, <span class="tt">MyPeriodicTask::run</span> will execute in a new thread managed by <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>. <span class="tt"><a class="el" href="class_c_thread.html#a39b985df9f70f9502198035353b1eedc" title="Performs the initialization logic for the object.">CThread::initialize()</a></span> starts it, and <span class="tt"><a class="el" href="class_c_thread.html#a66a1d7c2cba19611a23b645843b61474" title="Performs the finalization logic for the object.">CThread::finalize()</a></span> signals <span class="tt">is_running</span> to <span class="tt">false</span> and joins the thread.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_synchronized"></a>
Using Synchronized for Data Protection</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">iridium::threading::Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</span> is a template class designed to protect shared data from concurrent access. It typically serves as a base class for classes that contain data needing protection. It uses a mutex (e.g., <span class="tt">std::mutex</span>) and a condition variable.</p>
<p><b>Key Mechanism: <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></span></b> The <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></span> macro is the primary way to interact with <span class="tt"><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></span>. When placed inside a method of a class that inherits from <span class="tt"><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></span>, it creates a scoped lock (an instance of <span class="tt"><a class="el" href="class_synchronized_1_1_locker.html" title="A scoped locker class that acquires the Synchronized object&#39;s mutex on construction and releases it o...">Synchronized::Locker</a></span>). The mutex is acquired when <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></span> is encountered and automatically released when the scope is exited (due to RAII).</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span>    <span class="comment">// For std::mutex</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span>   <span class="comment">// For std::chrono</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/threading/implementation/thread.h&quot; // For more complex demo with actual threads</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Class whose methods will be synchronized</span></div>
<div class="line"><span class="keyword">class </span>SafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; items_;</div>
<div class="line">    <span class="keywordtype">int</span> access_count_ = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addItem(<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Lock acquired for this scope</span></div>
<div class="line">        items_.push_back(item);</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItem: Added &#39;&quot; &lt;&lt; item &lt;&lt; &quot;&#39;. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// Mutex is automatically released here by _____locked_scope_____ destructor</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> addItems(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; items_to_add) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item_to_add : items_to_add) { <span class="comment">// Fixed variable name</span></div>
<div class="line">            items_.push_back(item_to_add);</div>
<div class="line">        }</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItems: Added multiple items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; getItems() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// Return by value ensures the copy is made while the lock is held.</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;getItems: Returning copy of items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">return</span> items_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getAccessCount() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">return</span> access_count_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> waitUntilItemCountReaches(<span class="keywordtype">size_t</span> target_count, std::chrono::milliseconds timeout) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Waiting for item count &quot; &lt;&lt; target_count &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">while</span> (items_.size() &lt; target_count) {</div>
<div class="line">            <span class="keywordflow">if</span> (!<a class="code hl_define" href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816">LOCK_SCOPE_TRY_WAIT</a>(timeout)) {</div>
<div class="line">                <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Wait timed out or was interrupted.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Woke up, current count &quot; &lt;&lt; items_.size() &lt;&lt; std::endl;</span></div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// if (items_.size() &gt;= target_count) {</span></div>
<div class="line">        <span class="comment">//     std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Target count reached.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> notifyDataAdded() {</div>
<div class="line">        <span class="comment">// The Synchronized::Locker&#39;s destructor calls notify_one automatically.</span></div>
<div class="line">        <span class="comment">// To explicitly notify (e.g. all), you would need access to the condition variable itself.</span></div>
<div class="line">        <span class="comment">// For this pattern, you&#39;d typically add data (which acquires and releases a lock),</span></div>
<div class="line">        <span class="comment">// and the lock release notifies one waiter.</span></div>
<div class="line">        <span class="comment">// If you need notify_all, it&#39;s not directly exposed via LOCK_SCOPE alone for this simple pattern.</span></div>
<div class="line">        <span class="comment">// The Synchronized class has m_cv.notify_all() in its interrupt() method.</span></div>
<div class="line">        <span class="comment">// This example relies on the implicit notify_one on Locker destruction.</span></div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Acquire lock to ensure data consistency before potential notification</span></div>
<div class="line">        <span class="comment">// (no data change here, but typically you would modify data before notify)</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;notifyDataAdded: Change occurred. Locker destruction will notify one waiter.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized() {</div>
<div class="line">    SafeDataContainer container;</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Apple&quot;</span>);</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; currentItems = container.getItems();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : currentItems) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Access count: &quot;</span> &lt;&lt; container.getAccessCount() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Conceptual: A thread might wait for a condition</span></div>
<div class="line">    <span class="comment">// std::thread waiter([&amp;](){</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: waiting for 3 items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.waitUntilItemCountReaches(3, std::chrono::seconds(2));</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: finished waiting. Items: &quot; &lt;&lt; container.getItems().size() &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// std::thread adder([&amp;](){</span></div>
<div class="line">    <span class="comment">//    iridium::threading::sleep(500);</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Adder thread: adding &#39;Cherry&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.addItem(&quot;Cherry&quot;); // This will notify one waiter via Locker destructor</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// adder.join();</span></div>
<div class="line">    <span class="comment">// waiter.join();</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_synchronized_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a></div><div class="ttdoc">A template class providing synchronization primitives (mutex and condition variable) to protect share...</div><div class="ttdef"><b>Definition</b> synchronized.h:52</div></div>
<div class="ttc" id="asynchronized_8h_html"><div class="ttname"><a href="synchronized_8h.html">synchronized.h</a></div><div class="ttdoc">Defines the Synchronized class template for creating synchronized blocks of code and related helper m...</div></div>
<div class="ttc" id="asynchronized_8h_html_a0286bc5b797a5f1a2ba5c8a832572816"><div class="ttname"><a href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816">LOCK_SCOPE_TRY_WAIT</a></div><div class="ttdeci">#define LOCK_SCOPE_TRY_WAIT(timeout)</div><div class="ttdoc">Calls the wait(timeout) method on a Synchronized::Locker instance named _____locked_scope_____....</div><div class="ttdef"><b>Definition</b> synchronized.h:250</div></div>
<div class="ttc" id="asynchronized_8h_html_aa07286a6c9966cc562c16a85887533fc"><div class="ttname"><a href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a></div><div class="ttdeci">#define LOCK_SCOPE()</div><div class="ttdoc">Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....</div><div class="ttdef"><b>Definition</b> synchronized.h:234</div></div>
</div><!-- fragment --><p> The <span class="tt"><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></span> class makes methods of <span class="tt">SafeDataContainer</span> thread-safe. The <span class="tt">Locker</span>'s destructor also calls <span class="tt">notify_one()</span> on an internal condition variable, which can be used with <span class="tt">Locker::wait()</span> methods.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_synchronized_wait"></a>
Waiting on Conditions</h3>
<p>The <span class="tt"><a class="el" href="class_synchronized_1_1_locker.html" title="A scoped locker class that acquires the Synchronized object&#39;s mutex on construction and releases it o...">Synchronized::Locker</a></span> object, created by <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></span>, provides methods to wait on a condition variable, allowing threads to pause execution until notified or a timeout occurs. This is essential for building producer-consumer patterns or waiting for a specific state change.</p>
<ul>
<li><span class="tt">_____locked_scope_____.wait()</span>: Waits indefinitely until another thread issues a notification. It returns <span class="tt">true</span> if woken by a notification and <span class="tt">false</span> if the wait was interrupted by <span class="tt">interrupt()</span>.</li>
<li><span class="tt">_____locked_scope_____.wait(timeout)</span> or <span class="tt"><a class="el" href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816" title="Calls the wait(timeout) method on a Synchronized::Locker instance named _____locked_scope_____....">LOCK_SCOPE_TRY_WAIT(timeout)</a></span>: Waits for a specific duration. It returns <span class="tt">true</span> only if woken by a notification before the timeout expires. It returns <span class="tt">false</span> if the timeout is reached or if the wait is interrupted.</li>
</ul>
<p>It is crucial to use these wait methods inside a loop that checks the condition you are waiting for. This is because a thread can wake up spuriously (without a notification) or after a notification for a different condition.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_synchronized_interrupt"></a>
Interrupting Waits</h3>
<p>The <span class="tt"><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></span> class provides an <span class="tt">interrupt()</span> method to unblock all threads currently waiting on its condition variable. When <span class="tt">interrupt()</span> is called:</p><ol type="1">
<li>An internal <span class="tt">m_is_waitable</span> flag is set to <span class="tt">false</span>.</li>
<li><span class="tt">notify_all()</span> is called on the condition variable.</li>
<li>All waiting threads wake up. Their <span class="tt">wait()</span> calls will immediately return <span class="tt">false</span>.</li>
<li>Any subsequent calls to <span class="tt">wait()</span> will also return <span class="tt">false</span> immediately without actually waiting, until the <span class="tt"><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></span> object is destroyed.</li>
</ol>
<p>This mechanism is a clean way to signal threads to shut down gracefully.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_synchronized_wait_example"></a>
Example of Wait, Notify, and Interrupt</h3>
<p>This example demonstrates a simple producer-consumer scenario where a consumer thread waits for data to be added to a queue by a producer thread. It also shows how to interrupt the waiting thread.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/threading/synchronized.hh&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataQueue : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::queue&lt;std::string&gt; m_queue;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Producer method</span></div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Lock is acquired</span></div>
<div class="line">        m_queue.push(item);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Producer: Pushed &#39;&quot;</span> &lt;&lt; item &lt;&lt; <span class="stringliteral">&quot;&#39;. Notifying one waiter.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// Lock is released at end of scope, and notify_one() is called automatically</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Consumer method</span></div>
<div class="line">    <span class="keywordtype">void</span> consume() {</div>
<div class="line">        <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a>(<span class="stringliteral">&quot;Consumer&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Waiting for data...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Lock is acquired for the whole loop</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> (m_queue.empty()) {</div>
<div class="line">            <span class="comment">// Atomically releases the lock and waits.</span></div>
<div class="line">            <span class="comment">// Re-acquires the lock upon waking up.</span></div>
<div class="line">            <span class="keywordflow">if</span> (!_____locked_scope_____.wait()) {</div>
<div class="line">                <span class="comment">// wait() returned false, meaning it was interrupted</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Wait was interrupted. Exiting.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// Spurious wakeup check: if queue is still empty, loop again to wait.</span></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Woke up. Checking queue...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// At this point, the lock is held and m_queue is not empty.</span></div>
<div class="line">        std::string item = m_queue.front();</div>
<div class="line">        m_queue.pop();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Popped &#39;&quot;</span> &lt;&lt; item &lt;&lt; <span class="stringliteral">&quot;&#39;.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Method to demonstrate interruption</span></div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Interrupting all waiters.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_function" href="classiridium_1_1threading_1_1_synchronized.html#a79202da1c3b89c390b86848f1b17a50d">interrupt</a>(); <span class="comment">// This will cause wait() to return false</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_wait_interrupt() {</div>
<div class="line">    DataQueue queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start a consumer thread that will wait for data</span></div>
<div class="line">    std::thread consumer_thread(&amp;DataQueue::consume, &amp;queue);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Give the consumer a moment to start waiting</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(100);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start a producer thread</span></div>
<div class="line">    std::thread producer_thread([&amp;](){</div>
<div class="line">        <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a>(<span class="stringliteral">&quot;Producer&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(500); <span class="comment">// Simulate some work</span></div>
<div class="line">        queue.push(<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    producer_thread.join();</div>
<div class="line">    consumer_thread.join();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\n--- Interrupt Demo ---&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start another consumer that will be interrupted</span></div>
<div class="line">    std::thread interrupted_consumer(&amp;DataQueue::consume, &amp;queue);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(100); <span class="comment">// Let it start waiting</span></div>
<div class="line">    queue.stop(); <span class="comment">// Interrupt the wait</span></div>
<div class="line"> </div>
<div class="line">    interrupted_consumer.join();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Demo finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_a065f967a26a86efde891ec209094560d"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a></div><div class="ttdeci">static void setNameStatic(std::string const &amp;name)</div><div class="ttdoc">Sets the name of the current thread.</div><div class="ttdef"><b>Definition</b> thread.cpp:57</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_synchronized_html_a79202da1c3b89c390b86848f1b17a50d"><div class="ttname"><a href="classiridium_1_1threading_1_1_synchronized.html#a79202da1c3b89c390b86848f1b17a50d">iridium::threading::Synchronized::interrupt</a></div><div class="ttdeci">void interrupt()</div><div class="ttdoc">Interrupts any threads waiting on this Synchronized object&#39;s condition variable. Sets an internal fla...</div><div class="ttdef"><b>Definition</b> synchronized.h:156</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_cworker"></a>
Using CWorker for Task Processing</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html" title="A worker that processes items from an input queue and pushes them to an output queue.">iridium::threading::implementation::CWorker</a>&lt;TInputItem, TOutputItem&gt;</span> provides a single worker thread that processes items from an input queue and can place results in an output queue.</p>
<p><b><span class="tt"><a class="el" href="class_i_worker_1_1_i_handler.html" title="An interface for a handler that processes items.">IWorker::IHandler</a></span> Interface:</b> You define a handler class inheriting from <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_worker.html" title="An interface for a worker that processes items, taking input and producing output.">iridium::threading::IWorker</a>&lt;TInputItem, TOutputItem&gt;::IHandler</span>. Its core method is:</p><ul>
<li><span class="tt">TOutputItems handle(const TInputItems&amp; items)</span>: Receives a list of items from the input queue and should return a list of output items.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworker.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2worker_8h.html">iridium/threading/implementation/worker.h</a>&quot;</span> <span class="comment">// For CWorker</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// For IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// For std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// For toupper</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// For std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Define the Handler</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandler : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Initializing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Finalizing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line"> </div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Handler: Received &quot; &lt;&lt; items.size() &lt;&lt; &quot; items to process.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upperItem = item;</div>
<div class="line">            std::transform(upperItem.begin(), upperItem.end(), upperItem.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); }); <span class="comment">// Ensure char cast</span></div>
<div class="line">            results.push_back(upperItem + <span class="stringliteral">&quot;_processed_by_worker&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworker() {</div>
<div class="line">    <span class="keyword">auto</span> handler = std::make_shared&lt;ToUpperStringHandler&gt;();</div>
<div class="line">    <span class="keyword">auto</span> worker = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyStringToUpperWorker&quot;</span>, handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &#39;alpha&#39; and &#39;beta&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;push(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">        worker-&gt;push(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;gamma&quot;</span>});</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker&lt;std::string, std::string&gt;::TOutputItems</a> processedBatch;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The CWorkerRunnable processes one item at a time from the input queue,</span></div>
<div class="line">        <span class="comment">// calls handler (which receives a list of 1 item),</span></div>
<div class="line">        <span class="comment">// and handler returns a list of output items.</span></div>
<div class="line">        <span class="comment">// So, each pop() call will retrieve the results from one handle() call.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;alpha&quot;</span></div>
<div class="line">        processedBatch = worker-&gt;<a class="code hl_function" href="classiridium_1_1threading_1_1_i_async_queue_popper.html#aa693ab6107a6faca36d0db9a5a30a044">pop</a>(<span class="keyword">true</span>); <span class="comment">// true means wait</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processedBatch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;beta&quot;</span></div>
<div class="line">        processedBatch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processedBatch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;gamma&quot;</span></div>
<div class="line">        processedBatch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processedBatch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: CWorker operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_async_queue_popper_html_aa693ab6107a6faca36d0db9a5a30a044"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_async_queue_popper.html#aa693ab6107a6faca36d0db9a5a30a044">iridium::threading::IAsyncQueuePopper::pop</a></div><div class="ttdeci">virtual TItems pop(bool const &amp;is_wait_required=true)=0</div><div class="ttdoc">Pops items from the queue.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a></div><div class="ttdoc">An interface for a worker that processes items, taking input and producing output.</div><div class="ttdef"><b>Definition</b> worker.h:74</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker</a></div><div class="ttdoc">A worker that processes items from an input queue and pushes them to an output queue.</div><div class="ttdef"><b>Definition</b> worker.h:93</div></div>
<div class="ttc" id="aimplementation_2worker_8h_html"><div class="ttname"><a href="implementation_2worker_8h.html">worker.h</a></div></div>
<div class="ttc" id="aworker_8h_html"><div class="ttname"><a href="worker_8h.html">worker.h</a></div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_cworkerpool"></a>
Using CWorkerPool for Parallel Task Processing</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html" title="A worker pool that processes items from an input queue and pushes them to an output queue.">iridium::threading::implementation::CWorkerPool</a>&lt;TInputItem, TOutputItem&gt;</span> manages a pool of multiple worker threads for parallel processing of items from a shared input queue to a shared output queue.</p>
<p><b>Key Aspects:</b></p><ul>
<li>Constructor takes a list of <span class="tt">IHandler</span> shared pointers (<span class="tt">THandlers</span>).</li>
<li>Items pushed are distributed among worker threads.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworkerpool.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker__pool_8h.html">iridium/threading/implementation/worker_pool.h</a>&quot;</span> <span class="comment">// For CWorkerPool</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// For IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// For std::make_shared</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// For std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// For toupper</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO </span><span class="comment">// Guard if included multiple times</span></div>
<div class="line"><span class="preprocessor">#define TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandlerForPool : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string handlerId_;</div>
<div class="line">    ToUpperStringHandlerForPool(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>) : handlerId_(id) {}</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handlerId_ &lt;&lt; &quot;: Init&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handlerId_ &lt;&lt; &quot;: Final&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; handlerId_ &lt;&lt; &quot;: Handling &quot; &lt;&lt; items.size() &lt;&lt; &quot; items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upperItem = item;</div>
<div class="line">            std::transform(upperItem.begin(), upperItem.end(), upperItem.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); });</div>
<div class="line">            results.push_back(upperItem + <span class="stringliteral">&quot;_processed_by_pool_&quot;</span> + handlerId_);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworkerpool() {</div>
<div class="line">    <span class="keywordtype">int</span> numPoolThreads = 2;</div>
<div class="line">    std::list&lt;iridium::threading::IWorker&lt;std::string, std::string&gt;::IHandler::TSharedPtr&gt; handlersList;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numPoolThreads; ++i) {</div>
<div class="line">        handlersList.push_back(std::make_shared&lt;ToUpperStringHandlerForPool&gt;(<span class="stringliteral">&quot;H&quot;</span> + std::to_string(i)));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> pool = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyDemoPool&quot;</span>, handlersList);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::string&gt; allTasks = {<span class="stringliteral">&quot;task1&quot;</span>, <span class="stringliteral">&quot;task2&quot;</span>, <span class="stringliteral">&quot;task3&quot;</span>, <span class="stringliteral">&quot;task4&quot;</span>, <span class="stringliteral">&quot;task5&quot;</span>};</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &quot; &lt;&lt; allTasks.size() &lt;&lt; &quot; tasks to the pool.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;push(allTasks); <span class="comment">// Push a batch. These will be added to the shared input queue.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Collect results. Each worker thread processes one item from the input queue at a time,</span></div>
<div class="line">        <span class="comment">// its handler produces a list of output items, which are added to the pool&#39;s output queue.</span></div>
<div class="line">        <span class="comment">// So, we expect to pop &#39;allTasks.size()&#39; lists of results.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; allTasks.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> resultsBatch = pool-&gt;pop(<span class="keyword">true</span>); <span class="comment">// Wait for a batch of results from one handler call</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; res : resultsBatch) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Pool result: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker pool finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Worker Pool operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_pool_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a></div><div class="ttdoc">A worker pool that processes items from an input queue and pushes them to an output queue.</div><div class="ttdef"><b>Definition</b> worker_pool.h:119</div></div>
<div class="ttc" id="aworker__pool_8h_html"><div class="ttname"><a href="worker__pool_8h.html">worker_pool.h</a></div></div>
</div><!-- fragment --><p> The <span class="tt"><a class="el" href="class_c_worker_pool.html" title="A worker pool that processes items from an input queue and pushes them to an output queue.">CWorkerPool</a></span> is effective for parallelizing independent tasks. The order of results from <span class="tt">pop</span> may not strictly match the <span class="tt">push</span> order.</p>
<p>These primitives provide foundational tools for building concurrent and parallel applications with Iridium.</p>
<h1 class="doxsection"><a class="anchor" id="sec_testing"></a>
Testing with Iridium</h1>
<p>The Iridium library provides a built-in framework for writing and running unit tests, as well as for creating mock objects to isolate the code under test. This framework helps ensure the quality and reliability of code developed using Iridium.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_core_concepts"></a>
Core Concepts</h2>
<p>The foundation of the Iridium testing system consists of two key interfaces/classes:</p>
<ul>
<li><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Interface for a runnable test case. Concrete test classes should implement this interface to define a...">iridium::testing::ITest</a></span> (defined in <span class="tt"><a class="el" href="test_8h.html">iridium/testing/test.h</a></span>): This is the base interface for any runnable test case. Each class representing a test must implement the <span class="tt">virtual void run() = 0;</span> method. This method contains the logic of the test itself, including calls to the code under test and assertion checks.</li>
<li><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="A base class for unit tests, providing assertion methods.">iridium::testing::UnitTest</a></span> (defined in <span class="tt"><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></span>): This class serves as the base class for your tests (usually implicitly via the <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST</a></span> macro). It provides a set of methods for performing various assertions, such as checking equality, comparisons, truthiness of conditions, or the throwing of expected exceptions. If an assertion fails, these methods generate a special exception that signals the test failure.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_writing_tests"></a>
Writing Tests</h2>
<p>The primary tool for creating test cases in Iridium is the <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST</a></span> macro.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_test_macro"></a>
The TEST Macro</h3>
<p>The <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST(TestCaseName)</a></span> macro (defined in <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>) is used to define a test case. <span class="tt">TestCaseName</span> must be a unique identifier for your test. This macro automatically creates a class that inherits from <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Interface for a runnable test case. Concrete test classes should implement this interface to define a...">iridium::testing::ITest</a></span> and <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="A base class for unit tests, providing assertion methods.">iridium::testing::UnitTest</a></span>, and registers it with the testing system. You only need to provide the body for the <span class="tt">run()</span> method, which will contain the test logic.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For TEST and ASSERT macro</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span>                   <span class="comment">// For std::string in example</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span>                <span class="comment">// For std::runtime_error in example</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert (if custom types are needed in ASSERT)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example custom type to demonstrate output in ASSERT</span></div>
<div class="line"><span class="keyword">struct </span>MyCustomType {</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    std::string value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For comparison in tests</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyCustomType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> == other.id &amp;&amp; value == other.value;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specialization of convert for MyCustomType, so ASSERT can print it</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">std::string <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert</a>(MyCustomType <span class="keyword">const</span> &amp;obj) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyCustomType(id=&quot;</span> + <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(obj.id) + <span class="stringliteral">&quot;, value=\&quot;&quot;</span> + obj.value + <span class="stringliteral">&quot;\&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example class to be tested (replace with your own)</span></div>
<div class="line"><span class="keyword">class </span>MyClassToTest {</div>
<div class="line">    std::string param;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassToTest(<span class="keyword">const</span> std::string&amp; p = <span class="stringliteral">&quot;&quot;</span>) : param(p) {}</div>
<div class="line">    std::string getParameter()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> param; }</div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
<div class="line">    MyCustomType getCustomType(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; val) { <span class="keywordflow">return</span> {id, val}; }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatThrows() { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Expected exception&quot;</span>); }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatDoesNotThrow() { <span class="comment">/* No-op */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassConstruction) {</div>
<div class="line">    MyClassToTest obj(<span class="stringliteral">&quot;test_param&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getParameter(), equal, <span class="stringliteral">&quot;test_param&quot;</span>); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassAddsNumbers) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(2, 3), equal, 5);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), greaterEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), lessEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(5, 5), greater, 9);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), less, 3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyCustomTypeAssertion) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    MyCustomType expected = {1, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getCustomType(1, <span class="stringliteral">&quot;hello&quot;</span>), equal, expected);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(BooleanAssertions) {</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">true</span>); <span class="comment">// Check for truth</span></div>
<div class="line">    <span class="keywordtype">bool</span> myFlag = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(!myFlag); <span class="comment">// Check for falsehood via negation</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassThrowsException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.doSomethingThatThrows(), std::runtime_error);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassDoesNotThrowException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <span class="keywordtype">bool</span> didNotThrow = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        obj.doSomethingThatDoesNotThrow();</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        didNotThrow = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(didNotThrow);</div>
<div class="line">}</div>
<div class="ttc" id="atester_8h_html"><div class="ttname"><a href="tester_8h.html">tester.h</a></div></div>
<div class="ttc" id="atester_8h_html_a45feb1f37ce559e49baf8655d769ef85"><div class="ttname"><a href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a></div><div class="ttdeci">#define TEST(name)</div><div class="ttdoc">Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...</div><div class="ttdef"><b>Definition</b> tester.h:150</div></div>
<div class="ttc" id="atester_8h_html_a821326052e3e2bf1fb2d678e9e9a6004"><div class="ttname"><a href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a></div><div class="ttdeci">#define ASSERT(...)</div><div class="ttdoc">Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...</div><div class="ttdef"><b>Definition</b> tester.h:215</div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="subsubsec_testing_assertions"></a>
The ASSERT Macro</h3>
<p>The <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="A base class for unit tests, providing assertion methods.">iridium::testing::UnitTest</a></span> class (from which tests created by the <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST</a></span> macro implicitly inherit) provides various methods for checking conditions. The primary way to use them in tests is the <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(...)</a></span> macro (defined in <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>). If an assertion fails, an exception is thrown, and the test is marked as failed.</p>
<p>The <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a></span> macro is variadic (accepts a variable number of arguments) and is used as follows:</p>
<ol type="1">
<li><b>Checking a boolean condition: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(condition)</a></span></b><ul>
<li>Used to check for truth (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(true_condition)</a>;</span>) or falsehood (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a>(!false_condition);</span>).</li>
<li>Technically, this is a call to <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Assertion macro to check if a boolean condition is true. If is_true evaluates to false,...">ASSERT_1</a></span>, which passes <span class="tt">condition</span> to the <span class="tt">UnitTest::assert_()</span> method.</li>
<li>Example: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a>(x &gt; 5);</span></li>
</ul>
</li>
<li><b>Checking for comparison: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, comparison_symbol, value2)</a></span></b><ul>
<li>Used for various types of comparisons. <span class="tt">comparison_symbol</span> is the name of a comparison method from the <span class="tt">UnitTest</span> class. <span class="tt">value1</span> represents the expected value, and <span class="tt">value2</span> the actual (received) value.</li>
<li>When performing a comparison (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, comparison_symbol, value2)</a></span>), the expected value (<span class="tt">value1</span>) is converted to the type of the actual value (<span class="tt">value2</span>). For instance, in the template methods of <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="A base class for unit tests, providing assertion methods.">iridium::testing::UnitTest</a></span> (see <span class="tt"><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></span>), a construct like <span class="tt">TRight left_(left);</span> or <span class="tt">static_cast&lt;TRight&gt;(left)</span> is used, where <span class="tt">left</span> is <span class="tt">value1</span> (expected), and <span class="tt">TRight</span> is the type of <span class="tt">value2</span> (actual). Thus, the actual comparison (<span class="tt">left_ == right</span>, <span class="tt">left_ &lt; right</span>, etc.) occurs between values of the same typethe type <span class="tt">TRight</span>. For converting values to strings for display in error messages, <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a></span> is used.</li>
<li>Technically, this is a call to <span class="tt"><a class="el" href="tester_8h.html#add09cced0f90a8f1b3f5af6bb20c423e" title="Assertion macro for binary conditions (e.g., equality, inequality, less than). It evaluates condition...">ASSERT_3</a></span>, which calls <span class="tt">UnitTest::comparison_symbol(value1, value2, "value1 symbol value2", "<a href="file:line">file:line</a>")</span>.</li>
<li>Available <span class="tt">comparison_symbol</span>s:<ul>
<li><span class="tt">equal</span>: Checks that <span class="tt">value1 == value2</span>.</li>
<li><span class="tt">less</span>: Checks that <span class="tt">value1 &lt; value2</span>.</li>
<li><span class="tt">lessEqual</span>: Checks that <span class="tt">value1 &lt;= value2</span>.</li>
<li><span class="tt">greater</span>: Checks that <span class="tt">value1 &gt; value2</span>.</li>
<li><span class="tt">greaterEqual</span>: Checks that <span class="tt">value1 &gt;= value2</span>.</li>
</ul>
</li>
<li>Examples: <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(sum, equal, 10);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(count, less, max_count);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(actual_value, greaterEqual, expected_minimum);</div>
</div><!-- fragment --></li>
<li>Note: Although you can also write <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a>(value1 == value2);</span> (using <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Assertion macro to check if a boolean condition is true. If is_true evaluates to false,...">ASSERT_1</a></span>), using <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, equal, value2)</a>;</span> is preferable for comparisons, as it allows the framework to potentially output the values of <span class="tt">value1</span> and <span class="tt">value2</span> more informatively upon failure.</li>
</ul>
</li>
<li><b>Checking for exception throwing: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(expression, ExpectedExceptionType)</a></span></b><ul>
<li>Technically, this is a call to <span class="tt"><a class="el" href="tester_8h.html#aca9c4ab6285fc7229020bdeb3c10d50d" title="Assertion macro to check if a given function call throws a specific exception. It executes func withi...">ASSERT_2</a></span>, which passes a lambda function with <span class="tt">expression</span> and <span class="tt">ExpectedExceptionType</span> to the <span class="tt">UnitTest::assert_&lt;TFunction, TException&gt;()</span> method.</li>
<li>Checks that executing <span class="tt">expression</span> results in an exception of type <span class="tt">ExpectedExceptionType</span> (or its descendant) being thrown.</li>
<li>Example: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a>(myObject.methodThatThrows(), std::runtime_error);</span></li>
</ul>
</li>
<li><b>Unconditional test failure:</b><ul>
<li>There is no direct <span class="tt">FAIL(message)</span> macro. To unconditionally fail a test, use <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(false)</a>;</span>. You can add a comment to explain the reason. <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">false</span>); <span class="comment">// Test failed because condition X was not met</span></div>
</div><!-- fragment --></li>
</ul>
</li>
</ol>
<p><b>Outputting values on errors and <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a></span>:</b> A very important feature of the <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a></span> macro (especially for comparisons) is how it displays values when an assertion fails. To output <span class="tt">value1</span> and <span class="tt">value2</span> (or the value from <span class="tt">condition</span> for <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Assertion macro to check if a boolean condition is true. If is_true evaluates to false,...">ASSERT_1</a></span>) in a readable format, the testing system uses <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a>&lt;std::string&gt;(your_value)</span>. If you use custom types in <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a></span>, ensure that a specialization of <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">iridium::convertion::convert</a></span> to <span class="tt">std::string</span> exists for them. Otherwise, you might see uninformative output (e.g., just the type name or address). For more details on creating <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Converts a value from a source type to a target type.">convert</a></span> specializations, see section <a class="el" href="#sec_custom_type_conversion">Integrating Custom Types with <span class="tt">iridium::convertion::convert</span></a>.</p>
<p>The <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT</a></span> macro automatically includes the file name and line number in the error information, which helps to quickly locate the point of test failure.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_running_tests"></a>
Running Tests</h2>
<p>After writing tests, they need to be compiled and run. The Iridium framework simplifies this process.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_main"></a>
The IMPLEMENT_TEST_MAIN Macro</h3>
<p>To create an executable file that will run all defined tests, the <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></span> macro (defined in <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>) is used. This macro generates a standard <span class="tt">main()</span> function that initializes and runs the testing framework.</p>
<p>Typically, you create a separate <span class="tt">.cpp</span> file (e.g., <span class="tt">tests_main.cpp</span>) that includes all your test files (or headers, if tests are defined in them) and then calls <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></span>.</p>
<p>Example (<span class="tt">tests_main.cpp</span>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For IMPLEMENT_TEST_MAIN</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include your test files here or files where TEST(...) tests are defined</span></div>
<div class="line"><span class="comment">// For example:</span></div>
<div class="line"><span class="comment">// #include &quot;my_class_tests.cpp&quot; </span></div>
<div class="line"><span class="comment">// #include &quot;another_module_tests.cpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a>()</div>
<div class="ttc" id="atester_8h_html_ae18dbf9ed64402b9c94239f90547eceb"><div class="ttname"><a href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a></div><div class="ttdeci">#define IMPLEMENT_TEST_MAIN()</div><div class="ttdoc">Generates a main() function for a test executable. This main function initializes the Tester singleto...</div><div class="ttdef"><b>Definition</b> tester.h:227</div></div>
</div><!-- fragment --><p> When you compile this file along with your tests and the Iridium library, you will get an executable file that, when run, will execute all detected tests.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_tester"></a>
Role of the Tester Class</h3>
<p>The <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_tester.html" title="Singleton class responsible for registering, managing, and running all tests within the framework....">iridium::testing::Tester</a></span> class (defined in <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>) is the central component of the testing system. It is a singleton that:</p><ul>
<li>Registers all test cases defined using the <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST</a></span> macro.</li>
<li>Manages the execution of tests. The <span class="tt">Tester::run(argc, argv, main_cpp_path)</span> method is called from the generated <span class="tt">main()</span> function.</li>
<li>Allows filtering of tests based on command-line arguments (this functionality may not be fully detailed here, but <span class="tt">Tester</span> provides for it).</li>
<li>Collects test results.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_itestrunner"></a>
The ITestRunner Interface (for advanced scenarios)</h3>
<p>For more flexible control over the test execution process, there is the <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">iridium::testing::ITestRunner</a></span> interface (defined in <span class="tt"><a class="el" href="test__runner_8h.html">iridium/testing/test_runner.h</a></span>). This interface abstracts the way tests are run. The Iridium library provides at least two implementations of it:</p><ul>
<li><span class="tt">iridium::testing::implementation::TestRunnerRaw</span>: Runs tests in the same process.</li>
<li><span class="tt">iridium::testing::implementation::TestRunnerFork</span>: Can run tests in separate processes (forks), which provides better isolation (typically on POSIX systems).</li>
</ul>
<p>Although direct interaction with <span class="tt"><a class="el" href="class_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">ITestRunner</a></span> is usually not required for writing and running tests, knowing about its existence is useful for understanding the framework's architecture and for possible extensions or customization of the testing process. The <span class="tt">Tester</span> class uses an <span class="tt"><a class="el" href="class_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">ITestRunner</a></span> implementation to actually execute the tests.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_cli"></a>
Command-Line Arguments</h3>
<p>The test executable created with <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></span> supports the following command-line arguments to control the testing process. Assume your test application is named <span class="tt">your_test_app</span>.</p>
<ol type="1">
<li><b><span class="tt">help</span></b>: Displays help information on usage. <div class="fragment"><div class="line">./your_test_app help</div>
</div><!-- fragment --> Example output: <div class="fragment"><div class="line">main thread: 281473424756000</div>
<div class="line">2025-06-06 10:30:56.839 I 281473424756000 </div>
<div class="line">usage:</div>
<div class="line">./your_test_app help</div>
<div class="line">./your_test_app list</div>
<div class="line">./your_test_app run [ --mode=raw|serial|parallel ] [ --print-result=json ] [ --timeout=seconds ] [ include_path ] [ exclude_path ] ... [ exclude_path ]</div>
<div class="line">example:</div>
<div class="line">./your_test_app run / </div>
</div><!-- fragment --> (Note: The actual thread number and timestamp in your output will differ.)</li>
<li><b><span class="tt">list</span></b>: Displays a hierarchical list (tree) of all test cases discovered by the framework. Tests are grouped by file path and then by the test name defined in the <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST()</a></span> macro. <div class="fragment"><div class="line">./your_test_app list</div>
</div><!-- fragment --> This is useful for viewing the structure of tests and their full paths, which can be used as <span class="tt">include_path</span> or <span class="tt">exclude_path</span> for the <span class="tt">run</span> command. Example output: <div class="fragment"><div class="line">main thread: 281473794346272</div>
<div class="line">2025-06-06 10:30:22.166 I 281473794346272 </div>
<div class="line"><span class="stringliteral">&#39;root&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;convertion&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;convert.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;enum_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;strings&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;types&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;testing&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;example.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;bool_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;comparing_equal&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;mock&#39;</span></div>
<div class="line"><span class="preprocessor">  # ... (and so on for other modules and tests)</span></div>
</div><!-- fragment --> (Note: The actual thread number, timestamp, and full list of tests in your output will differ.)</li>
<li><p class="startli"><b><span class="tt">run</span></b>: Runs the tests. This is the default command if no other is specified. </p><div class="fragment"><div class="line">./your_test_app run [options] [include_path] [exclude_path_1] [exclude_path_2] ...</div>
</div><!-- fragment --><p> Standard output when running tests (without <span class="tt">--print-result=json</span>) includes logging for each test being run and its result: </p><div class="fragment"><div class="line">main thread: 281473243745568</div>
<div class="line">2025-06-06 10:30:39.744 I 281473243745568 RUN  /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 RUN  /testing/example.cpp/comparing_equal</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/comparing_equal</div>
<div class="line"><span class="preprocessor"># ... (and so on for other tests)</span></div>
<div class="line"><span class="preprocessor"># ... (in case of failure, FAILED will appear instead of OK, along with an error message)</span></div>
<div class="line">2025-06-06 10:30:39.747 I 281473243745568 </div>
<div class="line">passed: 8</div>
<div class="line">failed: 0</div>
<div class="line">total:  51 </div>
</div><!-- fragment --><p> (Note: Actual thread numbers, timestamps, and results in your output will differ.)</p>
<p class="startli">Available options for the <span class="tt">run</span> command:</p><ul>
<li><span class="tt">--mode=MODE</span>: Defines the test execution mode. Possible values for <span class="tt">MODE</span>:<ul>
<li><span class="tt">raw</span> (default): Tests are run in the same process.</li>
<li><span class="tt">serial</span>: Tests are run sequentially, each in a separate process.</li>
<li><span class="tt">parallel</span>: Tests are run in parallel in separate processes.</li>
</ul>
</li>
<li><span class="tt">--print-result=FORMAT</span>: Controls the output format of results.<ul>
<li>If not specified, the standard text format is used (see example above).</li>
<li><span class="tt">json</span>: Results are output in JSON format.</li>
</ul>
</li>
<li><span class="tt">--timeout=SECONDS</span>: Sets the maximum timeout for tests in seconds (default is 60).</li>
</ul>
<p class="startli">Parameters for the <span class="tt">run</span> command:</p><ul>
<li><span class="tt">include_path</span> (optional): If specified, only tests whose path (as in the <span class="tt">list</span> output) starts with <span class="tt">include_path</span> are run. Defaults to <span class="tt">/</span> (all tests).</li>
<li><span class="tt">exclude_path_...</span> (optional): One or more paths to exclude. Tests whose path starts with one of these paths will not be run.</li>
</ul>
</li>
</ol>
<p>Examples of using the <span class="tt">run</span> command:</p>
<ul>
<li>Run all tests: <div class="fragment"><div class="line">./your_test_app run</div>
</div><!-- fragment --> (or just <span class="tt">./your_test_app</span>)</li>
<li>Run all tests in parallel mode with a timeout of 120 seconds: <div class="fragment"><div class="line">./your_test_app run --mode=parallel --timeout=120</div>
</div><!-- fragment --></li>
<li>Run only tests from the <span class="tt">testing</span> module and <span class="tt">example.cpp</span> file: <div class="fragment"><div class="line">./your_test_app run /testing/example.cpp/</div>
</div><!-- fragment --></li>
<li>Run all tests from the <span class="tt">parsing</span> module, but exclude those in <span class="tt">node.cpp</span> within <span class="tt">parsing</span>: <div class="fragment"><div class="line">./your_test_app run /parsing/ /parsing/node.cpp/</div>
</div><!-- fragment --></li>
<li>Run all tests and output the result in JSON format: <div class="fragment"><div class="line">./your_test_app run --print-result=json</div>
</div><!-- fragment --></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_mocking"></a>
Mocking Dependencies</h2>
<p>Mocking is the process of creating substitute objects (mocks or mock objects) to simulate the behavior of real dependencies of the component under test. This allows isolating the code under test and making tests more predictable and stable. The Iridium testing framework provides tools for creating mocks (defined in <span class="tt"><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></span>).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_defining_mocks"></a>
Defining Mock Classes</h3>
<p>To create a mock for an interface or class, the <span class="tt"><a class="el" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee" title="Defines a mock class for a given interface.">DEFINE_MOCK_CLASS(InterfaceName)</a></span> macro is used. This macro creates a new class named <span class="tt">InterfaceNameMock</span> that inherits your <span class="tt">InterfaceName</span> and <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="A base class for mock objects.">iridium::testing::Mock</a>&lt;InterfaceName&gt;</span>.</p>
<p>Inside this mock class, you declare which methods of the interface you want to mock using the <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span> (for non-const methods) and <span class="tt"><a class="el" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530" title="A variadic macro to define a mock method for a const member function.">DEFINE_MOCK_METHOD_CONST</a></span> (for const methods) macros.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume this is the interface we want to mock</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="comment">// Constructor with arguments to demonstrate DEFINE_MOCK_CONSTRUCTOR</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; <span class="comment">// Add a default constructor if it&#39;s also needed</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the mock class for IMyDependency</span></div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// If the base class IMyDependency has a constructor with arguments</span></div>
<div class="line">    <span class="comment">// and you want to call it from the mock:</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Mocking interface methods</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, (<span class="keywordtype">int</span>))                  <span class="comment">// int getValue(int key)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName, ())        <span class="comment">// std::string getName() const</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, (const std::<a class="code hl_class" href="classvector.html">vector</a>&lt;<span class="keywordtype">int</span>&gt; &amp;)) <span class="comment">// void processData(const std::vector&lt;int&gt;&amp; data)</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassvector_html"><div class="ttname"><a href="classvector.html">vector</a></div></div>
<div class="ttc" id="amock_8h_html"><div class="ttname"><a href="mock_8h.html">mock.h</a></div></div>
<div class="ttc" id="amock_8h_html_a1aa823f3557d4e07d5a6cce9bb497aee"><div class="ttname"><a href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a></div><div class="ttdeci">#define DEFINE_MOCK_CLASS(Interface)</div><div class="ttdoc">Defines a mock class for a given interface.</div><div class="ttdef"><b>Definition</b> mock.h:461</div></div>
<div class="ttc" id="amock_8h_html_a45da68ed3f119848c88d8ef01622bcec"><div class="ttname"><a href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD(...)</div><div class="ttdef"><b>Definition</b> mock.h:411</div></div>
<div class="ttc" id="amock_8h_html_a4d8f3f37a1da67b31d455e5086be40f3"><div class="ttname"><a href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a></div><div class="ttdeci">#define DEFINE_MOCK_CONSTRUCTOR(Interface)</div><div class="ttdoc">Defines a constructor for a mock class.</div><div class="ttdef"><b>Definition</b> mock.h:466</div></div>
<div class="ttc" id="amock_8h_html_ae47eed5af62161b8cb04261fded66530"><div class="ttname"><a href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD_CONST(...)</div><div class="ttdoc">A variadic macro to define a mock method for a const member function.</div><div class="ttdef"><b>Definition</b> mock.h:456</div></div>
</div><!-- fragment --><p> The <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span> macros take the return type, method name, and in parentheses, the types of the method's arguments (without variable names).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_mock_behavior"></a>
Defining Mock Behavior</h3>
<p>After creating an instance of a mock object, you can define its behavior using the <span class="tt"><a class="el" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576" title="Defines the behavior of a mock method.">DEFINE_MOCK_BEHAVIOR</a></span> (for non-const methods) or <span class="tt"><a class="el" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15" title="Defines the behavior of a const mock method.">DEFINE_MOCK_BEHAVIOR_CONST</a></span> (for const methods) macro. This macro allows you to assign a lambda function that will be called when the mocked method is accessed.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span>   <span class="comment">// For mocking macros</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// For std::runtime_error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For completeness, copy IMyDependency and IMyDependencyMock definitions here</span></div>
<div class="line"><span class="comment">// In real code, they would be in header files</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, (<span class="keywordtype">int</span>))</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName, ())</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, (const std::<a class="code hl_class" href="classvector.html">vector</a>&lt;<span class="keywordtype">int</span>&gt; &amp;))</div>
<div class="line">};</div>
<div class="line"><span class="comment">// End of copied definitions</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Class that uses IMyDependency</span></div>
<div class="line">class MyClassUsesDependency {</div>
<div class="line">    IMyDependency* dependency;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassUsesDependency(IMyDependency* dep) : dependency(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> fetchValue(<span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Key cannot be negative&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dependency-&gt;getValue(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string getDepName()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> dependency-&gt;getName();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> sendData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) {</div>
<div class="line">        dependency-&gt;processData(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassUsesDependency_Behavior) {</div>
<div class="line">    IMyDependencyMock mockDep; <span class="comment">// Create a mock instance</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define behavior for getValue</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, (<span class="keywordtype">int</span> key)) {</div>
<div class="line">        <span class="comment">// This is a lambda function: [=](int key_param) -&gt; int { ... }</span></div>
<div class="line">        <span class="comment">// Parameter names in the lambda can be anything, but types must match those declared in DEFINE_MOCK_METHOD</span></div>
<div class="line">        <span class="keywordflow">if</span> (key == 1) <span class="keywordflow">return</span> 100;</div>
<div class="line">        <span class="keywordflow">if</span> (key == 42) <span class="keywordflow">return</span> 420;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define behavior for getName (const method)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a>(std::string, getName, mockDep, ()) {</div>
<div class="line">        <span class="comment">// Lambda for a method with no arguments: [=]() -&gt; std::string { ... }</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;MockedName&quot;</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Define behavior for processData (void method)</span></div>
<div class="line">    std::vector&lt;int&gt; receivedData;</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, (<span class="keyword">const</span> std::vector&lt;int&gt; &amp;data)) {</div>
<div class="line">        <span class="comment">// Lambda for a void method: [=](const std::vector&lt;int&gt;&amp; data_param) -&gt; void { ... }</span></div>
<div class="line">        receivedData = data; <span class="comment">// Copy data for verification</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClassUsesDependency mainObj(&amp;mockDep);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(1),   equal, 100);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(42),  equal, 420);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(10),  equal, -1);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.getDepName(),    equal, <span class="stringliteral">&quot;MockedName&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int&gt; dataToSend = {1, 2, 3};</div>
<div class="line">    mainObj.sendData(dataToSend);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(receivedData.size(),    equal, 3);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(receivedData[0],        equal, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check exception throwing from the main class, not the mock</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(-1), std::runtime_error);</div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_a8178900fca49688815d093d8c46b1c15"><div class="ttname"><a href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR_CONST(result_type, method_name, mock_object,...)</div><div class="ttdoc">Defines the behavior of a const mock method.</div><div class="ttdef"><b>Definition</b> mock.h:485</div></div>
<div class="ttc" id="amock_8h_html_aed1edc22e98dd2dc94c0368764223576"><div class="ttname"><a href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR(result_type, method_name, mock_object,...)</div><div class="ttdoc">Defines the behavior of a mock method.</div><div class="ttdef"><b>Definition</b> mock.h:473</div></div>
</div><!-- fragment --><p> In the lambda function defining the behavior, you can access the arguments with which the mocked method was called and return an appropriate value or perform necessary actions. The argument types in the lambda must match the types specified in <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span>.</p>
<p>Using <span class="tt"><a class="el" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3" title="Defines a constructor for a mock class.">DEFINE_MOCK_CONSTRUCTOR</a></span> is necessary if your original interface/class has constructors with parameters that you want to call when creating the mock object (e.g., if the mock inherits from a class rather than a pure interface, and the base class constructor needs to be called).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_mock_auto_creation"></a>
Automatic Mock Object Creation and Provisioning via <span class="tt">create()</span></h3>
<p>The Iridium framework provides a mechanism that allows static <span class="tt">create()</span> methods to return mock objects instead of real ones during testing. This is particularly useful when the class under test creates its dependencies internally. Understanding this mechanism requires looking at several macros and user conventions.</p>
<p><b>Key Macros and Their Interaction:</b></p>
<ol type="1">
<li><b><span class="tt">DEFINE_MOCK_CREATE</span> (Preprocessor Symbol):</b><ul>
<li>This is a <b>preprocessor symbol</b> that users should define for their test builds. This can be done, for example, by adding <span class="tt">#define DEFINE_MOCK_CREATE</span> at the top of a test file (before including Iridium headers like <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></span>) or via a compiler option (e.g., <span class="tt">-DDEFINE_MOCK_CREATE</span>).</li>
<li>The Iridium macro <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></span> (located in <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></span>) uses the preprocessor directive <span class="tt">#ifdef DEFINE_MOCK_CREATE</span> to conditionally compile the static <span class="tt">TClass::create(...)</span> method.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></span> (Iridium Macro from <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>This macro generates the static <span class="tt">TClass::create(...)</span> method.</li>
<li>Due to the <span class="tt">#ifdef DEFINE_MOCK_CREATE</span> check within <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE</a></span>:<ul>
<li>If <span class="tt">DEFINE_MOCK_CREATE</span> is defined when <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></span> is processed, the resulting <span class="tt">TClass::create(...)</span> method will call <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="A base class for mock objects.">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</span>.</li>
<li>If <span class="tt">DEFINE_MOCK_CREATE</span> is <em>not</em> defined, then <span class="tt">TClass::create(...)</span> will call <span class="tt">std::make_shared&lt;TClass&gt;(...)</span> to create a real object.</li>
</ul>
</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="A base class for mock objects.">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</span> (from <span class="tt"><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></span>):</b><ul>
<li>This method is called when <span class="tt">TClass::create(...)</span> has been generated in "mock mode" (due to <span class="tt">DEFINE_MOCK_CREATE</span>).</li>
<li>It checks an internal static flag, <span class="tt">Mock&lt;TClass&gt;::m_is_mocked</span>.</li>
<li>If <span class="tt">m_is_mocked == true</span> (this flag is set when an instance of a mock class, e.g., <span class="tt">TClassMock</span>, is created), then <span class="tt">Mock&lt;TClass&gt;::create(...)</span> attempts to return a previously registered instance of <span class="tt">TClassMock</span>. If no suitable mocks are available, an exception is thrown.</li>
<li>If <span class="tt">m_is_mocked == false</span>, then <span class="tt">Mock&lt;TClass&gt;::create(...)</span> attempts to create a real object via <span class="tt">std::make_shared&lt;TClass&gt;(...)</span>. <b>Important:</b> If <span class="tt">TClass</span> is an abstract interface, this attempt will result in a compile-time error.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...">DEFINE_IMPLEMENTATION(TClass)</a></span> (from <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>This Iridium macro is used for concrete classes. It internally calls <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></span>.</li>
<li>Consequently, the static <span class="tt">create()</span> method for classes defined with <span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...">DEFINE_IMPLEMENTATION</a></span> will automatically support switching between real and mock creation based on the presence of <span class="tt">DEFINE_MOCK_CREATE</span>.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE(Interface)</a></span> (from <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>This Iridium macro is used for defining interfaces. It defines typedefs for smart pointers and a virtual destructor.</li>
<li><b>Important:</b> <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE</a></span> does <b>not</b> use <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE</a></span>. Thus, interfaces defined solely with <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE</a></span> do not automatically get a static <span class="tt">create()</span> method that is managed by <span class="tt">DEFINE_MOCK_CREATE</span>.</li>
</ul>
</li>
</ol>
<p><b>Usage Scenarios:</b></p>
<ul>
<li><b>Mocking a Concrete Class:</b> If you have a concrete class <span class="tt">CMyImpl</span> defined with <span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...">DEFINE_IMPLEMENTATION(CMyImpl)</a></span>, and you define <span class="tt">DEFINE_MOCK_CREATE</span> in your test setup, then calls to <span class="tt">CMyImpl::create(...)</span> will automatically be routed to <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="A base class for mock objects.">iridium::testing::Mock</a>&lt;CMyImpl&gt;::create(...)</span>. If you've instantiated a <span class="tt">CMyImplMock</span>, it will then be provided.</li>
<li><b>Mocking via an Interface:</b> If you want <span class="tt">IMyInterface::create(...)</span> to return a mock, and <span class="tt">IMyInterface</span> is defined only with <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE</a></span>, you must <b>manually implement</b> the static <span class="tt">IMyInterface::create(...)</span> method. In your implementation, you can use <span class="tt">DEFINE_MOCK_CREATE</span> (or another flag of your choosing) to decide whether to call <span class="tt">std::make_shared&lt;CMyRealImpl&gt;(...)</span> or <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="A base class for mock objects.">iridium::testing::Mock</a>&lt;IMyInterface&gt;::create(...)</span>.</li>
</ul>
<p><b>Example (Mocking a concrete implementation, similar to <span class="tt">iridium-test/testing/example.cpp</span>):</b></p>
<div class="fragment"><div class="line"><span class="comment">// --- Start of Code Example ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include Iridium headers. Order can be important if DEFINE_MOCK_CREATE affects them.</span></div>
<div class="line"><span class="comment">// DEFINE_MOCK_CREATE should be defined before smart_ptr.h, where DEFINE_CREATE resides.</span></div>
<div class="line"><span class="comment">// For this example, we&#39;ll place DEFINE_MOCK_CREATE directly in the &quot;test file&quot;.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: IDataService.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// For DEFINE_INTERFACE</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IDataService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a>(IDataService); <span class="comment">// Does not create IDataService::create()</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: CDataServiceImpl.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;IDataService.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// For DEFINE_IMPLEMENTATION</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CDataServiceImpl : <span class="keyword">public</span> IDataService {</div>
<div class="line">    std::string mServiceName;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor for the real implementation</span></div>
<div class="line">    CDataServiceImpl(<span class="keyword">const</span> std::string&amp; name) : mServiceName(name) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// DEFINE_IMPLEMENTATION includes DEFINE_CREATE, which will respect DEFINE_MOCK_CREATE</span></div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a>(CDataServiceImpl);</div>
<div class="line"> </div>
<div class="line">    std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Real data for id &quot;</span> + std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot; from &quot;</span> + mServiceName;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: CDataServiceImplMock.h (or directly in the test .cpp)</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// We are mocking the concrete class</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(CDataServiceImpl) { <span class="comment">// Creates CDataServiceImplMock</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Since CDataServiceImpl has a constructor with parameters,</span></div>
<div class="line">    <span class="comment">// the mock must call it via DEFINE_MOCK_CONSTRUCTOR.</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(CDataServiceImpl)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(std::string, fetchData, (<span class="keywordtype">int</span>));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: DataConsumer.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Depends on the concrete implementation to call CDataServiceImpl::create()</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataConsumer {</div>
<div class="line">    std::shared_ptr&lt;CDataServiceImpl&gt; mDataService; <span class="comment">// Uses the concrete class</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataConsumer() {</div>
<div class="line">        <span class="comment">// Call CDataServiceImpl::create(), which will be governed by DEFINE_MOCK_CREATE</span></div>
<div class="line">        mDataService = CDataServiceImpl::create(<span class="stringliteral">&quot;MyRealService&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string processData(<span class="keywordtype">int</span> recordId) {</div>
<div class="line">        <span class="keywordflow">if</span> (!mDataService) <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error: Service not created&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Consumed: &quot;</span> + mDataService-&gt;fetchData(recordId);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: test_main.cpp (or your test file)</span></div>
<div class="line"><span class="comment">// THIS IS KEY: DEFINE_MOCK_CREATE should be defined BEFORE including</span></div>
<div class="line"><span class="comment">// iridium/smart_ptr.h if it&#39;s to affect DEFINE_CREATE within it.</span></div>
<div class="line"><span class="comment">// For simplicity here, we assume CDataServiceImpl.h (which pulls in smart_ptr.h)</span></div>
<div class="line"><span class="comment">// will be processed by the compiler after this define.</span></div>
<div class="line"><span class="preprocessor">#define DEFINE_MOCK_CREATE</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;DataConsumer.h&quot;       // Conceptually included above</span></div>
<div class="line"><span class="comment">// #include &quot;CDataServiceImplMock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(DataConsumer_UsesMockService) {</div>
<div class="line">    <span class="comment">// 1. Create an instance of the CDataServiceImplMock mock.</span></div>
<div class="line">    <span class="comment">//    This action sets Mock&lt;CDataServiceImpl&gt;::m_is_mocked = true;</span></div>
<div class="line">    <span class="comment">//    and registers this mockService in the list of available mocks.</span></div>
<div class="line">    <span class="comment">//    Pass constructor arguments as for the real CDataServiceImpl.</span></div>
<div class="line">    CDataServiceImplMock mockService(<span class="stringliteral">&quot;MockedServiceInstance&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Define behavior for the fetchData mock method</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(std::string, fetchData, mockService, (<span class="keywordtype">int</span> <span class="keywordtype">id</span>)) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 101) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;mocked_payload_for_101&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;generic_mock_payload&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create DataConsumer. Its constructor will call CDataServiceImpl::create(&quot;MyRealService&quot;).</span></div>
<div class="line">    <span class="comment">//    Because DEFINE_MOCK_CREATE is active, CDataServiceImpl::create() was generated</span></div>
<div class="line">    <span class="comment">//    to call iridium::testing::Mock&lt;CDataServiceImpl&gt;::create(...).</span></div>
<div class="line">    <span class="comment">//    Since mockService (of type CDataServiceImplMock) was created and registered,</span></div>
<div class="line">    <span class="comment">//    it will be returned. (The &quot;MyRealService&quot; argument would be used by the mock&#39;s constructor</span></div>
<div class="line">    <span class="comment">//    if it accepts it, or ignored if Mock&lt;T&gt;::create decides so for mocks).</span></div>
<div class="line">    DataConsumer consumer;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Verify that DataConsumer received and uses the mocked data</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(101), equal, <span class="stringliteral">&quot;Consumed: mocked_payload_for_101&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(200), equal, <span class="stringliteral">&quot;Consumed: generic_mock_payload&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// --- End of Code Example ---</span></div>
<div class="ttc" id="asmart__ptr_8h_html"><div class="ttname"><a href="smart__ptr_8h.html">smart_ptr.h</a></div><div class="ttdoc">Provides helper macros for defining standard smart pointer typedefs and static create factory methods...</div></div>
<div class="ttc" id="asmart__ptr_8h_html_a5314379c214998b38c9b5d50b1e1ac9d"><div class="ttname"><a href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a></div><div class="ttdeci">#define DEFINE_INTERFACE(TClass)</div><div class="ttdoc">A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...</div><div class="ttdef"><b>Definition</b> smart_ptr.h:96</div></div>
<div class="ttc" id="asmart__ptr_8h_html_ad4d8992039d0faf9ae66c4f596277280"><div class="ttname"><a href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a></div><div class="ttdeci">#define DEFINE_IMPLEMENTATION(TClass)</div><div class="ttdoc">A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...</div><div class="ttdef"><b>Definition</b> smart_ptr.h:110</div></div>
</div><!-- fragment --><p><b>Summary for Interfaces:</b></p>
<p>If you want to get a mock for an interface <span class="tt">IExample</span> via a call to <span class="tt">IExample::create()</span>, then, because <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE</a></span> does not provide <span class="tt">create()</span>, you must write this method yourself. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// In IExample.h or IExample.cpp</span></div>
<div class="line"><span class="comment">// #include &quot;CRealExampleImpl.h&quot; // Your real implementation</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/testing/mock.h&quot; // For Mock&lt;IExample&gt;::create()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::shared_ptr&lt;IExample&gt; IExample::create() { // Assuming you declared static create() in IExample</span></div>
<div class="line"><span class="comment">// #ifdef USER_TEST_FLAG_FOR_IEXAMPLE_MOCK // User-defined flag</span></div>
<div class="line"><span class="comment">//     return iridium::testing::Mock&lt;IExample&gt;::create();</span></div>
<div class="line"><span class="comment">// #else</span></div>
<div class="line"><span class="comment">//     return std::make_shared&lt;CRealExampleImpl&gt;();</span></div>
<div class="line"><span class="comment">// #endif</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><p> In this scenario, <span class="tt">DEFINE_MOCK_CREATE</span> is not directly used by Iridium for <span class="tt">IExample::create()</span>, but you could use it (or a similar flag like <span class="tt">USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</span>) in your own implementation of <span class="tt">IExample::create()</span>.</p>
<p>This detailed information should correctly reflect the mocking mechanism when using <span class="tt">create()</span> in Iridium.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_sequences"></a>
Testing Call Sequences</h2>
<p>Sometimes, it's important not only <em>which</em> methods of a mock object are called, but also the <em>order</em> in which they are called. The Iridium mocking framework provides tools to define and verify call sequences.</p>
<p>***Note:** This functionality may be incomplete or under development. The macros present in the code may not align with a full implementation of the <span class="tt">MockSequence</span> class.*</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_defining_sequences"></a>
Defining a Sequence (DEFINE_MOCK_SEQUENCE)</h3>
<p>The <span class="tt"><a class="el" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27" title="Defines a mock sequence.">DEFINE_MOCK_SEQUENCE(name)</a></span> macro is used to create a sequence object.</p><ul>
<li><span class="tt">name</span>: The name you give to this sequence (a variable <span class="tt">sequence_&lt;name&gt;</span> will be created).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_sequence_expectations"></a>
Expectations in a Sequence (DEFINE_MOCK_SEQUENCE_EXPECTATION)</h3>
<p>After defining a sequence object, you add expected calls to it using the <span class="tt"><a class="el" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57" title="Defines an expectation for a mock sequence.">DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock, method)</a></span> macro.</p><ul>
<li><span class="tt">sequence_name</span>: The name of the previously defined sequence.</li>
<li><span class="tt">mock</span>: The mock object.</li>
<li><span class="tt">method</span>: The name of the mocked method that is expected to be called.</li>
</ul>
<p>In the current implementation, this macro does not allow specifying the expected arguments for the method call. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
