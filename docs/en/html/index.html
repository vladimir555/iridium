<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iridium: Iridium</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iridium<span id="projectnumber">&#160;0.9.95</span>
   </div>
   <div id="projectbrief">Lightweight C++ framework (logging, serialization, threads, processes, I/O, testing)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iridium </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_mainpage__en"></a> </p><div style="float: left; margin-right: 15px; max-height: 50px;"> <div class="image">
<img src="logo.png" alt="" width="100px"/>
</div>
 </div><p>Welcome to the Iridium Library documentation!</p>
<p>This documentation provides information on how to use various components of the Iridium library. Explore the sections below to learn about its features.</p>
<h1><a class="anchor" id="sec_parsers_serializers"></a>
Parsers and Serializers</h1>
<p>The Iridium library provides a flexible mechanism for parsing data from string representations into a structured node tree, and for serializing (composing) these node trees back into strings. This is primarily achieved through the <code><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Interface for parsers and composers (serializers) of data. Parsers are responsible for converting a s...">iridium::parsing::IParser</a></code> interface.</p>
<h2><a class="anchor" id="subsec_iparser"></a>
The IParser Interface</h2>
<p>The <code><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Interface for parsers and composers (serializers) of data. Parsers are responsible for converting a s...">iridium::parsing::IParser</a></code> interface (defined in <code><a class="el" href="parser_8h.html" title="Defines the IParser interface for parsing and composing structured data. This interface provides meth...">iridium/parsing/parser.h</a></code>) is the core component for parsing and serialization. It exposes two main methods:</p><ul>
<li><code>parse(const std::string&amp; source)</code>: Takes a string as input and returns an <code>iridium::parsing::INode::TSharedPtr</code>, which is the root of a tree structure representing the parsed data.</li>
<li><code>compose(iridium::parsing::INode::TConstSharedPtr const&amp; root_node)</code>: Takes the root node of a tree structure and returns its string representation.</li>
</ul>
<h2><a class="anchor" id="subsec_obtaining_parser"></a>
Obtaining a Parser</h2>
<p>Specific parser implementations are provided for different data formats. For example, to create a JSON parser, you can use its static <code>create()</code> method:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span> <span class="comment">// For CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span> <span class="comment">// For IParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span>   <span class="comment">// For INode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (jsonParser) {</div>
<div class="line">        <span class="comment">// Use the parser...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;JSON Parser created successfully.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anode_8h_html"><div class="ttname"><a href="node_8h.html">node.h</a></div><div class="ttdoc">Defines the INode typedef, a specialization of INodeType&lt;std::string&gt;. This serves as the primary typ...</div></div>
<div class="ttc" id="aparser_8h_html"><div class="ttname"><a href="parser_8h.html">parser.h</a></div><div class="ttdoc">Defines the IParser interface for parsing and composing structured data. This interface provides meth...</div></div>
<div class="ttc" id="aparser__json_8h_html"><div class="ttname"><a href="parser__json_8h.html">parser_json.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_parsing_example"></a>
Parsing Example (JSON)</h2>
<p>Here's how you can parse a JSON string into an <code>INode</code> tree:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string json_string = R<span class="stringliteral">&quot;({ &quot;name&quot;: &quot;IridiumApp&quot;, &quot;version&quot;: 1.0, &quot;modules&quot;: [&quot;parsing&quot;, &quot;logging&quot;] })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(json_string);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;JSON parsed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// You can now inspect the rootNode tree structure.</span></div>
<div class="line">            <span class="comment">// For example, to get the &#39;name&#39; attribute:</span></div>
<div class="line">            iridium::parsing::INode::TSharedPtr nameNode = rootNode-&gt;getChild(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (nameNode) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Application Name: &quot;</span> &lt;&lt; nameNode-&gt;getValue() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Parsing returned a null node (empty input or other non-error case).&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_serializing_example"></a>
Serialization Example (JSON)</h2>
<p>To serialize an <code>INode</code> tree (for example, one you constructed programmatically or obtained from parsing) back into a JSON string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// For CNode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a simple node structure programmatically</span></div>
<div class="line">    iridium::parsing::INode::TSharedPtr root = iridium::parsing::implementation::CNode::create(<span class="stringliteral">&quot;config&quot;</span>);</div>
<div class="line">    root-&gt;addChild(<span class="stringliteral">&quot;setting1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line">    iridium::parsing::INode::TSharedPtr subNode = root-&gt;addChild(<span class="stringliteral">&quot;advanced_settings&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;timeout&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;retries&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::string composed_json = jsonParser-&gt;compose(root);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Composed JSON: &quot;</span> &lt;&lt; composed_json &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Composition failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aimplementation_2node_8h_html"><div class="ttname"><a href="implementation_2node_8h.html">node.h</a></div><div class="ttdoc">Defines the CNode typedef, a concrete node implementation based on CNodeType&lt;std::string&gt;....</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_serialization_macros"></a>
Typed Serialization with NodeView</h2>
<p>For more complex C++ data structures, the Iridium library offers a powerful serialization/deserialization framework based on <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Provides a typed view or wrapper around an underlying INode object. This class template facilitates t...">iridium::parsing::serialization::NodeView</a></code> and a set_of macros (like <code>DEFINE_ROOT_NODE_BEGIN</code>, <code>DEFINE_ATTRIBUTE</code>, <code>DEFINE_NODE_LIST_BEGIN</code>, etc.). These tools allow you to define C++ structs and classes that can be easily converted to and from an <code>INode</code> tree, and subsequently to/from string formats like JSON.</p>
<p>This system provides typed access to the node tree and automates much of the boilerplate code for serialization and deserialization. For detailed usage and examples, please refer to the header file <code><a class="el" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a></code>.</p>
<p>Here's a more concrete example of how to use these macros:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a>&quot;</span> <span class="comment">// For serialization macros</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span> <span class="comment">// For CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// For CNode (used by macros)</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For convert (used by macros)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span> <span class="comment">// Used by NodeViewList</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Required for the macros to compile if string conversions are needed.</span></div>
<div class="line"><span class="comment">// Normally, you&#39;d have these specializations for your custom types if they aren&#39;t basic.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a simple data item structure</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MyDataItem) <span class="comment">// Root node for direct use or nesting, uses &#39;-&#39; delimiter by default</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::string, Name, <span class="stringliteral">&quot;DefaultName&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, Value, 0)</div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a more complex settings structure</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MySettings) <span class="comment">// Root node, uses &#39;-&#39; delimiter</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ConfigName, <span class="stringliteral">&quot;DefaultConfig&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">bool</span>, IsEnabled, true)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a nested node using a previously defined root node structure</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a>(MyDataItem) <span class="comment">// Member name will be &#39;MyDataItem&#39;, node name &#39;my-data-item&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a list of MyDataItem</span></div>
<div class="line">    <span class="comment">// The list member will be named &#39;ItemList&#39;, and each item node will be named &#39;item&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a>(Item) <span class="comment">// This defines TItem and TItemList</span></div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ItemName, <span class="stringliteral">&quot;DefaultItem&quot;</span>)</div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, ItemId, 0)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a>(Item) <span class="comment">// Member name &#39;Item&#39; of type TItemList</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create an instance of the JSON parser</span></div>
<div class="line">    <span class="keyword">auto</span> jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Serialization Example ---</span></div>
<div class="line">    MySettings settingsToSerialize;</div>
<div class="line">    settingsToSerialize.ConfigName = <span class="stringliteral">&quot;UserSettings&quot;</span>;</div>
<div class="line">    settingsToSerialize.IsEnabled = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    settingsToSerialize.MyDataItem.Name = <span class="stringliteral">&quot;Special Item&quot;</span>;</div>
<div class="line">    settingsToSerialize.MyDataItem.Value = 123;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add items to the list</span></div>
<div class="line">    MySettings::TItem item1; <span class="comment">// Note: TItem is nested in MySettings due to DEFINE_NODE_LIST_BEGIN</span></div>
<div class="line">    item1.ItemName = <span class="stringliteral">&quot;FirstListItem&quot;</span>;</div>
<div class="line">    item1.ItemId = 1;</div>
<div class="line">    settingsToSerialize.Item.add(item1);</div>
<div class="line"> </div>
<div class="line">    MySettings::TItem item2;</div>
<div class="line">    item2.ItemName = <span class="stringliteral">&quot;SecondListItem&quot;</span>;</div>
<div class="line">    item2.ItemId = 2;</div>
<div class="line">    settingsToSerialize.Item.add(item2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// Get the INode from our settings object and compose it to JSON</span></div>
<div class="line">        std::string jsonOutput = jsonParser-&gt;compose(settingsToSerialize.getNode());</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Serialized JSON:&quot;</span> &lt;&lt; std::endl &lt;&lt; jsonOutput &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Expected output structure:</span></div>
<div class="line">        <span class="comment">// {</span></div>
<div class="line">        <span class="comment">//   &quot;config-name&quot;: &quot;UserSettings&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;is-enabled&quot;: &quot;true&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;my-data-item&quot;: {</span></div>
<div class="line">        <span class="comment">//     &quot;name&quot;: &quot;Special Item&quot;,</span></div>
<div class="line">        <span class="comment">//     &quot;value&quot;: &quot;123&quot;</span></div>
<div class="line">        <span class="comment">//   },</span></div>
<div class="line">        <span class="comment">//   &quot;item&quot;: [</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;FirstListItem&quot;, &quot;item-id&quot;: &quot;1&quot; },</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;SecondListItem&quot;, &quot;item-id&quot;: &quot;2&quot; }</span></div>
<div class="line">        <span class="comment">//   ]</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Serialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Deserialization Example ---</span></div>
<div class="line">    std::string jsonInput = R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">        &quot;config-name&quot;: &quot;LoadedSettings&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;is-enabled&quot;: &quot;false&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;my-data-item&quot;: {</span></div>
<div class="line"><span class="stringliteral">            &quot;name&quot;: &quot;LoadedItem&quot;,</span></div>
<div class="line"><span class="stringliteral">            &quot;value&quot;: &quot;456&quot;</span></div>
<div class="line"><span class="stringliteral">        },</span></div>
<div class="line"><span class="stringliteral">        &quot;item&quot;: [</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem1&quot;, &quot;item-id&quot;: &quot;10&quot; },</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem2&quot;, &quot;item-id&quot;: &quot;20&quot; }</span></div>
<div class="line"><span class="stringliteral">        ]</span></div>
<div class="line"><span class="stringliteral">    })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonInput);</div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            MySettings deserializedSettings(rootNode); <span class="comment">// Construct MySettings from the INode</span></div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Deserialized Settings:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Config Name: &quot;</span> &lt;&lt; deserializedSettings.ConfigName.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Is Enabled: &quot;</span> &lt;&lt; (deserializedSettings.IsEnabled.get() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Name: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Name.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Value: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Value.get() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;List Items:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : deserializedSettings.Item) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  - Name: &quot;</span> &lt;&lt; item.ItemName.get() &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; item.ItemId.get() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing input JSON returned a null node.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Deserialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconvert_8h_html"><div class="ttname"><a href="convert_8h.html">convert.h</a></div><div class="ttdoc">Public interface for the Iridium type conversion framework. Provides access to conversion functions a...</div></div>
<div class="ttc" id="aserialization_2node_8h_html"><div class="ttname"><a href="serialization_2node_8h.html">node.h</a></div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1547f0c86e3c410b26dcf1d13d1fcec7"><div class="ttname"><a href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_END(class_name)</div><div class="ttdoc">Ends the definition of a list of complex child nodes and declares an instance of the list....</div><div class="ttdef"><b>Definition</b> node.h:725</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1c49dbc67050d59e4b5e7d095067a81a"><div class="ttname"><a href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_BEGIN(class_name)</div><div class="ttdoc">Begins the definition of a list of complex child nodes. Generates two structs: T##class_name (for ind...</div><div class="ttdef"><b>Definition</b> node.h:704</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a6ae6809e071cbeb286389a6ea722e126"><div class="ttname"><a href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE(...)</div><div class="ttdoc">Chooser macro that dispatches to DEFINE_ATTRIBUTE_2 or DEFINE_ATTRIBUTE_3 based on the number of argu...</div><div class="ttdef"><b>Definition</b> node.h:684</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a7b4e724573d774904e29ede08ef7b17a"><div class="ttname"><a href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_END()</div><div class="ttdoc">Ends the definition of a root node structure started by DEFINE_ROOT_NODE_BEGIN. Simply provides the c...</div><div class="ttdef"><b>Definition</b> node.h:604</div></div>
<div class="ttc" id="aserialization_2node_8h_html_aac8f5e72dee27b1c9479d82a20f96f62"><div class="ttname"><a href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN(...)</div><div class="ttdoc">Chooser macro that dispatches to DEFINE_ROOT_NODE_BEGIN_1 or DEFINE_ROOT_NODE_BEGIN_2 based on the nu...</div><div class="ttdef"><b>Definition</b> node.h:595</div></div>
<div class="ttc" id="aserialization_2node_8h_html_ac671d110728b8a4bd1ea52fc352c9120"><div class="ttname"><a href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a></div><div class="ttdeci">#define DEFINE_NODE_EXTERNAL(class_name)</div><div class="ttdoc">Declares a member that is an instance of an externally defined root node structure....</div><div class="ttdef"><b>Definition</b> node.h:778</div></div>
</div><!-- fragment --><p>This example demonstrates defining structures with attributes, nested nodes, and lists of nodes. It then shows how to populate an instance of such a structure, serialize it to JSON, and deserialize JSON back into the structure using the <code>IParser</code> interface in conjunction with the node views generated by the macros. The <code>getNode()</code> method on the macro-defined struct provides the <code>INode</code> needed for <code>compose</code>, and the struct's constructor can take an <code>INode</code> (from <code>parse</code>) to populate itself. Remember that the actual node names in the JSON (e.g., "config-name") are derived from the C++ member names by converting CamelCase and inserting a delimiter (default is '-').</p>
<h1><a class="anchor" id="sec_logging"></a>
Logger Usage and Configuration</h1>
<p>The Iridium library includes a flexible logging facility to help instrument your application and diagnose issues. It supports multiple output destinations (sinks), configurable log levels, and asynchronous logging.</p>
<h2><a class="anchor" id="subsec_logging_macros"></a>
Basic Logging</h2>
<p>The easiest way to log messages is by using the provided logging macros:</p><ul>
<li><code>LOGT &lt;&lt; "Trace message";</code> (Trace level, often includes file/line, typically for debug builds)</li>
<li><code>LOGD &lt;&lt; "Debug message";</code> (Debug level, typically for debug builds)</li>
<li><code>LOGI &lt;&lt; "Informational message";</code> (Info level)</li>
<li><code>LOGW &lt;&lt; "Warning message";</code> (Warning level)</li>
<li><code>LOGE &lt;&lt; "Error message";</code> (Error level)</li>
<li><code>LOGF &lt;&lt; "Fatal message";</code> (Fatal level)</li>
</ul>
<p>These macros create a temporary log stream object. You can stream data into them using the <code>&lt;&lt;</code> operator, similar to <code>std::cout</code>. When the statement ends, the log message is automatically formatted and sent to the configured log sinks.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span> <span class="comment">// Main header for logging</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Basic configuration (default console output) is usually set up if no custom config is provided.</span></div>
<div class="line">    <span class="comment">// For more control, see configuration examples below.</span></div>
<div class="line">    <span class="comment">// iridium::logging::setConfig(iridium::logging::config::createDefault()); // Example of setting default</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> count = 42;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;Application started. Current count: &quot;</span> &lt;&lt; count;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This is a debug message. It might not appear in release builds.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (count &gt; 100) {</div>
<div class="line">        <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;Count is higher than expected: &quot;</span> &lt;&lt; count;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// LOGE &lt;&lt; &quot;An example error occurred.&quot;;</span></div>
<div class="line">    <span class="comment">// LOGF &lt;&lt; &quot;A fatal error occurred, application might terminate.&quot;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html"><div class="ttname"><a href="logger_8h.html">logger.h</a></div><div class="ttdoc">Defines the main Logger singleton class, LogStream and LogStreamDummy helper structs,...</div></div>
<div class="ttc" id="alogger_8h_html_a13fd5c842ec8d93baac58bb616497fe8"><div class="ttname"><a href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a></div><div class="ttdeci">#define LOGI</div><div class="ttdoc">Logging macro for INFO level messages. Usage: LOGI &lt;&lt; &quot;Informational message: &quot; &lt;&lt; value;</div><div class="ttdef"><b>Definition</b> logger.h:531</div></div>
<div class="ttc" id="alogger_8h_html_a62b5282578b939fd77b7bb1d00c4f15a"><div class="ttname"><a href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a></div><div class="ttdeci">#define LOGD</div><div class="ttdoc">Logging macro for DEBUG level messages. Disabled if BUILD_TYPE_DEBUG or BUILD_FLAG_FORCE_DEBUG_LOG is...</div><div class="ttdef"><b>Definition</b> logger.h:522</div></div>
<div class="ttc" id="alogger_8h_html_ac6f0b43ab85743ce5de50d53bda6de62"><div class="ttname"><a href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a></div><div class="ttdeci">#define LOGW</div><div class="ttdoc">Logging macro for WARNING level messages. Usage: LOGW &lt;&lt; &quot;Warning message: &quot; &lt;&lt; value;</div><div class="ttdef"><b>Definition</b> logger.h:539</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_logger_configuration"></a>
Logger Configuration</h2>
<p>The logger is configured using the <code>iridium::logging::config::TLogger</code> structure, which is defined in <code><a class="el" href="logging_2config_8h.html">iridium/logging/config.h</a></code>. This structure can be populated programmatically or potentially loaded from a configuration file (if parsed into an <code>INode</code> tree).</p>
<p>Key fields in <code>iridium::logging::config::TLogger</code>:</p><ul>
<li><code>IsGmtTime</code> (bool): If <code>true</code>, timestamps are in GMT/UTC; otherwise, local time is used. Defaults to <code>false</code>.</li>
<li><code>Level</code> (<code>iridium::logging::TEvent::TLevel</code>): The global default log level. Specific sinks can override this. Defaults to <code>TRACE</code>.</li>
<li><code>Sink</code> (a list of <code>TLogger::TSink</code> objects): Defines one or more output destinations for log messages.</li>
</ul>
<p>Each <code>TLogger::TSink</code> object in the <code>Sink</code> list has the following key fields:</p><ul>
<li><code>Type</code> (<code>iridium::logging::config::TLogger::TSink::TSinkType</code>): Specifies the sink type. Common values:<ul>
<li><code>CONSOLE</code>: Output to the standard console.</li>
<li><code>FILE</code>: Output to a single file.</li>
<li><code>FILE_DAILY</code>: Output to a file that rotates daily.</li>
<li><code>FILE_TIMELY</code>: Output to a new file every time the logger starts.</li>
</ul>
</li>
<li><code>IsAsync</code> (bool): If <code>true</code>, this sink processes log messages asynchronously in a separate thread. Defaults to <code>false</code>.</li>
<li><code>Uri</code> (std::string): For file-based sinks (<code>FILE</code>, <code>FILE_DAILY</code>, <code>FILE_TIMELY</code>), this is the path to the log file.</li>
<li><code>Level</code> (<code>iridium::logging::TEvent::TLevel</code>): A specific log level for this sink. If set to <code>UNKNOWN</code>, it inherits the global logger level. Otherwise, it overrides the global level for this particular sink.</li>
</ul>
<h2><a class="anchor" id="subsec_logger_config_example"></a>
Programmatic Configuration Example</h2>
<p>Here's how to configure the logger programmatically:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logging_2config_8h.html">iridium/logging/config.h</a>&quot;</span> <span class="comment">// For TLogger, TEvent::TLevel, etc.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Create a TLogger configuration object</span></div>
<div class="line">    iridium::logging::config::TLogger loggerConfig;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set global properties</span></div>
<div class="line">    loggerConfig.IsGmtTime = <span class="keyword">false</span>;</div>
<div class="line">    loggerConfig.Level = iridium::logging::TEvent::TLevel::INFO; <span class="comment">// Global level</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Configure a Console Sink</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink consoleSink;</div>
<div class="line">    consoleSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::CONSOLE;</div>
<div class="line">    consoleSink.IsAsync = <span class="keyword">false</span>;</div>
<div class="line">    consoleSink.Level = iridium::logging::TEvent::TLevel::DEBUG; <span class="comment">// Console will show DEBUG and above</span></div>
<div class="line">    loggerConfig.Sink.add(consoleSink); <span class="comment">// Add to the list of sinks</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Configure a File Sink</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink fileSink;</div>
<div class="line">    fileSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::FILE;</div>
<div class="line">    fileSink.IsAsync = <span class="keyword">true</span>; <span class="comment">// Log to file asynchronously</span></div>
<div class="line">    fileSink.Uri = <span class="stringliteral">&quot;application.log&quot;</span>;</div>
<div class="line">    fileSink.Level = iridium::logging::TEvent::TLevel::WARNING; <span class="comment">// File will only get WARNING and above</span></div>
<div class="line">    loggerConfig.Sink.add(fileSink);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Apply the configuration</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a>(loggerConfig);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now the logger is configured.</span></div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; <span class="stringliteral">&quot;This TRACE message will not appear on console or file.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This DEBUG message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;This INFO message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;This WARNING message will appear on console AND in application.log.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; <span class="stringliteral">&quot;This ERROR message will also appear on console AND in application.log.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html_a4f7814d1bd32cecccb2f3fafbb3ade58"><div class="ttname"><a href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a></div><div class="ttdeci">#define LOGT</div><div class="ttdoc">Logging macro for TRACE level messages. Prepends file name and line number. Disabled if BUILD_TYPE_DE...</div><div class="ttdef"><b>Definition</b> logger.h:507</div></div>
<div class="ttc" id="alogger_8h_html_ae08358ff7da64345ad674296a5957823"><div class="ttname"><a href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a></div><div class="ttdeci">#define LOGE</div><div class="ttdoc">Logging macro for ERROR level messages. Usage: LOGE &lt;&lt; &quot;Error message: &quot; &lt;&lt; value;</div><div class="ttdef"><b>Definition</b> logger.h:547</div></div>
<div class="ttc" id="alogging_2config_8h_html"><div class="ttname"><a href="logging_2config_8h.html">config.h</a></div></div>
<div class="ttc" id="anamespaceiridium_1_1logging_html_a4fff5fa51c4d1b05c97ae08faf5efd18"><div class="ttname"><a href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a></div><div class="ttdeci">void setConfig(config::TLogger const &amp;config)</div><div class="ttdoc">Sets the global logger configuration. This is a free function wrapper around Logger::instance()....</div><div class="ttdef"><b>Definition</b> logger.cpp:158</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_default_config"></a>
Default Configuration</h2>
<p>The library provides a helper function to get a simple default configuration: <code>iridium::logging::config::TLogger defaultConfig = <a class="el" href="namespaceiridium_1_1logging_1_1config.html#a57a36466c8a3545a48ab706922b86672">iridium::logging::config::createDefault()</a>;</code></p>
<p>This default configuration typically sets up a synchronous console sink with the <code>TRACE</code> log level. You can modify this default configuration object before applying it with <code><a class="el" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18" title="Sets the global logger configuration. This is a free function wrapper around Logger::instance()....">iridium::logging::setConfig()</a></code>.</p>
<p>Remember that logger configuration should ideally be done early in your application's lifecycle, before any significant logging occurs.</p>
<h1><a class="anchor" id="sec_custom_type_conversion"></a>
Integrating Custom Types with <code>iridium::convertion::convert</code></h1>
<p>The Iridium library provides a flexible way to integrate your custom data types with its systems, such as logging and the serialization macros. This is achieved by providing specializations for the <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a>&lt;TargetType, SourceType&gt;</code> template function for your custom type.</p>
<p>The library offers a pair of macros to help declare and implement these specializations:</p><ul>
<li><b><code><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Defines (declares) a specialization for the iridium::convertion::implementation::convert function tem...">DEFINE_CONVERT(TTo, TFrom)</a></code></b>: This macro should be used in your header file (e.g., alongside your custom type definition). It declares to the compiler that a specific conversion specialization will be made available.</li>
<li><b><code><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Implements a specialization for the iridium::convertion::implementation::convert function template....">IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</a></code></b>: This macro is used in a source file (.cpp) to provide the actual implementation for the conversion. <code>TFunc</code> must be a function, functor, or lambda that takes a <code>TFrom const&amp;</code> argument and returns a <code>TTo</code>.</li>
</ul>
<h2><a class="anchor" id="subsec_custom_convert_example_fn"></a>
Example: Custom <code>Point</code> Type</h2>
<p>Let's illustrate with a custom <code>Point</code> struct.</p>
<p><b>1. Define the Type and Declare Conversions (e.g., in <code>Point.h</code>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once </span><span class="comment">// Example header guard</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For DEFINE_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span> <span class="comment">// Required for std::string usage</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom struct</span></div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optional: For direct comparison in examples or tests</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> x == other.x &amp;&amp; y == other.y;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declare that we will provide specializations for converting</span></div>
<div class="line"><span class="comment">// Point to std::string and std::string to Point.</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(std::string, Point);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(Point, std::string);</div>
<div class="ttc" id="aconvert_8h_html_ab6323540b384b64371e62ea6e910317b"><div class="ttname"><a href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a></div><div class="ttdeci">#define DEFINE_CONVERT(TTo, TFrom)</div><div class="ttdoc">Defines (declares) a specialization for the iridium::convertion::implementation::convert function tem...</div><div class="ttdef"><b>Definition</b> convert.h:69</div></div>
</div><!-- fragment --><p><b>2. Implement the Conversions (e.g., in <code>Point.cpp</code>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Assuming Point struct and DEFINE_CONVERT declarations are here</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For IMPLEMENT_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// For std::invalid_argument, std::out_of_range</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper function to convert Point to std::string</span></div>
<div class="line"><span class="keyword">static</span> std::string localPointToString(<span class="keyword">const</span> Point&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + std::to_string(p.x) + <span class="stringliteral">&quot;,&quot;</span> + std::to_string(p.y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper function to convert std::string to Point</span></div>
<div class="line"><span class="keyword">static</span> Point localStringToPoint(<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s.length() &lt; 3 || s.front() != <span class="charliteral">&#39;(&#39;</span> || s.back() != <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing parentheses. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    std::string content = s.substr(1, s.length() - 2); <span class="comment">// Remove parentheses</span></div>
<div class="line">    <span class="keywordtype">size_t</span> comma_pos = content.find(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (comma_pos == std::string::npos) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing comma. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordtype">int</span> x_val = std::stoi(content.substr(0, comma_pos));</div>
<div class="line">        <span class="keywordtype">int</span> y_val = std::stoi(content.substr(comma_pos + 1));</div>
<div class="line">        <span class="keywordflow">return</span> {x_val, y_val};</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e_ia) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid integer in Point string: &quot;</span> + std::string(e_ia.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; e_oor) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Integer out of range in Point string: &quot;</span> + std::string(e_oor.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement the declared conversion specializations using the helper functions</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(std::string, Point, localPointToString);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(Point, std::string, localStringToPoint);</div>
<div class="ttc" id="aconvert_8h_html_aa14ff619763935045ee893f7f1e8668f"><div class="ttname"><a href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a></div><div class="ttdeci">#define IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</div><div class="ttdoc">Implements a specialization for the iridium::convertion::implementation::convert function template....</div><div class="ttdef"><b>Definition</b> convert.h:94</div></div>
</div><!-- fragment --><p><b>3. Usage Example (e.g., in <code>main.cpp</code> or tests)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Your custom type&#39;s header</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span>   <span class="comment">// For LOGI (example usage)</span></div>
<div class="line"><span class="comment">// For serialization macros example (conceptual)</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/serialization/node.h&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// For std::cout</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main_custom_convert_demo() { <span class="comment">// Renamed to avoid collision if mainpage.md is compiled</span></div>
<div class="line">    Point p1 = {7, 14};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Logging Example:</span></div>
<div class="line">    <span class="comment">// The iridium::logging::LogStream typically uses iridium::convertion::convert&lt;std::string&gt;(value)</span></div>
<div class="line">    <span class="comment">// for types that don&#39;t have a direct std::ostream&amp; operator&lt;&lt; overload.</span></div>
<div class="line">    <span class="comment">// So, after defining the conversion, this should work:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;My custom point: &quot; &lt;&lt; p1;</span></div>
<div class="line">    <span class="comment">// For this example, we&#39;ll demonstrate the conversion explicitly:</span></div>
<div class="line">    std::string p1_as_string = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(p1);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Point p1 converted to string: &quot;</span> &lt;&lt; p1_as_string &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Deserialization Example (e.g., from a configuration string):</span></div>
<div class="line">    std::string input_string = <span class="stringliteral">&quot;(100,-200)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        Point p2 = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;Point&gt;</a>(input_string);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;String &#39;&quot;</span> &lt;&lt; input_string &lt;&lt; <span class="stringliteral">&quot;&#39; converted to Point: (&quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; p2.y &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error converting string to Point: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// How this applies to serialization macros:</span></div>
<div class="line">    <span class="comment">// If you define a serializable struct like this:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyStructure)</span></div>
<div class="line">    <span class="comment">//   DEFINE_ATTRIBUTE(Point, Position) // Uses Point</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// MyStructure data;</span></div>
<div class="line">    <span class="comment">// data.Position = {5,5}; // Set the Point</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // When serializing:</span></div>
<div class="line">    <span class="comment">// // auto jsonParser = iridium::parsing::implementation::CJSONParser::create();</span></div>
<div class="line">    <span class="comment">// // std::string json_output = jsonParser-&gt;compose(data.getNode());</span></div>
<div class="line">    <span class="comment">// // ...the &#39;Position&#39; node&#39;s value would be &quot;(5,5)&quot; due to Convert&lt;std::string, Point&gt;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // When deserializing:</span></div>
<div class="line">    <span class="comment">// // std::string json_input = R&quot;({ &quot;position&quot;: &quot;(10,20)&quot; })&quot;;</span></div>
<div class="line">    <span class="comment">// // MyStructure loaded_data(jsonParser-&gt;parse(json_input));</span></div>
<div class="line">    <span class="comment">// // ...the string &quot;(10,20)&quot; would be converted to a Point object for &#39;Position&#39;</span></div>
<div class="line">    <span class="comment">// //    due to Convert&lt;Point, std::string&gt;.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceiridium_1_1convertion_html_a5afe4d5e065e8b085dcd6b8b391f2c2d"><div class="ttname"><a href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert</a></div><div class="ttdeci">string convert(system_clock::time_point const &amp;value, bool const &amp;is_gmt_time)</div><div class="ttdoc">Provides access to the core conversion function template from the implementation namespace....</div><div class="ttdef"><b>Definition</b> convert.cpp:89</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_custom_convert_fn_impact"></a>
Impact of Custom <code>convert</code> Specializations</h2>
<p><b>For Logging:</b> Once you provide a specialization <code><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Defines (declares) a specialization for the iridium::convertion::implementation::convert function tem...">DEFINE_CONVERT(std::string, YourCustomType)</a></code> and its implementation, your custom objects can often be directly used in logging statements (e.g., <code>LOGI &lt;&lt; yourCustomObject;</code>). The logging framework will typically call <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a>&lt;std::string&gt;(yourCustomObject)</code> to get a string representation if no direct <code>operator&lt;&lt;(std::ostream&amp;, const YourCustomType&amp;)</code> is found or preferred.</p>
<p><b>For Serialization Macros:</b> When using serialization macros like <code><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126" title="Chooser macro that dispatches to DEFINE_ATTRIBUTE_2 or DEFINE_ATTRIBUTE_3 based on the number of argu...">DEFINE_ATTRIBUTE(YourCustomType, myField)</a></code>:</p><ul>
<li>The specialization for <code>Convert&lt;std::string, YourCustomType&gt;</code> (implemented via <code>IMPLEMENT_CONVERT</code>) is used to convert the <code>myField</code> member into its string representation when serializing the parent structure. This string is then stored as the value of the corresponding node (e.g., a JSON string attribute or an XML text node).</li>
<li>The specialization for <code>Convert&lt;YourCustomType, std::string&gt;</code> (implemented via <code>IMPLEMENT_CONVERT</code>) is used during deserialization. If the parser reads a string value from the input data (e.g., from a JSON attribute) that needs to be converted to <code>YourCustomType</code> for <code>myField</code>, this specialization will be invoked.</li>
</ul>
<p>By providing these <code>convert</code> function specializations, you enable your custom data types to integrate smoothly with various parts of the Iridium library that rely on type conversion, particularly for string-based representations. Remember to declare the specializations with <code>DEFINE_CONVERT</code> in a header and implement them with <code>IMPLEMENT_CONVERT</code> and your conversion logic in a source file.</p>
<h1><a class="anchor" id="sec_define_enum"></a>
Handling Enumerations with DEFINE_ENUM</h1>
<p>The Iridium library often provides a utility macro, <code>DEFINE_ENUM</code> (typically expected in a header like <code><a class="el" href="enum_8h.html" title="Provides macros for creating enhanced C++ enumerations with features like string conversion and itera...">iridium/enum.h</a></code> or a general utilities header), to simplify the definition of C++ <code>enum class</code> types and automatically integrate them with the <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a></code> system. This integration is crucial for easily logging enum values as human-readable strings and for serializing/deserializing them in configuration files or data interchange formats.</p>
<p><b>Key Functionality of <code>DEFINE_ENUM</code>:</b></p>
<p>When you use <code>DEFINE_ENUM</code>, it generally performs the following actions:</p><ol type="1">
<li><b>Defines the <code>enum class</code></b>: It creates the actual C++ <code>enum class</code> with the specified name and enumerators.</li>
<li><b>Generates String Conversions</b>: Most importantly, it automatically generates the necessary specializations for <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a></code> to allow:<ul>
<li>Converting an enum value to its string representation (e.g., <code>MyEnum::ValueOne</code> becomes <code>"ValueOne"</code>).</li>
<li>Converting a string representation back to an enum value (e.g., <code>"ValueOne"</code> becomes <code>MyEnum::ValueOne</code>).</li>
</ul>
</li>
</ol>
<p><b>Typical Syntax:</b></p>
<p>While the exact syntax can vary slightly based on the specific macro implementation, a common pattern is:</p>
<p><code><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Defines an enhanced enumeration class. This macro generates a class that wraps a standard C++ enum,...">DEFINE_ENUM(EnumTypeName, Enumerator1, Enumerator2, ..., [OptionalDefaultOrUnknownEnumerator])</a></code></p>
<ul>
<li><code>EnumTypeName</code>: The desired name for your <code>enum class</code>.</li>
<li><code>Enumerator1, Enumerator2, ...</code>: The list of enumerator names.</li>
<li><code>[OptionalDefaultOrUnknownEnumerator]</code>: Often, the last enumerator can be designated (e.g., named <code>Unknown</code> or <code>Default</code>) to serve as a fallback value if a string cannot be successfully parsed into one of the other defined enumerators. If not specified, attempting to convert an invalid string to the enum type might result in the first enumerator being returned, or potentially an error, depending on the macro's design.</li>
</ul>
<h2><a class="anchor" id="subsec_define_enum_example"></a>
Example Usage</h2>
<p>Let's illustrate with a couple of examples. (Ensure you include the header that provides <code>DEFINE_ENUM</code>, e.g., <code>#include "iridium/enum.h"</code>)</p>
<div class="fragment"><div class="line"><span class="comment">// Note: The DEFINE_ENUM macro is provided by the Iridium library.</span></div>
<div class="line"><span class="comment">// You would typically include a header like &lt;iridium/enum.h&gt; to use it.</span></div>
<div class="line"><span class="comment">// mainpage_example_define_enum.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// It&#39;s assumed that &quot;iridium/enum.h&quot; or a similar header defining DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// and &quot;iridium/convertion/convert.h&quot; are available.</span></div>
<div class="line"><span class="comment">// For this example, we&#39;ll mock the macro&#39;s expected behavior for demonstration if needed,</span></div>
<div class="line"><span class="comment">// but ideally, it comes from the library.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 1: Simple Color Enumeration</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(MyColor,</div>
<div class="line">    Red,    <span class="comment">// Mapped to &quot;Red&quot;</span></div>
<div class="line">    Green,  <span class="comment">// Mapped to &quot;Green&quot;</span></div>
<div class="line">    Blue    <span class="comment">// Mapped to &quot;Blue&quot;</span></div>
<div class="line">) <span class="comment">// MyColor will have MyColor::Red, MyColor::Green, MyColor::Blue</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 2: Operation Status with an explicit Unknown/Default value</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(OperationStatus,</div>
<div class="line">    Success,</div>
<div class="line">    Pending,</div>
<div class="line">    Failed,</div>
<div class="line">    Unknown <span class="comment">// This can serve as a default if parsing a string fails</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/logging/logger.h&quot; // For LOGI (conceptual)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_define_enum_usage() {</div>
<div class="line">    MyColor favoriteColor = MyColor::Green;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert enum to string (e.g., for logging or serialization)</span></div>
<div class="line">    <span class="comment">// The DEFINE_ENUM macro is expected to have created the necessary</span></div>
<div class="line">    <span class="comment">// iridium::convertion::convert&lt;std::string, MyColor&gt; specialization.</span></div>
<div class="line">    std::string colorStr = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(favoriteColor);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Favorite color: &quot;</span> &lt;&lt; colorStr &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Green&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Conceptual logging:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;Current status: &quot; &lt;&lt; OperationStatus::Pending; // Would output &quot;Pending&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert string to enum (e.g., for deserialization from a config file)</span></div>
<div class="line">    std::string inputColorStr = <span class="stringliteral">&quot;Blue&quot;</span>;</div>
<div class="line">    MyColor parsedColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;MyColor&gt;</a>(inputColorStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed color from string &#39;&quot;</span> &lt;&lt; inputColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(parsedColor) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Blue&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example of parsing an invalid string for MyColor</span></div>
<div class="line">    std::string invalidColorStr = <span class="stringliteral">&quot;Purple&quot;</span>;</div>
<div class="line">    MyColor defaultOrFirstColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;MyColor&gt;</a>(invalidColorStr);</div>
<div class="line">    <span class="comment">// Behavior for invalid string depends on DEFINE_ENUM implementation.</span></div>
<div class="line">    <span class="comment">// It might default to the first enumerator (Red) or a specified &#39;Unknown&#39; value if the macro supports that.</span></div>
<div class="line">    <span class="comment">// Our conceptual placeholder defaults to &#39;Unknown&#39; if available, or first if not.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid color string &#39;&quot;</span> &lt;&lt; invalidColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(defaultOrFirstColor) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example with OperationStatus which has an &#39;Unknown&#39; default</span></div>
<div class="line">    std::string invalidStatusStr = <span class="stringliteral">&quot;NonExistentStatus&quot;</span>;</div>
<div class="line">    OperationStatus status = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;OperationStatus&gt;</a>(invalidStatusStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid status string &#39;&quot;</span> &lt;&lt; invalidStatusStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(status) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Unknown&quot;</span></div>
<div class="line"> </div>
<div class="line">    OperationStatus goodStatus = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;OperationStatus&gt;</a>(<span class="stringliteral">&quot;Success&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed valid status string &#39;Success&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(goodStatus) &lt;&lt; std::endl; <span class="comment">// Expected: &quot;Success&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aenum_8h_html_acf1825d3b8e6ea6b7e5f4dbc5bacae6d"><div class="ttname"><a href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a></div><div class="ttdeci">#define DEFINE_ENUM(TEnum,...)</div><div class="ttdoc">Defines an enhanced enumeration class. This macro generates a class that wraps a standard C++ enum,...</div><div class="ttdef"><b>Definition</b> enum.h:56</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_define_enum_impact"></a>
Impact of <code>DEFINE_ENUM</code></h2>
<p><b>Simplified Logging:</b> Because <code>DEFINE_ENUM</code> typically handles the creation of <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a>&lt;std::string, YourEnumType&gt;</code>, enum values can be directly used in logging statements, and they will be automatically converted to their human-readable string names: </p><div class="fragment"><div class="line"><span class="comment">// MyColor color = MyColor::Blue;</span></div>
<div class="line"><span class="comment">// LOGI &lt;&lt; &quot;Current color selection: &quot; &lt;&lt; color; // Would log &quot;Current color selection: Blue&quot;</span></div>
</div><!-- fragment --><p><b>Seamless Serialization:</b> Enums defined with <code>DEFINE_ENUM</code> integrate smoothly with Iridium's serialization macros. If you use such an enum as a type for an attribute: </p><div class="fragment"><div class="line"><span class="comment">// // Assuming MyColor is defined using DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyWidgetConfig)</span></div>
<div class="line"><span class="comment">//   DEFINE_ATTRIBUTE(MyColor, WidgetColor)</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyWidgetConfig config;</span></div>
<div class="line"><span class="comment">// config.WidgetColor = MyColor::Red;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// // Serializing &#39;config&#39; would store &quot;Red&quot; for the &#39;widget-color&#39; attribute.</span></div>
<div class="line"><span class="comment">// // Deserializing a structure where &#39;widget-color&#39; is &quot;Green&quot; would set config.WidgetColor to MyColor::Green.</span></div>
</div><!-- fragment --><p> The serialization system uses the auto-generated <code>convert</code> specializations to handle the transformation between the enum values and their string representations in the serialized data (e.g., JSON, XML).</p>
<p>Using <code>DEFINE_ENUM</code> thus reduces boilerplate, ensures consistency, and makes working with enumerations in Iridium much more convenient. Always refer to the specific <code><a class="el" href="enum_8h.html" title="Provides macros for creating enhanced C++ enumerations with features like string conversion and itera...">iridium/enum.h</a></code> or equivalent header in your version of the library for the exact capabilities and syntax of the <code>DEFINE_ENUM</code> macro.</p>
<h1><a class="anchor" id="sec_threading"></a>
Multithreading Primitives</h1>
<p>The Iridium library provides several primitives to aid in multithreaded application development. These include tools for direct thread management, data synchronization, and task processing with worker threads and pools.</p>
<p>Note: Some concrete classes like <code><a class="el" href="class_c_thread.html" title="Concrete implementation of the IThread interface. Manages an actual std::thread to execute an IRunnab...">CThread</a></code>, <code><a class="el" href="class_c_worker.html" title="Implements IWorker to process items from an input queue and place results in an output queue,...">CWorker</a></code>, and <code><a class="el" href="class_c_worker_pool.html">CWorkerPool</a></code> reside in the <code><a class="el" href="namespaceiridium_1_1threading_1_1implementation.html" title="Contains concrete implementations of the interfaces defined in the parent threading namespace.">iridium::threading::implementation</a></code> namespace. While they might have <code>::create()</code> factory methods suggesting usability, this namespacing typically indicates they are foundational blocks, possibly intended to be wrapped by higher-level abstractions in some cases. However, their direct usage is documented here as per common need.</p>
<h2><a class="anchor" id="subsec_cthread"></a>
Using CThread for Direct Thread Management</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_thread.html" title="Concrete implementation of the IThread interface. Manages an actual std::thread to execute an IRunnab...">iridium::threading::implementation::CThread</a></code> allows you to create and manage a dedicated thread. It executes a task defined by an object implementing the <code><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></code> interface.</p>
<p><b><code>IRunnable</code> Interface:</b> To define the work for a <code><a class="el" href="class_c_thread.html" title="Concrete implementation of the IThread interface. Manages an actual std::thread to execute an IRunnab...">CThread</a></code>, you create a class that inherits from <code><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></code>. This interface requires you to implement:</p><ul>
<li><code>void initialize()</code>: Called once after the thread starts, for setup.</li>
<li><code>void finalize()</code>: Called once before the thread joins, for cleanup.</li>
<li><code>void run(std::atomic&lt;bool&gt;&amp; is_running)</code>: This is the main function executed by the thread. It should contain your task's logic and periodically check the <code>is_running</code> flag. When <code>is_running</code> becomes <code>false</code>, the <code>run</code> method should return to allow the thread to exit gracefully.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cthread.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2thread_8h.html">iridium/threading/implementation/thread.h</a>&quot;</span> <span class="comment">// For CThread</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="runnable_8h.html">iridium/threading/runnable.h</a>&quot;</span>       <span class="comment">// For IRunnable</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span>         <span class="comment">// For iridium::threading::sleep, IThread (for getNameStatic)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span> <span class="comment">// For std::chrono::milliseconds</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// For std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Implement IRunnable</span></div>
<div class="line"><span class="keyword">class </span>MyPeriodicTask : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Initializing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">run</a>(std::atomic&lt;bool&gt;&amp; is_running)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (is_running) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;): Working, count: &quot;</span> &lt;&lt; ++counter &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Simulate work by sleeping</span></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 5 &amp;&amp; is_running; ++i) { <span class="comment">// Check is_running more frequently during &quot;work&quot;</span></div>
<div class="line">                 <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(200);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Exiting run loop.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Finalizing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cthread() {</div>
<div class="line">    <span class="comment">// 2. Create an instance of your IRunnable</span></div>
<div class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;MyPeriodicTask&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create and manage the CThread</span></div>
<div class="line">    <span class="comment">// CThread::create takes (name, IRunnable::TSharedPtr)</span></div>
<div class="line">    <span class="keyword">auto</span> thread_obj = iridium::threading::implementation::CThread::create(<span class="stringliteral">&quot;MyWorker1&quot;</span>, task);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Initializing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;initialize(); <span class="comment">// Starts the thread and waits for it to be running</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Sleeping for 3 seconds while thread runs...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(3000);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Finalizing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;finalize(); <span class="comment">// Signals thread to stop and waits for it to join</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Thread finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Thread operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a5b8c613423cd12e98327a9279d8b9d64"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">iridium::pattern::IInitializable::initialize</a></div><div class="ttdeci">virtual void initialize()=0</div><div class="ttdoc">Performs the initialization of the object. This method should be called after the object is construct...</div></div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a93a1fb6f89e1e1f125455a8682e9ae59"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">iridium::pattern::IInitializable::finalize</a></div><div class="ttdeci">virtual void finalize()=0</div><div class="ttdoc">Performs the finalization or cleanup of the object. This method should be called when the object is n...</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></div><div class="ttdef"><b>Definition</b> runnable.h:19</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html_a8849596ba04c14d98b200c24491dcd97"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">iridium::threading::IRunnable::run</a></div><div class="ttdeci">virtual void run(std::atomic&lt; bool &gt; &amp;is_running)=0</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_aebf89ec3258e418ee6141cb9a5adb285"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a></div><div class="ttdeci">static std::string const &amp; getNameStatic()</div><div class="ttdoc">Gets the name of the currently executing thread (statically, from thread-local storage).</div><div class="ttdef"><b>Definition</b> thread.cpp:51</div></div>
<div class="ttc" id="aimplementation_2thread_8h_html"><div class="ttname"><a href="implementation_2thread_8h.html">thread.h</a></div><div class="ttdoc">Defines the CThread class, a concrete implementation of the IThread interface. This class manages a s...</div></div>
<div class="ttc" id="anamespaceiridium_1_1threading_html_a77efc83dba79715684b3890184b31992"><div class="ttname"><a href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a></div><div class="ttdeci">void sleep(int const &amp;milliseconds)</div><div class="ttdoc">Pauses the execution of the current thread for a specified duration.</div><div class="ttdef"><b>Definition</b> thread.cpp:41</div></div>
<div class="ttc" id="arunnable_8h_html"><div class="ttname"><a href="runnable_8h.html">runnable.h</a></div></div>
<div class="ttc" id="athread_8h_html"><div class="ttname"><a href="thread_8h.html">thread.h</a></div><div class="ttdoc">Defines the IThread interface and related threading utility functions. This includes the core interfa...</div></div>
</div><!-- fragment --><p> In this example, <code>MyPeriodicTask::run</code> will execute in a new thread managed by <code><a class="el" href="class_c_thread.html" title="Concrete implementation of the IThread interface. Manages an actual std::thread to execute an IRunnab...">CThread</a></code>. <code><a class="el" href="class_c_thread.html#a39b985df9f70f9502198035353b1eedc" title="Initializes the thread, which includes starting the underlying std::thread and waiting for it to sign...">CThread::initialize()</a></code> starts it, and <code><a class="el" href="class_c_thread.html#a66a1d7c2cba19611a23b645843b61474" title="Finalizes the thread. Signals the IRunnable to stop, then joins the underlying std::thread....">CThread::finalize()</a></code> signals <code>is_running</code> to <code>false</code> and joins the thread.</p>
<h2><a class="anchor" id="subsec_synchronized"></a>
Using Synchronized for Data Protection</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">iridium::threading::Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</code> is a template class designed to protect shared data from concurrent access. It typically serves as a base class for classes that contain data needing protection. It uses a mutex (e.g., <code>std::mutex</code>) and a condition variable.</p>
<p><b>Key Mechanism: <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></code></b> The <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></code> macro is the primary way to interact with <code><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></code>. When placed inside a method of a class that inherits from <code><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></code>, it creates a scoped lock (an instance of <code><a class="el" href="class_synchronized_1_1_locker.html" title="A scoped locker class that acquires the Synchronized object&#39;s mutex on construction and releases it o...">Synchronized::Locker</a></code>). The mutex is acquired when <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....">LOCK_SCOPE()</a></code> is encountered and automatically released when the scope is exited (due to RAII).</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span>    <span class="comment">// For std::mutex</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span>   <span class="comment">// For std::chrono</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/threading/implementation/thread.h&quot; // For more complex demo with actual threads</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Class whose methods will be synchronized</span></div>
<div class="line"><span class="keyword">class </span>SafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; items_;</div>
<div class="line">    <span class="keywordtype">int</span> access_count_ = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addItem(<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Lock acquired for this scope</span></div>
<div class="line">        items_.push_back(item);</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItem: Added &#39;&quot; &lt;&lt; item &lt;&lt; &quot;&#39;. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// Mutex is automatically released here by _____locked_scope_____ destructor</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> addItems(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; items_to_add) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item_to_add : items_to_add) { <span class="comment">// Fixed variable name</span></div>
<div class="line">            items_.push_back(item_to_add);</div>
<div class="line">        }</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItems: Added multiple items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; getItems() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// Return by value ensures the copy is made while the lock is held.</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;getItems: Returning copy of items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">return</span> items_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getAccessCount() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">return</span> access_count_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> waitUntilItemCountReaches(<span class="keywordtype">size_t</span> target_count, std::chrono::milliseconds timeout) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Waiting for item count &quot; &lt;&lt; target_count &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">while</span> (items_.size() &lt; target_count) {</div>
<div class="line">            <span class="keywordflow">if</span> (!_____locked_scope_____.wait(timeout)) {</div>
<div class="line">                <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Wait timed out or was interrupted.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Woke up, current count &quot; &lt;&lt; items_.size() &lt;&lt; std::endl;</span></div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// if (items_.size() &gt;= target_count) {</span></div>
<div class="line">        <span class="comment">//     std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Target count reached.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> notifyDataAdded() {</div>
<div class="line">        <span class="comment">// The Synchronized::Locker&#39;s destructor calls notify_one automatically.</span></div>
<div class="line">        <span class="comment">// To explicitly notify (e.g. all), you would need access to the condition variable itself.</span></div>
<div class="line">        <span class="comment">// For this pattern, you&#39;d typically add data (which acquires and releases a lock),</span></div>
<div class="line">        <span class="comment">// and the lock release notifies one waiter.</span></div>
<div class="line">        <span class="comment">// If you need notify_all, it&#39;s not directly exposed via LOCK_SCOPE alone for this simple pattern.</span></div>
<div class="line">        <span class="comment">// The Synchronized class has m_cv.notify_all() in its interrupt() method.</span></div>
<div class="line">        <span class="comment">// This example relies on the implicit notify_one on Locker destruction.</span></div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Acquire lock to ensure data consistency before potential notification</span></div>
<div class="line">        <span class="comment">// (no data change here, but typically you would modify data before notify)</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;notifyDataAdded: Change occurred. Locker destruction will notify one waiter.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized() {</div>
<div class="line">    SafeDataContainer container;</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Apple&quot;</span>);</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; current_items = container.getItems();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : current_items) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Access count: &quot;</span> &lt;&lt; container.getAccessCount() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Conceptual: A thread might wait for a condition</span></div>
<div class="line">    <span class="comment">// std::thread waiter([&amp;](){</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: waiting for 3 items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.waitUntilItemCountReaches(3, std::chrono::seconds(2));</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: finished waiting. Items: &quot; &lt;&lt; container.getItems().size() &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// std::thread adder([&amp;](){</span></div>
<div class="line">    <span class="comment">//    iridium::threading::sleep(500);</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Adder thread: adding &#39;Cherry&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.addItem(&quot;Cherry&quot;); // This will notify one waiter via Locker destructor</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// adder.join();</span></div>
<div class="line">    <span class="comment">// waiter.join();</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_synchronized_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a></div><div class="ttdoc">A template class providing synchronization primitives (mutex and condition variable) to protect share...</div><div class="ttdef"><b>Definition</b> synchronized.h:56</div></div>
<div class="ttc" id="asynchronized_8h_html"><div class="ttname"><a href="synchronized_8h.html">synchronized.h</a></div><div class="ttdoc">Defines the Synchronized class template for creating synchronized blocks of code and related helper m...</div></div>
<div class="ttc" id="asynchronized_8h_html_aa07286a6c9966cc562c16a85887533fc"><div class="ttname"><a href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a></div><div class="ttdeci">#define LOCK_SCOPE()</div><div class="ttdoc">Creates a Synchronized::Locker instance named _____locked_scope_____ for the current scope....</div><div class="ttdef"><b>Definition</b> synchronized.h:239</div></div>
</div><!-- fragment --><p> The <code><a class="el" href="class_synchronized.html" title="A template class providing synchronization primitives (mutex and condition variable) to protect share...">Synchronized</a></code> class makes methods of <code>SafeDataContainer</code> thread-safe. The <code>Locker</code>'s destructor also calls <code>notify_one()</code> on an internal condition variable, which can be used with <code>Locker::wait()</code> methods.</p>
<h2><a class="anchor" id="subsec_cworker"></a>
Using CWorker for Task Processing</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html" title="Implements IWorker to process items from an input queue and place results in an output queue,...">iridium::threading::implementation::CWorker</a>&lt;TInputItem, TOutputItem&gt;</code> provides a single worker thread that processes items from an input queue and can place results in an output queue.</p>
<p><b><code><a class="el" href="class_i_worker_1_1_i_handler.html">IWorker::IHandler</a></code> Interface:</b> You define a handler class inheriting from <code><a class="el" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;TInputItem, TOutputItem&gt;::IHandler</code>. Its core method is:</p><ul>
<li><code>TOutputItems handle(const TInputItems&amp; items)</code>: Receives a list of items from the input queue and should return a list of output items.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworker.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2worker_8h.html">iridium/threading/implementation/worker.h</a>&quot;</span> <span class="comment">// For CWorker</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// For IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// For std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// For toupper</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// For std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Define the Handler</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandler : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Initializing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Finalizing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line"> </div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Handler: Received &quot; &lt;&lt; items.size() &lt;&lt; &quot; items to process.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); }); <span class="comment">// Ensure char cast</span></div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_worker&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworker() {</div>
<div class="line">    <span class="keyword">auto</span> handler = std::make_shared&lt;ToUpperStringHandler&gt;();</div>
<div class="line">    <span class="keyword">auto</span> worker = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyStringToUpperWorker&quot;</span>, handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &#39;alpha&#39; and &#39;beta&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;push(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">        worker-&gt;push(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;gamma&quot;</span>});</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker&lt;std::string, std::string&gt;::TOutputItems</a> processed_batch;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The CWorkerRunnable processes one item at a time from the input queue,</span></div>
<div class="line">        <span class="comment">// calls handler (which receives a list of 1 item),</span></div>
<div class="line">        <span class="comment">// and handler returns a list of output items.</span></div>
<div class="line">        <span class="comment">// So, each pop() call will retrieve the results from one handle() call.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;alpha&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;<a class="code hl_function" href="classiridium_1_1threading_1_1_i_async_queue_popper.html#a69e6f12074937e6f482f8e688df03d2e">pop</a>(<span class="keyword">true</span>); <span class="comment">// true means wait</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;beta&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Results for &quot;gamma&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: CWorker operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_async_queue_popper_html_a69e6f12074937e6f482f8e688df03d2e"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_async_queue_popper.html#a69e6f12074937e6f482f8e688df03d2e">iridium::threading::IAsyncQueuePopper::pop</a></div><div class="ttdeci">virtual TItems pop(bool const &amp;is_do_wait=true)=0</div><div class="ttdoc">Pops items from the queue. Retrieves one or more items from the front of the queue....</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a></div><div class="ttdef"><b>Definition</b> worker.h:59</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker</a></div><div class="ttdoc">Implements IWorker to process items from an input queue and place results in an output queue,...</div><div class="ttdef"><b>Definition</b> worker.h:165</div></div>
<div class="ttc" id="aimplementation_2worker_8h_html"><div class="ttname"><a href="implementation_2worker_8h.html">worker.h</a></div><div class="ttdoc">Defines worker class implementations (CWorkerPusher, CWorkerPopper, CWorker) that manage a thread to ...</div></div>
<div class="ttc" id="aworker_8h_html"><div class="ttname"><a href="worker_8h.html">worker.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_cworkerpool"></a>
Using CWorkerPool for Parallel Task Processing</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a>&lt;TInputItem, TOutputItem&gt;</code> manages a pool of multiple worker threads for parallel processing of items from a shared input queue to a shared output queue.</p>
<p><b>Key Aspects:</b></p><ul>
<li>Constructor takes a list of <code>IHandler</code> shared pointers (<code>THandlers</code>).</li>
<li>Items pushed are distributed among worker threads.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworkerpool.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker__pool_8h.html">iridium/threading/implementation/worker_pool.h</a>&quot;</span> <span class="comment">// For CWorkerPool</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// For IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// For std::make_shared</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// For std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// For toupper</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO </span><span class="comment">// Guard if included multiple times</span></div>
<div class="line"><span class="preprocessor">#define TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandlerForPool : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string handler_id_;</div>
<div class="line">    ToUpperStringHandlerForPool(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>) : handler_id_(id) {}</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Init&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Final&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Handling &quot; &lt;&lt; items.size() &lt;&lt; &quot; items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); });</div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_pool_&quot;</span> + handler_id_);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworkerpool() {</div>
<div class="line">    <span class="keywordtype">int</span> num_pool_threads = 2;</div>
<div class="line">    std::list&lt;iridium::threading::IWorker&lt;std::string, std::string&gt;::IHandler::TSharedPtr&gt; handlers_list;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_pool_threads; ++i) {</div>
<div class="line">        handlers_list.push_back(std::make_shared&lt;ToUpperStringHandlerForPool&gt;(<span class="stringliteral">&quot;H&quot;</span> + std::to_string(i)));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> pool = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyDemoPool&quot;</span>, handlers_list);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::string&gt; all_tasks = {<span class="stringliteral">&quot;task1&quot;</span>, <span class="stringliteral">&quot;task2&quot;</span>, <span class="stringliteral">&quot;task3&quot;</span>, <span class="stringliteral">&quot;task4&quot;</span>, <span class="stringliteral">&quot;task5&quot;</span>};</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &quot; &lt;&lt; all_tasks.size() &lt;&lt; &quot; tasks to the pool.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;push(all_tasks); <span class="comment">// Push a batch. These will be added to the shared input queue.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Collect results. Each worker thread processes one item from the input queue at a time,</span></div>
<div class="line">        <span class="comment">// its handler produces a list of output items, which are added to the pool&#39;s output queue.</span></div>
<div class="line">        <span class="comment">// So, we expect to pop &#39;all_tasks.size()&#39; lists of results.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; all_tasks.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> results_batch = pool-&gt;pop(<span class="keyword">true</span>); <span class="comment">// Wait for a batch of results from one handler call</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; res : results_batch) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Pool result: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker pool finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Worker Pool operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_pool_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a></div><div class="ttdef"><b>Definition</b> worker_pool.h:89</div></div>
<div class="ttc" id="aworker__pool_8h_html"><div class="ttname"><a href="worker__pool_8h.html">worker_pool.h</a></div></div>
</div><!-- fragment --><p> The <code><a class="el" href="class_c_worker_pool.html">CWorkerPool</a></code> is effective for parallelizing independent tasks. The order of results from <code>pop</code> may not strictly match the <code>push</code> order.</p>
<p>These primitives provide foundational tools for building concurrent and parallel applications with Iridium.</p>
<h1><a class="anchor" id="sec_testing"></a>
Testing with Iridium</h1>
<p>The Iridium library provides a built-in framework for writing and running unit tests, as well as for creating mock objects to isolate the code under test. This framework helps ensure the quality and reliability of code developed using Iridium.</p>
<h2><a class="anchor" id="subsec_testing_core_concepts"></a>
Core Concepts</h2>
<p>The foundation of the Iridium testing system consists of two key interfaces/classes:</p>
<ul>
<li><code><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Interface for a runnable test case. Concrete test classes should implement this interface to define a...">iridium::testing::ITest</a></code> (defined in <code><a class="el" href="test_8h.html">iridium/testing/test.h</a></code>): This is the base interface for any runnable test case. Each class representing a test must implement the <code>virtual void run() = 0;</code> method. This method contains the logic of the test itself, including calls to the code under test and assertion checks.</li>
<li><code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> (defined in <code><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></code>): This class serves as the base class for your tests (usually implicitly via the <code>TEST</code> macro). It provides a set of methods for performing various assertions, such as checking equality, comparisons, truthiness of conditions, or the throwing of expected exceptions. If an assertion fails, these methods generate a special exception that signals the test failure.</li>
</ul>
<h2><a class="anchor" id="subsec_testing_writing_tests"></a>
Writing Tests</h2>
<p>The primary tool for creating test cases in Iridium is the <code>TEST</code> macro.</p>
<h3><a class="anchor" id="subsubsec_testing_test_macro"></a>
The TEST Macro</h3>
<p>The <code><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST(TestCaseName)</a></code> macro (defined in <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>) is used to define a test case. <code>TestCaseName</code> must be a unique identifier for your test. This macro automatically creates a class that inherits from <code><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Interface for a runnable test case. Concrete test classes should implement this interface to define a...">iridium::testing::ITest</a></code> and <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code>, and registers it with the testing system. You only need to provide the body for the <code>run()</code> method, which will contain the test logic.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For TEST and ASSERT macro</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span>                   <span class="comment">// For std::string in example</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span>                <span class="comment">// For std::runtime_error in example</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// For iridium::convertion::convert (if custom types are needed in ASSERT)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example custom type to demonstrate output in ASSERT</span></div>
<div class="line"><span class="keyword">struct </span>MyCustomType {</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    std::string value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For comparison in tests</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyCustomType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> == other.id &amp;&amp; value == other.value;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specialization of convert for MyCustomType, so ASSERT can print it</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">std::string <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert</a>(MyCustomType <span class="keyword">const</span> &amp;obj) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyCustomType(id=&quot;</span> + <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(obj.id) + <span class="stringliteral">&quot;, value=\&quot;&quot;</span> + obj.value + <span class="stringliteral">&quot;\&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example class to be tested (replace with your own)</span></div>
<div class="line"><span class="keyword">class </span>MyClassToTest {</div>
<div class="line">    std::string param_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassToTest(<span class="keyword">const</span> std::string&amp; p = <span class="stringliteral">&quot;&quot;</span>) : param_(p) {}</div>
<div class="line">    std::string getParameter()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> param_; }</div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
<div class="line">    MyCustomType getCustomType(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; val) { <span class="keywordflow">return</span> {id, val}; }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatThrows() { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Expected exception&quot;</span>); }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatDoesNotThrow() { <span class="comment">/* No-op */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassConstruction) {</div>
<div class="line">    MyClassToTest obj(<span class="stringliteral">&quot;test_param&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getParameter(), equal, <span class="stringliteral">&quot;test_param&quot;</span>); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassAddsNumbers) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(2, 3), equal, 5);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), greaterEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), lessEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(5, 5), greater, 9);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), less, 3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyCustomTypeAssertion) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    MyCustomType expected = {1, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getCustomType(1, <span class="stringliteral">&quot;hello&quot;</span>), equal, expected);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(BooleanAssertions) {</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">true</span>); <span class="comment">// Check for truth</span></div>
<div class="line">    <span class="keywordtype">bool</span> my_flag = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(!my_flag); <span class="comment">// Check for falsehood via negation</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassThrowsException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.doSomethingThatThrows(), std::runtime_error);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassDoesNotThrowException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <span class="keywordtype">bool</span> did_not_throw = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        obj.doSomethingThatDoesNotThrow();</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        did_not_throw = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(did_not_throw);</div>
<div class="line">}</div>
<div class="ttc" id="atester_8h_html"><div class="ttname"><a href="tester_8h.html">tester.h</a></div></div>
<div class="ttc" id="atester_8h_html_a45feb1f37ce559e49baf8655d769ef85"><div class="ttname"><a href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a></div><div class="ttdeci">#define TEST(name)</div><div class="ttdoc">Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...</div><div class="ttdef"><b>Definition</b> tester.h:153</div></div>
<div class="ttc" id="atester_8h_html_a821326052e3e2bf1fb2d678e9e9a6004"><div class="ttname"><a href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a></div><div class="ttdeci">#define ASSERT(...)</div><div class="ttdoc">Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...</div><div class="ttdef"><b>Definition</b> tester.h:218</div></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_testing_assertions"></a>
The ASSERT Macro</h3>
<p>The <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> class (from which tests created by the <code>TEST</code> macro implicitly inherit) provides various methods for checking conditions. The primary way to use them in tests is the <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(...)</a></code> macro (defined in <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>). If an assertion fails, an exception is thrown, and the test is marked as failed.</p>
<p>The <code>ASSERT</code> macro is variadic (accepts a variable number of arguments) and is used as follows:</p>
<ol type="1">
<li><b>Checking a boolean condition: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(condition)</a></code></b><ul>
<li>Used to check for truth (<code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(true_condition)</a>;</code>) or falsehood (<code>ASSERT(!false_condition);</code>).</li>
<li>Technically, this is a call to <code>ASSERT_1</code>, which passes <code>condition</code> to the <code>UnitTest::assert_()</code> method.</li>
<li>Example: <code>ASSERT(x &gt; 5);</code></li>
</ul>
</li>
<li><b>Checking for comparison: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, comparison_symbol, value2)</a></code></b><ul>
<li>Used for various types of comparisons. <code>comparison_symbol</code> is the name of a comparison method from the <code>UnitTest</code> class. <code>value1</code> represents the expected value, and <code>value2</code> the actual (received) value.</li>
<li>When performing a comparison (<code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, comparison_symbol, value2)</a></code>), the expected value (<code>value1</code>) is converted to the type of the actual value (<code>value2</code>). For instance, in the template methods of <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> (see <code><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></code>), a construct like <code>TRight left_(left);</code> or <code>static_cast&lt;TRight&gt;(left)</code> is used, where <code>left</code> is <code>value1</code> (expected), and <code>TRight</code> is the type of <code>value2</code> (actual). Thus, the actual comparison (<code>left_ == right</code>, <code>left_ &lt; right</code>, etc.) occurs between values of the same typethe type <code>TRight</code>. For converting values to strings for display in error messages, <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a></code> is used.</li>
<li>Technically, this is a call to <code>ASSERT_3</code>, which calls <code>UnitTest::comparison_symbol(value1, value2, "value1 symbol value2", "file:line")</code>.</li>
<li>Available <code>comparison_symbol</code>s:<ul>
<li><code>equal</code>: Checks that <code>value1 == value2</code>.</li>
<li><code>less</code>: Checks that <code>value1 &lt; value2</code>.</li>
<li><code>lessEqual</code>: Checks that <code>value1 &lt;= value2</code>.</li>
<li><code>greater</code>: Checks that <code>value1 &gt; value2</code>.</li>
<li><code>greaterEqual</code>: Checks that <code>value1 &gt;= value2</code>.</li>
</ul>
</li>
<li>Examples: <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(sum, equal, 10);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(count, less, max_count);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(actual_value, greaterEqual, expected_minimum);</div>
</div><!-- fragment --></li>
<li>Note: Although you can also write <code>ASSERT(value1 == value2);</code> (using <code>ASSERT_1</code>), using <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(value1, equal, value2)</a>;</code> is preferable for comparisons, as it allows the framework to potentially output the values of <code>value1</code> and <code>value2</code> more informatively upon failure.</li>
</ul>
</li>
<li><b>Checking for exception throwing: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(expression, ExpectedExceptionType)</a></code></b><ul>
<li>Technically, this is a call to <code>ASSERT_2</code>, which passes a lambda function with <code>expression</code> and <code>ExpectedExceptionType</code> to the <code>UnitTest::assert_&lt;TFunction, TException&gt;()</code> method.</li>
<li>Checks that executing <code>expression</code> results in an exception of type <code>ExpectedExceptionType</code> (or its descendant) being thrown.</li>
<li>Example: <code>ASSERT(myObject.methodThatThrows(), std::runtime_error);</code></li>
</ul>
</li>
<li><b>Unconditional test failure:</b><ul>
<li>There is no direct <code>FAIL(message)</code> macro. To unconditionally fail a test, use <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Chooser macro that dispatches to ASSERT_1, ASSERT_2, or ASSERT_3 based on the number of arguments pro...">ASSERT(false)</a>;</code>. You can add a comment to explain the reason. <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">false</span>); <span class="comment">// Test failed because condition X was not met</span></div>
</div><!-- fragment --></li>
</ul>
</li>
</ol>
<p><b>Outputting values on errors and <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a></code>:</b> A very important feature of the <code>ASSERT</code> macro (especially for comparisons) is how it displays values when an assertion fails. To output <code>value1</code> and <code>value2</code> (or the value from <code>condition</code> for <code>ASSERT_1</code>) in a readable format, the testing system uses <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a>&lt;std::string&gt;(your_value)</code>. If you use custom types in <code>ASSERT</code>, ensure that a specialization of <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Provides access to the core conversion function template from the implementation namespace....">iridium::convertion::convert</a></code> to <code>std::string</code> exists for them. Otherwise, you might see uninformative output (e.g., just the type name or address). For more details on creating <code>convert</code> specializations, see section <a class="el" href="#sec_custom_type_conversion">Integrating Custom Types with <code>iridium::convertion::convert</code></a>.</p>
<p>The <code>ASSERT</code> macro automatically includes the file name and line number in the error information, which helps to quickly locate the point of test failure.</p>
<h2><a class="anchor" id="subsec_testing_running_tests"></a>
Running Tests</h2>
<p>After writing tests, they need to be compiled and run. The Iridium framework simplifies this process.</p>
<h3><a class="anchor" id="subsubsec_testing_main"></a>
The IMPLEMENT_TEST_MAIN Macro</h3>
<p>To create an executable file that will run all defined tests, the <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></code> macro (defined in <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>) is used. This macro generates a standard <code>main()</code> function that initializes and runs the testing framework.</p>
<p>Typically, you create a separate <code>.cpp</code> file (e.g., <code>tests_main.cpp</code>) that includes all your test files (or headers, if tests are defined in them) and then calls <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></code>.</p>
<p>Example (<code>tests_main.cpp</code>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For IMPLEMENT_TEST_MAIN</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include your test files here or files where TEST(...) tests are defined</span></div>
<div class="line"><span class="comment">// For example:</span></div>
<div class="line"><span class="comment">// #include &quot;my_class_tests.cpp&quot; </span></div>
<div class="line"><span class="comment">// #include &quot;another_module_tests.cpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a>()</div>
<div class="ttc" id="atester_8h_html_ae18dbf9ed64402b9c94239f90547eceb"><div class="ttname"><a href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a></div><div class="ttdeci">#define IMPLEMENT_TEST_MAIN()</div><div class="ttdoc">Generates a main() function for a test executable. This main function initializes the Tester singleto...</div><div class="ttdef"><b>Definition</b> tester.h:230</div></div>
</div><!-- fragment --><p> When you compile this file along with your tests and the Iridium library, you will get an executable file that, when run, will execute all detected tests.</p>
<h3><a class="anchor" id="subsubsec_testing_tester"></a>
Role of the Tester Class</h3>
<p>The <code><a class="el" href="classiridium_1_1testing_1_1_tester.html" title="Singleton class responsible for registering, managing, and running all tests within the framework....">iridium::testing::Tester</a></code> class (defined in <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>) is the central component of the testing system. It is a singleton that:</p><ul>
<li>Registers all test cases defined using the <code>TEST</code> macro.</li>
<li>Manages the execution of tests. The <code>Tester::run(argc, argv, main_cpp_path)</code> method is called from the generated <code>main()</code> function.</li>
<li>Allows filtering of tests based on command-line arguments (this functionality may not be fully detailed here, but <code>Tester</code> provides for it).</li>
<li>Collects test results.</li>
</ul>
<h3><a class="anchor" id="subsubsec_testing_itestrunner"></a>
The ITestRunner Interface (for advanced scenarios)</h3>
<p>For more flexible control over the test execution process, there is the <code><a class="el" href="classiridium_1_1testing_1_1_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">iridium::testing::ITestRunner</a></code> interface (defined in <code><a class="el" href="test__runner_8h.html">iridium/testing/test_runner.h</a></code>). This interface abstracts the way tests are run. The Iridium library provides at least two implementations of it:</p><ul>
<li><code>iridium::testing::implementation::TestRunnerRaw</code>: Runs tests in the same process.</li>
<li><code>iridium::testing::implementation::TestRunnerFork</code>: Can run tests in separate processes (forks), which provides better isolation (typically on POSIX systems).</li>
</ul>
<p>Although direct interaction with <code><a class="el" href="class_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">ITestRunner</a></code> is usually not required for writing and running tests, knowing about its existence is useful for understanding the framework's architecture and for possible extensions or customization of the testing process. The <code>Tester</code> class uses an <code><a class="el" href="class_i_test_runner.html" title="Represents the overall result of a test execution run. This structure is typically serialized to/from...">ITestRunner</a></code> implementation to actually execute the tests.</p>
<h3><a class="anchor" id="subsubsec_testing_cli"></a>
Command-Line Arguments</h3>
<p>The test executable created with <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Generates a main() function for a test executable. This main function initializes the Tester singleto...">IMPLEMENT_TEST_MAIN()</a></code> supports the following command-line arguments to control the testing process. Assume your test application is named <code>your_test_app</code>.</p>
<ol type="1">
<li><b><code>help</code></b>: Displays help information on usage. <div class="fragment"><div class="line">./your_test_app help</div>
</div><!-- fragment --> Example output: <div class="fragment"><div class="line">main thread: 281473424756000</div>
<div class="line">2025-06-06 10:30:56.839 I 281473424756000 </div>
<div class="line">usage:</div>
<div class="line">./your_test_app help</div>
<div class="line">./your_test_app list</div>
<div class="line">./your_test_app run [ --mode=raw|serial|parallel ] [ --print-result=json ] [ --timeout=seconds ] [ include_path ] [ exclude_path ] ... [ exclude_path ]</div>
<div class="line">example:</div>
<div class="line">./your_test_app run / </div>
</div><!-- fragment --> (Note: The actual thread number and timestamp in your output will differ.)</li>
<li><b><code>list</code></b>: Displays a hierarchical list (tree) of all test cases discovered by the framework. Tests are grouped by file path and then by the test name defined in the <code><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Defines a test case and registers it with the Tester singleton. This macro generates a unique class n...">TEST()</a></code> macro. <div class="fragment"><div class="line">./your_test_app list</div>
</div><!-- fragment --> This is useful for viewing the structure of tests and their full paths, which can be used as <code>include_path</code> or <code>exclude_path</code> for the <code>run</code> command. Example output: <div class="fragment"><div class="line">main thread: 281473794346272</div>
<div class="line">2025-06-06 10:30:22.166 I 281473794346272 </div>
<div class="line"><span class="stringliteral">&#39;root&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;convertion&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;convert.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;enum_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;strings&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;types&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;testing&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;example.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;bool_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;comparing_equal&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;mock&#39;</span></div>
<div class="line"><span class="preprocessor">  # ... (and so on for other modules and tests)</span></div>
</div><!-- fragment --> (Note: The actual thread number, timestamp, and full list of tests in your output will differ.)</li>
<li><p class="startli"><b><code>run</code></b>: Runs the tests. This is the default command if no other is specified. </p><div class="fragment"><div class="line">./your_test_app run [options] [include_path] [exclude_path_1] [exclude_path_2] ...</div>
</div><!-- fragment --><p> Standard output when running tests (without <code>--print-result=json</code>) includes logging for each test being run and its result: </p><div class="fragment"><div class="line">main thread: 281473243745568</div>
<div class="line">2025-06-06 10:30:39.744 I 281473243745568 RUN  /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 RUN  /testing/example.cpp/comparing_equal</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/comparing_equal</div>
<div class="line"><span class="preprocessor"># ... (and so on for other tests)</span></div>
<div class="line"><span class="preprocessor"># ... (in case of failure, FAILED will appear instead of OK, along with an error message)</span></div>
<div class="line">2025-06-06 10:30:39.747 I 281473243745568 </div>
<div class="line">passed: 8</div>
<div class="line">failed: 0</div>
<div class="line">total:  51 </div>
</div><!-- fragment --><p> (Note: Actual thread numbers, timestamps, and results in your output will differ.)</p>
<p class="startli">Available options for the <code>run</code> command:</p><ul>
<li><code>--mode=MODE</code>: Defines the test execution mode. Possible values for <code>MODE</code>:<ul>
<li><code>raw</code> (default): Tests are run in the same process.</li>
<li><code>serial</code>: Tests are run sequentially, each in a separate process.</li>
<li><code>parallel</code>: Tests are run in parallel in separate processes.</li>
</ul>
</li>
<li><code>--print-result=FORMAT</code>: Controls the output format of results.<ul>
<li>If not specified, the standard text format is used (see example above).</li>
<li><code>json</code>: Results are output in JSON format.</li>
</ul>
</li>
<li><code>--timeout=SECONDS</code>: Sets the maximum timeout for tests in seconds (default is 60).</li>
</ul>
<p class="startli">Parameters for the <code>run</code> command:</p><ul>
<li><code>include_path</code> (optional): If specified, only tests whose path (as in the <code>list</code> output) starts with <code>include_path</code> are run. Defaults to <code>/</code> (all tests).</li>
<li><code>exclude_path_...</code> (optional): One or more paths to exclude. Tests whose path starts with one of these paths will not be run.</li>
</ul>
</li>
</ol>
<p>Examples of using the <code>run</code> command:</p>
<ul>
<li>Run all tests: <div class="fragment"><div class="line">./your_test_app run</div>
</div><!-- fragment --> (or just <code>./your_test_app</code>)</li>
<li>Run all tests in parallel mode with a timeout of 120 seconds: <div class="fragment"><div class="line">./your_test_app run --mode=parallel --timeout=120</div>
</div><!-- fragment --></li>
<li>Run only tests from the <code>testing</code> module and <code>example.cpp</code> file: <div class="fragment"><div class="line">./your_test_app run /testing/example.cpp/</div>
</div><!-- fragment --></li>
<li>Run all tests from the <code>parsing</code> module, but exclude those in <code>node.cpp</code> within <code>parsing</code>: <div class="fragment"><div class="line">./your_test_app run /parsing/ /parsing/node.cpp/</div>
</div><!-- fragment --></li>
<li>Run all tests and output the result in JSON format: <div class="fragment"><div class="line">./your_test_app run --print-result=json</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="subsec_testing_mocking"></a>
Mocking Dependencies</h2>
<p>Mocking is the process of creating substitute objects (mocks or mock objects) to simulate the behavior of real dependencies of the component under test. This allows isolating the code under test and making tests more predictable and stable. The Iridium testing framework provides tools for creating mocks (defined in <code><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></code>).</p>
<h3><a class="anchor" id="subsubsec_testing_defining_mocks"></a>
Defining Mock Classes</h3>
<p>To create a mock for an interface or class, the <code><a class="el" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee" title="Defines a mock class named Interface##Mock that inherits from Interface and iridium::testing::Mock&lt;In...">DEFINE_MOCK_CLASS(InterfaceName)</a></code> macro is used. This macro creates a new class named <code>InterfaceNameMock</code> that inherits your <code>InterfaceName</code> and <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Base class for creating mock objects. To create a mock for an interface or class TClass,...">iridium::testing::Mock</a>&lt;InterfaceName&gt;</code>.</p>
<p>Inside this mock class, you declare which methods of the interface you want to mock using the <code>DEFINE_MOCK_METHOD</code> (for non-const methods) and <code>DEFINE_MOCK_METHOD_CONST</code> (for const methods) macros.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume this is the interface we want to mock</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="comment">// Constructor with arguments to demonstrate DEFINE_MOCK_CONSTRUCTOR</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; <span class="comment">// Add a default constructor if it&#39;s also needed</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the mock class for IMyDependency</span></div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// If the base class IMyDependency has a constructor with arguments</span></div>
<div class="line">    <span class="comment">// and you want to call it from the mock:</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Mocking interface methods</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>))                  <span class="comment">// int getValue(int key)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)                <span class="comment">// std::string getName() const</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;) <span class="comment">// void processData(const std::vector&lt;int&gt;&amp; data)</span></div>
<div class="line">};</div>
<div class="ttc" id="amock_8h_html"><div class="ttname"><a href="mock_8h.html">mock.h</a></div></div>
<div class="ttc" id="amock_8h_html_a1aa823f3557d4e07d5a6cce9bb497aee"><div class="ttname"><a href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a></div><div class="ttdeci">#define DEFINE_MOCK_CLASS(Interface)</div><div class="ttdoc">Defines a mock class named Interface##Mock that inherits from Interface and iridium::testing::Mock&lt;In...</div><div class="ttdef"><b>Definition</b> mock.h:760</div></div>
<div class="ttc" id="amock_8h_html_a45da68ed3f119848c88d8ef01622bcec"><div class="ttname"><a href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD(...)</div><div class="ttdoc">Chooser macro for defining non-const mock method overrides, dispatching to DEFINE_MOCK_METHOD_N based...</div><div class="ttdef"><b>Definition</b> mock.h:682</div></div>
<div class="ttc" id="amock_8h_html_a4d8f3f37a1da67b31d455e5086be40f3"><div class="ttname"><a href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a></div><div class="ttdeci">#define DEFINE_MOCK_CONSTRUCTOR(Interface)</div><div class="ttdoc">Defines a constructor for a mock class (Interface##Mock) that forwards its arguments to the construct...</div><div class="ttdef"><b>Definition</b> mock.h:769</div></div>
<div class="ttc" id="amock_8h_html_ae47eed5af62161b8cb04261fded66530"><div class="ttname"><a href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD_CONST(...)</div><div class="ttdoc">Chooser macro for defining const mock method overrides, dispatching to DEFINE_MOCK_METHOD_CONST_N bas...</div><div class="ttdef"><b>Definition</b> mock.h:751</div></div>
</div><!-- fragment --><p> The <code>DEFINE_MOCK_METHOD</code> macros take the return type, method name, and in parentheses, the types of the method's arguments (without variable names).</p>
<h3><a class="anchor" id="subsubsec_testing_mock_behavior"></a>
Defining Mock Behavior</h3>
<p>After creating an instance of a mock object, you can define its behavior using the <code>DEFINE_MOCK_BEHAVIOR</code> (for non-const methods) or <code>DEFINE_MOCK_BEHAVIOR_CONST</code> (for const methods) macro. This macro allows you to assign a lambda function that will be called when the mocked method is accessed.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// For ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span>   <span class="comment">// For mocking macros</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// For std::runtime_error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For completeness, copy IMyDependency and IMyDependencyMock definitions here</span></div>
<div class="line"><span class="comment">// In real code, they would be in header files</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;)</div>
<div class="line">};</div>
<div class="line"><span class="comment">// End of copied definitions</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Class that uses IMyDependency</span></div>
<div class="line"><span class="keyword">class </span>MyClassUsesDependency {</div>
<div class="line">    IMyDependency* dependency_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassUsesDependency(IMyDependency* dep) : dependency_(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> fetchValue(<span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Key cannot be negative&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getValue(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string getDepName()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getName();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> sendData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) {</div>
<div class="line">        dependency_-&gt;processData(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassUsesDependency_Behavior) {</div>
<div class="line">    IMyDependencyMock mockDep; <span class="comment">// Create a mock instance</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define behavior for getValue</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, <span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="comment">// This is a lambda function: [=](int key_param) -&gt; int { ... }</span></div>
<div class="line">        <span class="comment">// Parameter names in the lambda can be anything, but types must match those declared in DEFINE_MOCK_METHOD</span></div>
<div class="line">        <span class="keywordflow">if</span> (key == 1) <span class="keywordflow">return</span> 100;</div>
<div class="line">        <span class="keywordflow">if</span> (key == 42) <span class="keywordflow">return</span> 420;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define behavior for getName (const method)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a>(std::string, getName, mockDep) {</div>
<div class="line">        <span class="comment">// Lambda for a method with no arguments: [=]() -&gt; std::string { ... }</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;MockedName&quot;</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Define behavior for processData (void method)</span></div>
<div class="line">    std::vector&lt;int&gt; received_data;</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;data) {</div>
<div class="line">        <span class="comment">// Lambda for a void method: [=](const std::vector&lt;int&gt;&amp; data_param) -&gt; void { ... }</span></div>
<div class="line">        received_data = data; <span class="comment">// Copy data for verification</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClassUsesDependency mainObj(&amp;mockDep);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(1),   equal, 100);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(42),  equal, 420);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(10),  equal, -1);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.getDepName(),    equal, <span class="stringliteral">&quot;MockedName&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int&gt; data_to_send = {1, 2, 3};</div>
<div class="line">    mainObj.sendData(data_to_send);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data.size(),    equal, 3);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data[0],        equal, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check exception throwing from the main class, not the mock</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(-1), std::runtime_error);</div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_a8178900fca49688815d093d8c46b1c15"><div class="ttname"><a href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR_CONST(result_type, method_name, mock_object,...)</div><div class="ttdoc">Sets the behavior for a const mocked method. Similar to DEFINE_MOCK_BEHAVIOR but for const member fun...</div><div class="ttdef"><b>Definition</b> mock.h:814</div></div>
<div class="ttc" id="amock_8h_html_aed1edc22e98dd2dc94c0368764223576"><div class="ttname"><a href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR(result_type, method_name, mock_object,...)</div><div class="ttdoc">Sets the behavior for a non-const mocked method. This macro is used to specify what a mocked method s...</div><div class="ttdef"><b>Definition</b> mock.h:790</div></div>
</div><!-- fragment --><p> In the lambda function defining the behavior, you can access the arguments with which the mocked method was called and return an appropriate value or perform necessary actions. The argument types in the lambda must match the types specified in <code>DEFINE_MOCK_METHOD</code>.</p>
<p>Using <code>DEFINE_MOCK_CONSTRUCTOR</code> is necessary if your original interface/class has constructors with parameters that you want to call when creating the mock object (e.g., if the mock inherits from a class rather than a pure interface, and the base class constructor needs to be called).</p>
<h3><a class="anchor" id="subsubsec_testing_mock_auto_creation"></a>
Automatic Mock Object Creation and Provisioning via <code>create()</code></h3>
<p>The Iridium framework provides a mechanism that allows static <code>create()</code> methods to return mock objects instead of real ones during testing. This is particularly useful when the class under test creates its dependencies internally. Understanding this mechanism requires looking at several macros and user conventions.</p>
<p><b>Key Macros and Their Interaction:</b></p>
<ol type="1">
<li><b><code>DEFINE_MOCK_CREATE</code> (Preprocessor Symbol):</b><ul>
<li>This is a <b>preprocessor symbol</b> that users should define for their test builds. This can be done, for example, by adding <code>#define DEFINE_MOCK_CREATE</code> at the top of a test file (before including Iridium headers like <code><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></code>) or via a compiler option (e.g., <code>-DDEFINE_MOCK_CREATE</code>).</li>
<li>The Iridium macro <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class TClass. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></code> (located in <code><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></code>) uses the preprocessor directive <code>#ifdef DEFINE_MOCK_CREATE</code> to conditionally compile the static <code>TClass::create(...)</code> method.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class TClass. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></code> (Iridium Macro from <code><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>This macro generates the static <code>TClass::create(...)</code> method.</li>
<li>Due to the <code>#ifdef DEFINE_MOCK_CREATE</code> check within <code>DEFINE_CREATE</code>:<ul>
<li>If <code>DEFINE_MOCK_CREATE</code> is defined when <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class TClass. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></code> is processed, the resulting <code>TClass::create(...)</code> method will call <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Base class for creating mock objects. To create a mock for an interface or class TClass,...">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</code>.</li>
<li>If <code>DEFINE_MOCK_CREATE</code> is <em>not</em> defined, then <code>TClass::create(...)</code> will call <code>std::make_shared&lt;TClass&gt;(...)</code> to create a real object.</li>
</ul>
</li>
</ul>
</li>
<li><b><code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Base class for creating mock objects. To create a mock for an interface or class TClass,...">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</code> (from <code><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></code>):</b><ul>
<li>This method is called when <code>TClass::create(...)</code> has been generated in "mock mode" (due to <code>DEFINE_MOCK_CREATE</code>).</li>
<li>It checks an internal static flag, <code>Mock&lt;TClass&gt;::m_is_mocked</code>.</li>
<li>If <code>m_is_mocked == true</code> (this flag is set when an instance of a mock class, e.g., <code>TClassMock</code>, is created), then <code>Mock&lt;TClass&gt;::create(...)</code> attempts to return a previously registered instance of <code>TClassMock</code>. If no suitable mocks are available, an exception is thrown.</li>
<li>If <code>m_is_mocked == false</code>, then <code>Mock&lt;TClass&gt;::create(...)</code> attempts to create a real object via <code>std::make_shared&lt;TClass&gt;(...)</code>. <b>Important:</b> If <code>TClass</code> is an abstract interface, this attempt will result in a compile-time error.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...">DEFINE_IMPLEMENTATION(TClass)</a></code> (from <code><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>This Iridium macro is used for concrete classes. It internally calls <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Defines a static create factory method for a class TClass. If DEFINE_MOCK_CREATE is not defined,...">DEFINE_CREATE(TClass)</a></code>.</li>
<li>Consequently, the static <code>create()</code> method for classes defined with <code>DEFINE_IMPLEMENTATION</code> will automatically support switching between real and mock creation based on the presence of <code>DEFINE_MOCK_CREATE</code>.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...">DEFINE_INTERFACE(Interface)</a></code> (from <code><a class="el" href="smart__ptr_8h.html" title="Provides helper macros for defining standard smart pointer typedefs and static create factory methods...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>This Iridium macro is used for defining interfaces. It defines typedefs for smart pointers and a virtual destructor.</li>
<li><b>Important:</b> <code>DEFINE_INTERFACE</code> does <b>not</b> use <code>DEFINE_CREATE</code>. Thus, interfaces defined solely with <code>DEFINE_INTERFACE</code> do not automatically get a static <code>create()</code> method that is managed by <code>DEFINE_MOCK_CREATE</code>.</li>
</ul>
</li>
</ol>
<p><b>Usage Scenarios:</b></p>
<ul>
<li><b>Mocking a Concrete Class:</b> If you have a concrete class <code>CMyImpl</code> defined with <code><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...">DEFINE_IMPLEMENTATION(CMyImpl)</a></code>, and you define <code>DEFINE_MOCK_CREATE</code> in your test setup, then calls to <code>CMyImpl::create(...)</code> will automatically be routed to <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Base class for creating mock objects. To create a mock for an interface or class TClass,...">iridium::testing::Mock</a>&lt;CMyImpl&gt;::create(...)</code>. If you've instantiated a <code>CMyImplMock</code>, it will then be provided.</li>
<li><b>Mocking via an Interface:</b> If you want <code>IMyInterface::create(...)</code> to return a mock, and <code>IMyInterface</code> is defined only with <code>DEFINE_INTERFACE</code>, you must <b>manually implement</b> the static <code>IMyInterface::create(...)</code> method. In your implementation, you can use <code>DEFINE_MOCK_CREATE</code> (or another flag of your choosing) to decide whether to call <code>std::make_shared&lt;CMyRealImpl&gt;(...)</code> or <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Base class for creating mock objects. To create a mock for an interface or class TClass,...">iridium::testing::Mock</a>&lt;IMyInterface&gt;::create(...)</code>.</li>
</ul>
<p><b>Example (Mocking a concrete implementation, similar to <code>iridium-test/testing/example.cpp</code>):</b></p>
<div class="fragment"><div class="line"><span class="comment">// --- Start of Code Example ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include Iridium headers. Order can be important if DEFINE_MOCK_CREATE affects them.</span></div>
<div class="line"><span class="comment">// DEFINE_MOCK_CREATE should be defined before smart_ptr.h, where DEFINE_CREATE resides.</span></div>
<div class="line"><span class="comment">// For this example, we&#39;ll place DEFINE_MOCK_CREATE directly in the &quot;test file&quot;.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: IDataService.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// For DEFINE_INTERFACE</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IDataService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a>(IDataService); <span class="comment">// Does not create IDataService::create()</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: CDataServiceImpl.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;IDataService.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// For DEFINE_IMPLEMENTATION</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CDataServiceImpl : <span class="keyword">public</span> IDataService {</div>
<div class="line">    std::string m_serviceName;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor for the real implementation</span></div>
<div class="line">    CDataServiceImpl(<span class="keyword">const</span> std::string&amp; name) : m_serviceName(name) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// DEFINE_IMPLEMENTATION includes DEFINE_CREATE, which will respect DEFINE_MOCK_CREATE</span></div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a>(CDataServiceImpl);</div>
<div class="line"> </div>
<div class="line">    std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Real data for id &quot;</span> + std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot; from &quot;</span> + m_serviceName;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: CDataServiceImplMock.h (or directly in the test .cpp)</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// We are mocking the concrete class</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(CDataServiceImpl) { <span class="comment">// Creates CDataServiceImplMock</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Since CDataServiceImpl has a constructor with parameters,</span></div>
<div class="line">    <span class="comment">// the mock must call it via DEFINE_MOCK_CONSTRUCTOR.</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(CDataServiceImpl)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(std::string, fetchData, <span class="keywordtype">int</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: DataConsumer.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Depends on the concrete implementation to call CDataServiceImpl::create()</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataConsumer {</div>
<div class="line">    std::shared_ptr&lt;CDataServiceImpl&gt; m_dataService; <span class="comment">// Uses the concrete class</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataConsumer() {</div>
<div class="line">        <span class="comment">// Call CDataServiceImpl::create(), which will be governed by DEFINE_MOCK_CREATE</span></div>
<div class="line">        m_dataService = CDataServiceImpl::create(<span class="stringliteral">&quot;MyRealService&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string processData(<span class="keywordtype">int</span> recordId) {</div>
<div class="line">        <span class="keywordflow">if</span> (!m_dataService) <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error: Service not created&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Consumed: &quot;</span> + m_dataService-&gt;fetchData(recordId);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: test_main.cpp (or your test file)</span></div>
<div class="line"><span class="comment">// THIS IS KEY: DEFINE_MOCK_CREATE should be defined BEFORE including</span></div>
<div class="line"><span class="comment">// iridium/smart_ptr.h if it&#39;s to affect DEFINE_CREATE within it.</span></div>
<div class="line"><span class="comment">// For simplicity here, we assume CDataServiceImpl.h (which pulls in smart_ptr.h)</span></div>
<div class="line"><span class="comment">// will be processed by the compiler after this define.</span></div>
<div class="line"><span class="preprocessor">#define DEFINE_MOCK_CREATE</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;DataConsumer.h&quot;       // Conceptually included above</span></div>
<div class="line"><span class="comment">// #include &quot;CDataServiceImplMock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(DataConsumer_UsesMockService) {</div>
<div class="line">    <span class="comment">// 1. Create an instance of the CDataServiceImplMock mock.</span></div>
<div class="line">    <span class="comment">//    This action sets Mock&lt;CDataServiceImpl&gt;::m_is_mocked = true;</span></div>
<div class="line">    <span class="comment">//    and registers this mockService in the list of available mocks.</span></div>
<div class="line">    <span class="comment">//    Pass constructor arguments as for the real CDataServiceImpl.</span></div>
<div class="line">    CDataServiceImplMock mockService(<span class="stringliteral">&quot;MockedServiceInstance&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Define behavior for the fetchData mock method</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(std::string, fetchData, mockService, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 101) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;mocked_payload_for_101&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;generic_mock_payload&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create DataConsumer. Its constructor will call CDataServiceImpl::create(&quot;MyRealService&quot;).</span></div>
<div class="line">    <span class="comment">//    Because DEFINE_MOCK_CREATE is active, CDataServiceImpl::create() was generated</span></div>
<div class="line">    <span class="comment">//    to call iridium::testing::Mock&lt;CDataServiceImpl&gt;::create(...).</span></div>
<div class="line">    <span class="comment">//    Since mockService (of type CDataServiceImplMock) was created and registered,</span></div>
<div class="line">    <span class="comment">//    it will be returned. (The &quot;MyRealService&quot; argument would be used by the mock&#39;s constructor</span></div>
<div class="line">    <span class="comment">//    if it accepts it, or ignored if Mock&lt;T&gt;::create decides so for mocks).</span></div>
<div class="line">    DataConsumer consumer;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Verify that DataConsumer received and uses the mocked data</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(101), equal, <span class="stringliteral">&quot;Consumed: mocked_payload_for_101&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(200), equal, <span class="stringliteral">&quot;Consumed: generic_mock_payload&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// --- End of Code Example ---</span></div>
<div class="ttc" id="asmart__ptr_8h_html"><div class="ttname"><a href="smart__ptr_8h.html">smart_ptr.h</a></div><div class="ttdoc">Provides helper macros for defining standard smart pointer typedefs and static create factory methods...</div></div>
<div class="ttc" id="asmart__ptr_8h_html_a5314379c214998b38c9b5d50b1e1ac9d"><div class="ttname"><a href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a></div><div class="ttdeci">#define DEFINE_INTERFACE(TClass)</div><div class="ttdoc">A convenience macro for defining interfaces. It combines DEFINE_SMART_PTR(TClass) to declare standard...</div><div class="ttdef"><b>Definition</b> smart_ptr.h:96</div></div>
<div class="ttc" id="asmart__ptr_8h_html_ad4d8992039d0faf9ae66c4f596277280"><div class="ttname"><a href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a></div><div class="ttdeci">#define DEFINE_IMPLEMENTATION(TClass)</div><div class="ttdoc">A convenience macro for defining implementation classes. It combines DEFINE_CREATE(TClass) to declare...</div><div class="ttdef"><b>Definition</b> smart_ptr.h:110</div></div>
</div><!-- fragment --><p><b>Summary for Interfaces:</b></p>
<p>If you want to get a mock for an interface <code>IExample</code> via a call to <code>IExample::create()</code>, then, because <code>DEFINE_INTERFACE</code> does not provide <code>create()</code>, you must write this method yourself. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// In IExample.h or IExample.cpp</span></div>
<div class="line"><span class="comment">// #include &quot;CRealExampleImpl.h&quot; // Your real implementation</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/testing/mock.h&quot; // For Mock&lt;IExample&gt;::create()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::shared_ptr&lt;IExample&gt; IExample::create() { // Assuming you declared static create() in IExample</span></div>
<div class="line"><span class="comment">// #ifdef USER_TEST_FLAG_FOR_IEXAMPLE_MOCK // User-defined flag</span></div>
<div class="line"><span class="comment">//     return iridium::testing::Mock&lt;IExample&gt;::create();</span></div>
<div class="line"><span class="comment">// #else</span></div>
<div class="line"><span class="comment">//     return std::make_shared&lt;CRealExampleImpl&gt;();</span></div>
<div class="line"><span class="comment">// #endif</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><p> In this scenario, <code>DEFINE_MOCK_CREATE</code> is not directly used by Iridium for <code>IExample::create()</code>, but you could use it (or a similar flag like <code>USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</code>) in your own implementation of <code>IExample::create()</code>.</p>
<p>This detailed information should correctly reflect the mocking mechanism when using <code>create()</code> in Iridium.</p>
<h2><a class="anchor" id="subsec_testing_sequences"></a>
Testing Call Sequences</h2>
<p>Sometimes it's important not only which methods of a mock object are called, but also in what order. The Iridium mocking framework provides means to define and verify call sequences.</p>
<h3><a class="anchor" id="subsubsec_testing_defining_sequences"></a>
Defining a Sequence (DEFINE_MOCK_SEQUENCE)</h3>
<p>The <code><a class="el" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27" title="Defines a MockSequence object for verifying ordered expectations.">DEFINE_MOCK_SEQUENCE(sequence_name, mock_object)</a></code> macro is used to create a sequence object.</p><ul>
<li><code>sequence_name</code>: The name you give to this sequence (a variable <code>sequence_&lt;sequence_name&gt;</code> will be created).</li>
<li><code>mock_object</code>: The instance of the mock object for which you are defining the call sequence.</li>
</ul>
<p>This macro should be called at the beginning of your test where you want to define expectations for the order of calls.</p>
<h3><a class="anchor" id="subsubsec_testing_sequence_expectations"></a>
Expectations in a Sequence (DEFINE_MOCK_SEQUENCE_EXPECTATION)</h3>
<p>After defining a sequence object, you add expected calls to it using the <code><a class="el" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57" title="Adds an expectation to a MockSequence. This macro is likely intended to be part of a chained call or ...">DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock_object, method_name, arg1, arg2, ...)</a></code> macro.</p><ul>
<li><code>sequence_name</code>: The name of the previously defined sequence.</li>
<li><code>mock_object</code>: The same mock object.</li>
<li><code>method_name</code>: The name of the mocked method that is expected to be called.</li>
<li><code>(arg1, arg2, ...)</code>: The expected arguments for this call, enclosed in parentheses.</li>
</ul>
<p>Each call to <code>DEFINE_MOCK_SEQUENCE_EXPECTATION</code> adds one expectation to the specified sequence. The order of these macros defines the expected order of method calls.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// For completeness, define IMyDependency and its mock here.</span></div>
<div class="line"><span class="comment">// In real code, they would be in header files.</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> setup() = 0; <span class="comment">// New method to demonstrate sequence</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt;&amp;)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, setup) <span class="comment">// Mock for the new method</span></div>
<div class="line">};</div>
<div class="line"><span class="comment">// End of IMyDependency and mock definitions</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Class demonstrating calls in a specific sequence</span></div>
<div class="line"><span class="keyword">class </span>ServiceWithOrderedCalls {</div>
<div class="line">    IMyDependency* dep_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ServiceWithOrderedCalls(IMyDependency* dep) : dep_(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initializeAndGetData(<span class="keywordtype">int</span> val_key) {</div>
<div class="line">        dep_-&gt;setup(); <span class="comment">// First expected call</span></div>
<div class="line">        std::vector&lt;int&gt; data_vec = {val_key, val_key * 2};</div>
<div class="line">        dep_-&gt;processData(data_vec); <span class="comment">// Second expected call</span></div>
<div class="line">        dep_-&gt;getValue(val_key); <span class="comment">// Third expected call</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(ServiceOrderedTest) {</div>
<div class="line">    IMyDependencyMock mockDep;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define behavior for methods so they just work</span></div>
<div class="line">    <span class="comment">// (for sequence testing, it&#39;s important that calls happen,</span></div>
<div class="line">    <span class="comment">// not what they return, unless it&#39;s part of the test logic)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, setup, mockDep) {};</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, <span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) {};</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, <span class="keywordtype">int</span> key) { <span class="keywordflow">return</span> key + 1; };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define sequence &#39;s1&#39; for object &#39;mockDep&#39;</span></div>
<div class="line">    <span class="comment">// The sequence object name will be sequence_s1</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27">DEFINE_MOCK_SEQUENCE</a>(s1, mockDep); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add expectations to sequence s1</span></div>
<div class="line">    <span class="comment">// Expect mockDep.setup() to be called with no arguments</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, setup); </div>
<div class="line">    <span class="comment">// Expect mockDep.processData() to be called with a specific vector</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, processData, {10, 20}); </div>
<div class="line">    <span class="comment">// Expect mockDep.getValue() to be called with argument 10</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, getValue, 10); </div>
<div class="line"> </div>
<div class="line">    ServiceWithOrderedCalls service(&amp;mockDep);</div>
<div class="line">    service.initializeAndGetData(10); <span class="comment">// This method should call mockDep methods in the specified order</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Sequence verification happens automatically. If the order is violated,</span></div>
<div class="line">    <span class="comment">// or one of the expected calls did not occur in the right place,</span></div>
<div class="line">    <span class="comment">// or undeclared methods of the mock in the sequence were called,</span></div>
<div class="line">    <span class="comment">// MockSequence::step will throw an exception, and the test will fail.</span></div>
<div class="line">    <span class="comment">// If all calls occurred in the correct order with the correct arguments, the test will pass.</span></div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_aae10d30862b8ed496a69f53cc93d7c57"><div class="ttname"><a href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a></div><div class="ttdeci">#define DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock, method)</div><div class="ttdoc">Adds an expectation to a MockSequence. This macro is likely intended to be part of a chained call or ...</div><div class="ttdef"><b>Definition</b> mock.h:849</div></div>
<div class="ttc" id="amock_8h_html_ace4b22cc417f51770cfce95652a56f27"><div class="ttname"><a href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27">DEFINE_MOCK_SEQUENCE</a></div><div class="ttdeci">#define DEFINE_MOCK_SEQUENCE(name)</div><div class="ttdoc">Defines a MockSequence object for verifying ordered expectations.</div><div class="ttdef"><b>Definition</b> mock.h:830</div></div>
</div><!-- fragment --><p><b>Important Notes:</b></p><ul>
<li>If a method is called with arguments different from those specified in <code>DEFINE_MOCK_SEQUENCE_EXPECTATION</code>, it is considered a sequence violation.</li>
<li>If, during code execution, calls to mocked methods occur that are not part of the current expected step in the sequence (or are not expected at all within any active sequence), this may also lead to an error, depending on the strictness of the mock framework implementation. Exact matching is usually expected.</li>
<li>Sequence verification is performed at each step (<code>step</code> inside <code>MockSequence</code>). If the order is violated, an exception will be thrown immediately.</li>
</ul>
<p>Using sequences is particularly useful for testing interaction protocols or complex scenarios where the order of operations is critical. ``` </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
