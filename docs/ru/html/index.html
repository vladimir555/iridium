<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iridium: Iridium</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iridium<span id="projectnumber">&#160;0.9.95</span>
   </div>
   <div id="projectbrief">Легковесный C++ фреймворк (логгер, сериализация, потоки, процессы, ввод/вывод, тестирование)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Поиск',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iridium </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_mainpage__ru"></a> </p><div style="float: left; margin-right: 15px; max-height: 50px;"> <div class="image">
<img src="logo.png" alt="" width="100px"/>
</div>
 </div><p>Добро пожаловать в документацию по библиотеке Iridium!</p>
<p>Эта документация предоставляет информацию о том, как использовать различные компоненты библиотеки Iridium. Изучите разделы ниже, чтобы узнать о ее возможностях.</p>
<h1><a class="anchor" id="sec_parsers_serializers"></a>
Парсеры и сериализаторы</h1>
<p>Библиотека Iridium предоставляет гибкий механизм для парсинга данных из строковых представлений в структурированное дерево узлов и для сериализации (компоновки) этих деревьев узлов обратно в строки. В основном это достигается через интерфейс <code><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Интерфейс для парсеров и компоновщиков (сериализаторов) данных. Парсеры отвечают за преобразование ст...">iridium::parsing::IParser</a></code>.</p>
<h2><a class="anchor" id="subsec_iparser"></a>
Интерфейс IParser</h2>
<p>Интерфейс <code><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Интерфейс для парсеров и компоновщиков (сериализаторов) данных. Парсеры отвечают за преобразование ст...">iridium::parsing::IParser</a></code> (определенный в <code><a class="el" href="parser_8h.html" title="Определяет интерфейс IParser для разбора и формирования структурированных данных. Этот интерфейс пред...">iridium/parsing/parser.h</a></code>) является основным компонентом для парсинга и сериализации. Он предоставляет два основных метода:</p><ul>
<li><code>parse(const std::string&amp; source)</code>: Принимает строку в качестве входных данных и возвращает <code>iridium::parsing::INode::TSharedPtr</code>, который является корнем древовидной структуры, представляющей разобранные данные.</li>
<li><code>compose(iridium::parsing::INode::TConstSharedPtr const&amp; root_node)</code>: Принимает корневой узел древовидной структуры и возвращает его строковое представление.</li>
</ul>
<h2><a class="anchor" id="subsec_obtaining_parser"></a>
Получение парсера</h2>
<p>Конкретные реализации парсеров предоставляются для различных форматов данных. Например, чтобы создать JSON-парсер, вы можете использовать его статический метод <code>create()</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span> <span class="comment">// Для CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span> <span class="comment">// Для IParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span>   <span class="comment">// Для INode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (jsonParser) {</div>
<div class="line">        <span class="comment">// Используйте парсер...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;JSON Parser created successfully.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anode_8h_html"><div class="ttname"><a href="node_8h.html">node.h</a></div><div class="ttdoc">Определяет typedef INode, специализацию INodeType&lt;std::string&gt;. Служит основным типом для представлен...</div></div>
<div class="ttc" id="aparser_8h_html"><div class="ttname"><a href="parser_8h.html">parser.h</a></div><div class="ttdoc">Определяет интерфейс IParser для разбора и формирования структурированных данных. Этот интерфейс пред...</div></div>
<div class="ttc" id="aparser__json_8h_html"><div class="ttname"><a href="parser__json_8h.html">parser_json.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_parsing_example"></a>
Пример парсинга (JSON)</h2>
<p>Вот как вы можете разобрать JSON-строку в дерево <code>INode</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string json_string = R<span class="stringliteral">&quot;({ &quot;name&quot;: &quot;IridiumApp&quot;, &quot;version&quot;: 1.0, &quot;modules&quot;: [&quot;parsing&quot;, &quot;logging&quot;] })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(json_string);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;JSON parsed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Теперь вы можете исследовать структуру дерева rootNode.</span></div>
<div class="line">            <span class="comment">// Например, чтобы получить атрибут &#39;name&#39;:</span></div>
<div class="line">            iridium::parsing::INode::TSharedPtr nameNode = rootNode-&gt;getChild(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (nameNode) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Application Name: &quot;</span> &lt;&lt; nameNode-&gt;getValue() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Parsing returned a null node (empty input or other non-error case).&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_serializing_example"></a>
Пример сериализации (JSON)</h2>
<p>Чтобы сериализовать дерево <code>INode</code> (например, созданное программно или полученное в результате парсинга) обратно в JSON-строку:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// Для CNode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Создание простой структуры узлов программно</span></div>
<div class="line">    iridium::parsing::INode::TSharedPtr root = iridium::parsing::implementation::CNode::create(<span class="stringliteral">&quot;config&quot;</span>);</div>
<div class="line">    root-&gt;addChild(<span class="stringliteral">&quot;setting1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line">    iridium::parsing::INode::TSharedPtr subNode = root-&gt;addChild(<span class="stringliteral">&quot;advanced_settings&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;timeout&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;retries&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::string composed_json = jsonParser-&gt;compose(root);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Composed JSON: &quot;</span> &lt;&lt; composed_json &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Composition failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aimplementation_2node_8h_html"><div class="ttname"><a href="implementation_2node_8h.html">node.h</a></div><div class="ttdoc">Определяет typedef CNode, конкретную реализацию узла на основе CNodeType&lt;std::string&gt;....</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_serialization_macros"></a>
Типизированная сериализация с NodeView</h2>
<p>Для более сложных структур данных C++ библиотека Iridium предлагает мощный фреймворк сериализации/десериализации, основанный на <code><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Предоставляет типизированное представление или обертку над базовым объектом INode....">iridium::parsing::serialization::NodeView</a></code> и наборе макросов (таких как <code>DEFINE_ROOT_NODE_BEGIN</code>, <code>DEFINE_ATTRIBUTE</code>, <code>DEFINE_NODE_LIST_BEGIN</code> и т.д.). Эти инструменты позволяют определять структуры и классы C++, которые могут быть легко преобразованы в дерево <code>INode</code> и обратно, а затем в строковые форматы, такие как JSON, и обратно.</p>
<p>Эта система обеспечивает типизированный доступ к дереву узлов и автоматизирует большую часть шаблонного кода для сериализации и десериализации. Для получения подробной информации об использовании и примерах, пожалуйста, обратитесь к заголовочному файлу <code><a class="el" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a></code>.</p>
<p>Вот более конкретный пример использования этих макросов:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a>&quot;</span> <span class="comment">// Для макросов сериализации</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser__json_8h.html">iridium/parsing/implementation/parser_json.h</a>&quot;</span> <span class="comment">// Для CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// Для CNode (используется макросами)</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для convert (используется макросами)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span> <span class="comment">// Используется NodeViewList</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Требуется для компиляции макросов, если необходимы преобразования строк.</span></div>
<div class="line"><span class="comment">// Обычно у вас должны быть эти специализации для ваших пользовательских типов, если они не являются базовыми.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение простой структуры элемента данных</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MyDataItem) <span class="comment">// Корневой узел для прямого использования или вложения, по умолчанию использует разделитель &#39;-&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::string, Name, <span class="stringliteral">&quot;DefaultName&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, Value, 0)</div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение более сложной структуры настроек</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MySettings) <span class="comment">// Корневой узел, использует разделитель &#39;-&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ConfigName, <span class="stringliteral">&quot;DefaultConfig&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">bool</span>, IsEnabled, true)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определение вложенного узла с использованием ранее определенной структуры корневого узла</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a>(MyDataItem) <span class="comment">// Имя члена будет &#39;MyDataItem&#39;, имя узла &#39;my-data-item&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определение списка MyDataItem</span></div>
<div class="line">    <span class="comment">// Член списка будет называться &#39;ItemList&#39;, а каждый узел элемента будет называться &#39;item&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a>(Item) <span class="comment">// Это определяет TItem и TItemList</span></div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ItemName, <span class="stringliteral">&quot;DefaultItem&quot;</span>)</div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, ItemId, 0)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a>(Item) <span class="comment">// Член с именем &#39;Item&#39; типа TItemList</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Создание экземпляра JSON-парсера</span></div>
<div class="line">    <span class="keyword">auto</span> jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Пример сериализации ---</span></div>
<div class="line">    MySettings settingsToSerialize;</div>
<div class="line">    settingsToSerialize.ConfigName = <span class="stringliteral">&quot;UserSettings&quot;</span>;</div>
<div class="line">    settingsToSerialize.IsEnabled = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    settingsToSerialize.MyDataItem.Name = <span class="stringliteral">&quot;Special Item&quot;</span>;</div>
<div class="line">    settingsToSerialize.MyDataItem.Value = 123;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Добавление элементов в список</span></div>
<div class="line">    MySettings::TItem item1; <span class="comment">// Примечание: TItem вложен в MySettings из-за DEFINE_NODE_LIST_BEGIN</span></div>
<div class="line">    item1.ItemName = <span class="stringliteral">&quot;FirstListItem&quot;</span>;</div>
<div class="line">    item1.ItemId = 1;</div>
<div class="line">    settingsToSerialize.Item.add(item1);</div>
<div class="line"> </div>
<div class="line">    MySettings::TItem item2;</div>
<div class="line">    item2.ItemName = <span class="stringliteral">&quot;SecondListItem&quot;</span>;</div>
<div class="line">    item2.ItemId = 2;</div>
<div class="line">    settingsToSerialize.Item.add(item2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// Получение INode из нашего объекта настроек и его компоновка в JSON</span></div>
<div class="line">        std::string jsonOutput = jsonParser-&gt;compose(settingsToSerialize.getNode());</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Serialized JSON:&quot;</span> &lt;&lt; std::endl &lt;&lt; jsonOutput &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Ожидаемая структура вывода:</span></div>
<div class="line">        <span class="comment">// {</span></div>
<div class="line">        <span class="comment">//   &quot;config-name&quot;: &quot;UserSettings&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;is-enabled&quot;: &quot;true&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;my-data-item&quot;: {</span></div>
<div class="line">        <span class="comment">//     &quot;name&quot;: &quot;Special Item&quot;,</span></div>
<div class="line">        <span class="comment">//     &quot;value&quot;: &quot;123&quot;</span></div>
<div class="line">        <span class="comment">//   },</span></div>
<div class="line">        <span class="comment">//   &quot;item&quot;: [</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;FirstListItem&quot;, &quot;item-id&quot;: &quot;1&quot; },</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;SecondListItem&quot;, &quot;item-id&quot;: &quot;2&quot; }</span></div>
<div class="line">        <span class="comment">//   ]</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Serialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Пример десериализации ---</span></div>
<div class="line">    std::string jsonInput = R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">        &quot;config-name&quot;: &quot;LoadedSettings&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;is-enabled&quot;: &quot;false&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;my-data-item&quot;: {</span></div>
<div class="line"><span class="stringliteral">            &quot;name&quot;: &quot;LoadedItem&quot;,</span></div>
<div class="line"><span class="stringliteral">            &quot;value&quot;: &quot;456&quot;</span></div>
<div class="line"><span class="stringliteral">        },</span></div>
<div class="line"><span class="stringliteral">        &quot;item&quot;: [</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem1&quot;, &quot;item-id&quot;: &quot;10&quot; },</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem2&quot;, &quot;item-id&quot;: &quot;20&quot; }</span></div>
<div class="line"><span class="stringliteral">        ]</span></div>
<div class="line"><span class="stringliteral">    })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonInput);</div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            MySettings deserializedSettings(rootNode); <span class="comment">// Создание MySettings из INode</span></div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Deserialized Settings:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Config Name: &quot;</span> &lt;&lt; deserializedSettings.ConfigName.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Is Enabled: &quot;</span> &lt;&lt; (deserializedSettings.IsEnabled.get() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Name: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Name.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Value: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Value.get() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;List Items:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : deserializedSettings.Item) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  - Name: &quot;</span> &lt;&lt; item.ItemName.get() &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; item.ItemId.get() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing input JSON returned a null node.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Deserialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconvert_8h_html"><div class="ttname"><a href="convert_8h.html">convert.h</a></div><div class="ttdoc">Публичный интерфейс для фреймворка преобразования типов Iridium. Предоставляет доступ к функциям прео...</div></div>
<div class="ttc" id="aserialization_2node_8h_html"><div class="ttname"><a href="serialization_2node_8h.html">node.h</a></div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1547f0c86e3c410b26dcf1d13d1fcec7"><div class="ttname"><a href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_END(class_name)</div><div class="ttdoc">Завершает определение списка сложных дочерних узлов и объявляет экземпляр списка. Закрывает определен...</div><div class="ttdef"><b>Определения</b> node.h:725</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1c49dbc67050d59e4b5e7d095067a81a"><div class="ttname"><a href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_BEGIN(class_name)</div><div class="ttdoc">Начинает определение списка сложных дочерних узлов. Генерирует две структуры: T##class_name (для отде...</div><div class="ttdef"><b>Определения</b> node.h:704</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a6ae6809e071cbeb286389a6ea722e126"><div class="ttname"><a href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE(...)</div><div class="ttdoc">Макрос-переключатель, который диспетчеризует вызов в DEFINE_ATTRIBUTE_2 или DEFINE_ATTRIBUTE_3 в зави...</div><div class="ttdef"><b>Определения</b> node.h:684</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a7b4e724573d774904e29ede08ef7b17a"><div class="ttname"><a href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_END()</div><div class="ttdoc">Завершает определение структуры корневого узла, начатое DEFINE_ROOT_NODE_BEGIN. Просто предоставляет ...</div><div class="ttdef"><b>Определения</b> node.h:604</div></div>
<div class="ttc" id="aserialization_2node_8h_html_aac8f5e72dee27b1c9479d82a20f96f62"><div class="ttname"><a href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN(...)</div><div class="ttdoc">Макрос-переключатель, который диспетчеризует вызов в DEFINE_ROOT_NODE_BEGIN_1 или DEFINE_ROOT_NODE_BE...</div><div class="ttdef"><b>Определения</b> node.h:595</div></div>
<div class="ttc" id="aserialization_2node_8h_html_ac671d110728b8a4bd1ea52fc352c9120"><div class="ttname"><a href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a></div><div class="ttdeci">#define DEFINE_NODE_EXTERNAL(class_name)</div><div class="ttdoc">Объявляет член, являющийся экземпляром внешне определенной структуры корневого узла....</div><div class="ttdef"><b>Определения</b> node.h:778</div></div>
</div><!-- fragment --><p>Этот пример демонстрирует определение структур с атрибутами, вложенными узлами и списками узлов. Затем он показывает, как заполнить экземпляр такой структуры, сериализовать его в JSON и десериализовать JSON обратно в структуру, используя интерфейс <code>IParser</code> в сочетании с представлениями узлов, генерируемыми макросами. Метод <code>getNode()</code> в структуре, определенной макросом, предоставляет <code>INode</code>, необходимый для <code>compose</code>, а конструктор структуры может принимать <code>INode</code> (из <code>parse</code>) для своего заполнения. Помните, что фактические имена узлов в JSON (например, "config-name") выводятся из имен членов C++ путем преобразования CamelCase и вставки разделителя (по умолчанию '-').</p>
<h1><a class="anchor" id="sec_logging"></a>
Использование и конфигурация логгера</h1>
<p>Библиотека Iridium включает гибкую систему логирования для помощи в инструментировании вашего приложения и диагностике проблем. Она поддерживает несколько мест назначения вывода (приемников), настраиваемые уровни логирования и асинхронное логирование.</p>
<h2><a class="anchor" id="subsec_logging_macros"></a>
Базовое логирование</h2>
<p>Самый простой способ логирования сообщений — использование предоставленных макросов логирования:</p><ul>
<li><code>LOGT &lt;&lt; "Trace message";</code> (Уровень трассировки, часто включает файл/строку, обычно для отладочных сборок)</li>
<li><code>LOGD &lt;&lt; "Debug message";</code> (Уровень отладки, обычно для отладочных сборок)</li>
<li><code>LOGI &lt;&lt; "Informational message";</code> (Информационный уровень)</li>
<li><code>LOGW &lt;&lt; "Warning message";</code> (Уровень предупреждения)</li>
<li><code>LOGE &lt;&lt; "Error message";</code> (Уровень ошибки)</li>
<li><code>LOGF &lt;&lt; "Fatal message";</code> (Фатальный уровень)</li>
</ul>
<p>Эти макросы создают временный объект потока лога. Вы можете передавать в них данные с помощью оператора <code>&lt;&lt;</code>, аналогично <code>std::cout</code>. Когда оператор завершается, сообщение лога автоматически форматируется и отправляется в настроенные приемники логов.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span> <span class="comment">// Основной заголовочный файл для логирования</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Базовая конфигурация (вывод в консоль по умолчанию) обычно настраивается, если не предоставлена пользовательская конфигурация.</span></div>
<div class="line">    <span class="comment">// Для большего контроля см. примеры конфигурации ниже.</span></div>
<div class="line">    <span class="comment">// iridium::logging::setConfig(iridium::logging::config::createDefault()); // Пример установки по умолчанию</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> count = 42;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;Application started. Current count: &quot;</span> &lt;&lt; count;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This is a debug message. It might not appear in release builds.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (count &gt; 100) {</div>
<div class="line">        <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;Count is higher than expected: &quot;</span> &lt;&lt; count;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// LOGE &lt;&lt; &quot;An example error occurred.&quot;;</span></div>
<div class="line">    <span class="comment">// LOGF &lt;&lt; &quot;A fatal error occurred, application might terminate.&quot;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html"><div class="ttname"><a href="logger_8h.html">logger.h</a></div><div class="ttdoc">Определяет основной класс-одиночку Logger, вспомогательные структуры LogStream и LogStreamDummy,...</div></div>
<div class="ttc" id="alogger_8h_html_a13fd5c842ec8d93baac58bb616497fe8"><div class="ttname"><a href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a></div><div class="ttdeci">#define LOGI</div><div class="ttdoc">Макрос логирования для сообщений уровня INFO. Использование: LOGI &lt;&lt; &quot;Информационное сообщение: &quot; &lt;&lt; ...</div><div class="ttdef"><b>Определения</b> logger.h:531</div></div>
<div class="ttc" id="alogger_8h_html_a62b5282578b939fd77b7bb1d00c4f15a"><div class="ttname"><a href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a></div><div class="ttdeci">#define LOGD</div><div class="ttdoc">Макрос логирования для сообщений уровня DEBUG. Отключен, если не определены BUILD_TYPE_DEBUG или BUIL...</div><div class="ttdef"><b>Определения</b> logger.h:522</div></div>
<div class="ttc" id="alogger_8h_html_ac6f0b43ab85743ce5de50d53bda6de62"><div class="ttname"><a href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a></div><div class="ttdeci">#define LOGW</div><div class="ttdoc">Макрос логирования для сообщений уровня WARNING. Использование: LOGW &lt;&lt; &quot;Предупреждающее сообщение: &quot;...</div><div class="ttdef"><b>Определения</b> logger.h:539</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_logger_configuration"></a>
Конфигурация логгера</h2>
<p>Логгер настраивается с помощью структуры <code>iridium::logging::config::TLogger</code>, которая определена в <code><a class="el" href="logging_2config_8h.html">iridium/logging/config.h</a></code>. Эту структуру можно заполнить программно или потенциально загрузить из конфигурационного файла (если он разобран в дерево <code>INode</code>).</p>
<p>Ключевые поля в <code>iridium::logging::config::TLogger</code>:</p><ul>
<li><code>IsGmtTime</code> (bool): Если <code>true</code>, временные метки указаны в GMT/UTC; в противном случае используется местное время. По умолчанию <code>false</code>.</li>
<li><code>Level</code> (<code>iridium::logging::TEvent::TLevel</code>): Глобальный уровень логирования по умолчанию. Конкретные приемники могут переопределять это значение. По умолчанию <code>TRACE</code>.</li>
<li><code>Sink</code> (список объектов <code>TLogger::TSink</code>): Определяет одно или несколько мест назначения вывода для сообщений лога.</li>
</ul>
<p>Каждый объект <code>TLogger::TSink</code> в списке <code>Sink</code> имеет следующие ключевые поля:</p><ul>
<li><code>Type</code> (<code>iridium::logging::config::TLogger::TSink::TSinkType</code>): Указывает тип приемника. Распространенные значения:<ul>
<li><code>CONSOLE</code>: Вывод в стандартную консоль.</li>
<li><code>FILE</code>: Вывод в один файл.</li>
<li><code>FILE_DAILY</code>: Вывод в файл, который ротируется ежедневно.</li>
<li><code>FILE_TIMELY</code>: Вывод в новый файл каждый раз при запуске логгера.</li>
</ul>
</li>
<li><code>IsAsync</code> (bool): Если <code>true</code>, этот приемник обрабатывает сообщения лога асинхронно в отдельном потоке. По умолчанию <code>false</code>.</li>
<li><code>Uri</code> (std::string): Для файловых приемников (<code>FILE</code>, <code>FILE_DAILY</code>, <code>FILE_TIMELY</code>) это путь к файлу лога.</li>
<li><code>Level</code> (<code>iridium::logging::TEvent::TLevel</code>): Конкретный уровень логирования для этого приемника. Если установлено значение <code>UNKNOWN</code>, он наследует глобальный уровень логгера. В противном случае он переопределяет глобальный уровень для этого конкретного приемника.</li>
</ul>
<h2><a class="anchor" id="subsec_logger_config_example"></a>
Пример программной конфигурации</h2>
<p>Вот как настроить логгер программно:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logging_2config_8h.html">iridium/logging/config.h</a>&quot;</span> <span class="comment">// Для TLogger, TEvent::TLevel и т.д.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Создание объекта конфигурации TLogger</span></div>
<div class="line">    iridium::logging::config::TLogger loggerConfig;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Установка глобальных свойств</span></div>
<div class="line">    loggerConfig.IsGmtTime = <span class="keyword">false</span>;</div>
<div class="line">    loggerConfig.Level = iridium::logging::TEvent::TLevel::INFO; <span class="comment">// Глобальный уровень</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Конфигурация приемника для консоли</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink consoleSink;</div>
<div class="line">    consoleSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::CONSOLE;</div>
<div class="line">    consoleSink.IsAsync = <span class="keyword">false</span>;</div>
<div class="line">    consoleSink.Level = iridium::logging::TEvent::TLevel::DEBUG; <span class="comment">// Консоль будет показывать DEBUG и выше</span></div>
<div class="line">    loggerConfig.Sink.add(consoleSink); <span class="comment">// Добавление в список приемников</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Конфигурация файлового приемника</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink fileSink;</div>
<div class="line">    fileSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::FILE;</div>
<div class="line">    fileSink.IsAsync = <span class="keyword">true</span>; <span class="comment">// Асинхронное логирование в файл</span></div>
<div class="line">    fileSink.Uri = <span class="stringliteral">&quot;application.log&quot;</span>;</div>
<div class="line">    fileSink.Level = iridium::logging::TEvent::TLevel::WARNING; <span class="comment">// Файл будет получать только WARNING и выше</span></div>
<div class="line">    loggerConfig.Sink.add(fileSink);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Применение конфигурации</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a>(loggerConfig);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Теперь логгер настроен.</span></div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; <span class="stringliteral">&quot;This TRACE message will not appear on console or file.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This DEBUG message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;This INFO message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;This WARNING message will appear on console AND in application.log.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; <span class="stringliteral">&quot;This ERROR message will also appear on console AND in application.log.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html_a4f7814d1bd32cecccb2f3fafbb3ade58"><div class="ttname"><a href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a></div><div class="ttdeci">#define LOGT</div><div class="ttdoc">Макрос логирования для сообщений уровня TRACE. Добавляет имя файла и номер строки....</div><div class="ttdef"><b>Определения</b> logger.h:507</div></div>
<div class="ttc" id="alogger_8h_html_ae08358ff7da64345ad674296a5957823"><div class="ttname"><a href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a></div><div class="ttdeci">#define LOGE</div><div class="ttdoc">Макрос логирования для сообщений уровня ERROR. Использование: LOGE &lt;&lt; &quot;Сообщение об ошибке: &quot; &lt;&lt; valu...</div><div class="ttdef"><b>Определения</b> logger.h:547</div></div>
<div class="ttc" id="alogging_2config_8h_html"><div class="ttname"><a href="logging_2config_8h.html">config.h</a></div></div>
<div class="ttc" id="anamespaceiridium_1_1logging_html_a4fff5fa51c4d1b05c97ae08faf5efd18"><div class="ttname"><a href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a></div><div class="ttdeci">void setConfig(config::TLogger const &amp;config)</div><div class="ttdoc">Устанавливает глобальную конфигурацию логгера. Это свободная функция-обертка вокруг Logger::instance(...</div><div class="ttdef"><b>Определения</b> logger.cpp:158</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_default_config"></a>
Конфигурация по умолчанию</h2>
<p>Библиотека предоставляет вспомогательную функцию для получения простой конфигурации по умолчанию: <code>iridium::logging::config::TLogger defaultConfig = <a class="el" href="namespaceiridium_1_1logging_1_1config.html#a57a36466c8a3545a48ab706922b86672">iridium::logging::config::createDefault()</a>;</code></p>
<p>Эта конфигурация по умолчанию обычно настраивает синхронный консольный приемник с уровнем логирования <code>TRACE</code>. Вы можете изменить этот объект конфигурации по умолчанию перед его применением с помощью <code><a class="el" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18" title="Устанавливает глобальную конфигурацию логгера. Это свободная функция-обертка вокруг Logger::instance(...">iridium::logging::setConfig()</a></code>.</p>
<p>Помните, что конфигурацию логгера в идеале следует выполнять на ранних этапах жизненного цикла вашего приложения, до того, как произойдет какое-либо значительное логирование.</p>
<h1><a class="anchor" id="sec_custom_type_conversion"></a>
Интеграция пользовательских типов с <code>iridium::convertion::convert</code></h1>
<p>Библиотека Iridium предоставляет гибкий способ интеграции ваших пользовательских типов данных с ее системами, такими как логирование и макросы сериализации. Это достигается путем предоставления специализаций для шаблонной функции <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a>&lt;TargetType, SourceType&gt;</code> для вашего пользовательского типа.</p>
<p>Библиотека предлагает пару макросов для объявления и реализации этих специализаций:</p><ul>
<li><b><code><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Определяет (объявляет) специализацию для шаблонной функции iridium::convertion::implementation::conve...">DEFINE_CONVERT(TTo, TFrom)</a></code></b>: Этот макрос следует использовать в вашем заголовочном файле (например, рядом с определением вашего пользовательского типа). Он объявляет компилятору, что будет доступна конкретная специализация преобразования.</li>
<li><b><code><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Реализует специализацию для шаблонной функции iridium::convertion::implementation::convert....">IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</a></code></b>: Этот макрос используется в исходном файле (.cpp) для предоставления фактической реализации преобразования. <code>TFunc</code> должен быть функцией, функтором или лямбда-выражением, которое принимает аргумент <code>TFrom const&amp;</code> и возвращает <code>TTo</code>.</li>
</ul>
<h2><a class="anchor" id="subsec_custom_convert_example_fn"></a>
Пример: Пользовательский тип <code>Point</code></h2>
<p>Проиллюстрируем это на примере пользовательской структуры <code>Point</code>.</p>
<p><b>1. Определение типа и объявление преобразований (например, в <code>Point.h</code>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once </span><span class="comment">// Пример защитного включения заголовка</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для DEFINE_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span> <span class="comment">// Требуется для использования std::string</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пользовательская структура</span></div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Необязательно: для прямого сравнения в примерах или тестах</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> x == other.x &amp;&amp; y == other.y;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Объявление того, что мы предоставим специализации для преобразования</span></div>
<div class="line"><span class="comment">// Point в std::string и std::string в Point.</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(std::string, Point);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(Point, std::string);</div>
<div class="ttc" id="aconvert_8h_html_ab6323540b384b64371e62ea6e910317b"><div class="ttname"><a href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a></div><div class="ttdeci">#define DEFINE_CONVERT(TTo, TFrom)</div><div class="ttdoc">Определяет (объявляет) специализацию для шаблонной функции iridium::convertion::implementation::conve...</div><div class="ttdef"><b>Определения</b> convert.h:69</div></div>
</div><!-- fragment --><p><b>2. Реализация преобразований (например, в <code>Point.cpp</code>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Предполагается, что здесь находятся определения структуры Point и объявления DEFINE_CONVERT</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для IMPLEMENT_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// Для std::invalid_argument, std::out_of_range</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Вспомогательная функция для преобразования Point в std::string</span></div>
<div class="line"><span class="keyword">static</span> std::string localPointToString(<span class="keyword">const</span> Point&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + std::to_string(p.x) + <span class="stringliteral">&quot;,&quot;</span> + std::to_string(p.y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Вспомогательная функция для преобразования std::string в Point</span></div>
<div class="line"><span class="keyword">static</span> Point localStringToPoint(<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s.length() &lt; 3 || s.front() != <span class="charliteral">&#39;(&#39;</span> || s.back() != <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing parentheses. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    std::string content = s.substr(1, s.length() - 2); <span class="comment">// Удаление скобок</span></div>
<div class="line">    <span class="keywordtype">size_t</span> comma_pos = content.find(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (comma_pos == std::string::npos) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing comma. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordtype">int</span> x_val = std::stoi(content.substr(0, comma_pos));</div>
<div class="line">        <span class="keywordtype">int</span> y_val = std::stoi(content.substr(comma_pos + 1));</div>
<div class="line">        <span class="keywordflow">return</span> {x_val, y_val};</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e_ia) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid integer in Point string: &quot;</span> + std::string(e_ia.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; e_oor) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Integer out of range in Point string: &quot;</span> + std::string(e_oor.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Реализация объявленных специализаций преобразования с использованием вспомогательных функций</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(std::string, Point, localPointToString);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(Point, std::string, localStringToPoint);</div>
<div class="ttc" id="aconvert_8h_html_aa14ff619763935045ee893f7f1e8668f"><div class="ttname"><a href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a></div><div class="ttdeci">#define IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</div><div class="ttdoc">Реализует специализацию для шаблонной функции iridium::convertion::implementation::convert....</div><div class="ttdef"><b>Определения</b> convert.h:94</div></div>
</div><!-- fragment --><p><b>3. Пример использования (например, в <code>main.cpp</code> или тестах)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Заголовочный файл вашего пользовательского типа</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span>   <span class="comment">// Для LOGI (пример использования)</span></div>
<div class="line"><span class="comment">// Для примера макросов сериализации (концептуально)</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/serialization/node.h&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// Для std::cout</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main_custom_convert_demo() { <span class="comment">// Переименовано, чтобы избежать конфликтов, если mainpage.md компилируется</span></div>
<div class="line">    Point p1 = {7, 14};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример логирования:</span></div>
<div class="line">    <span class="comment">// iridium::logging::LogStream обычно использует iridium::convertion::convert&lt;std::string&gt;(value)</span></div>
<div class="line">    <span class="comment">// для типов, у которых нет прямой перегрузки оператора std::ostream&amp; operator&lt;&lt;.</span></div>
<div class="line">    <span class="comment">// Таким образом, после определения преобразования это должно работать:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;My custom point: &quot; &lt;&lt; p1;</span></div>
<div class="line">    <span class="comment">// Для этого примера мы продемонстрируем преобразование явно:</span></div>
<div class="line">    std::string p1_as_string = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(p1);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Point p1 converted to string: &quot;</span> &lt;&lt; p1_as_string &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример десериализации (например, из строки конфигурации):</span></div>
<div class="line">    std::string input_string = <span class="stringliteral">&quot;(100,-200)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        Point p2 = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;Point&gt;</a>(input_string);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;String &#39;&quot;</span> &lt;&lt; input_string &lt;&lt; <span class="stringliteral">&quot;&#39; converted to Point: (&quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; p2.y &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error converting string to Point: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Как это применяется к макросам сериализации:</span></div>
<div class="line">    <span class="comment">// Если вы определяете сериализуемую структуру следующим образом:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyStructure)</span></div>
<div class="line">    <span class="comment">//   DEFINE_ATTRIBUTE(Point, Position) // Использует Point</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// MyStructure data;</span></div>
<div class="line">    <span class="comment">// data.Position = {5,5}; // Установка Point</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // При сериализации:</span></div>
<div class="line">    <span class="comment">// // auto jsonParser = iridium::parsing::implementation::CJSONParser::create();</span></div>
<div class="line">    <span class="comment">// // std::string json_output = jsonParser-&gt;compose(data.getNode());</span></div>
<div class="line">    <span class="comment">// // ...значением узла &#39;Position&#39; будет &quot;(5,5)&quot; благодаря Convert&lt;std::string, Point&gt;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // При десериализации:</span></div>
<div class="line">    <span class="comment">// // std::string json_input = R&quot;({ &quot;position&quot;: &quot;(10,20)&quot; })&quot;;</span></div>
<div class="line">    <span class="comment">// // MyStructure loaded_data(jsonParser-&gt;parse(json_input));</span></div>
<div class="line">    <span class="comment">// // ...строка &quot;(10,20)&quot; будет преобразована в объект Point для &#39;Position&#39;</span></div>
<div class="line">    <span class="comment">// //    благодаря Convert&lt;Point, std::string&gt;.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceiridium_1_1convertion_html_a5afe4d5e065e8b085dcd6b8b391f2c2d"><div class="ttname"><a href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert</a></div><div class="ttdeci">string convert(system_clock::time_point const &amp;value, bool const &amp;is_gmt_time)</div><div class="ttdoc">Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....</div><div class="ttdef"><b>Определения</b> convert.cpp:89</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_custom_convert_fn_impact"></a>
Влияние пользовательских специализаций <code>convert</code></h2>
<p><b>Для логирования:</b> После того, как вы предоставите специализацию <code><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Определяет (объявляет) специализацию для шаблонной функции iridium::convertion::implementation::conve...">DEFINE_CONVERT(std::string, YourCustomType)</a></code> и ее реализацию, ваши пользовательские объекты часто можно будет напрямую использовать в операторах логирования (например, <code>LOGI &lt;&lt; yourCustomObject;</code>). Система логирования обычно вызывает <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a>&lt;std::string&gt;(yourCustomObject)</code> для получения строкового представления, если не найдена или не предпочтительна прямая перегрузка <code>operator&lt;&lt;(std::ostream&amp;, const YourCustomType&amp;)</code>.</p>
<p><b>Для макросов сериализации:</b> При использовании макросов сериализации, таких как <code><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126" title="Макрос-переключатель, который диспетчеризует вызов в DEFINE_ATTRIBUTE_2 или DEFINE_ATTRIBUTE_3 в зави...">DEFINE_ATTRIBUTE(YourCustomType, myField)</a></code>:</p><ul>
<li>Специализация для <code>Convert&lt;std::string, YourCustomType&gt;</code> (реализованная через <code>IMPLEMENT_CONVERT</code>) используется для преобразования члена <code>myField</code> в его строковое представление при сериализации родительской структуры. Эта строка затем сохраняется как значение соответствующего узла (например, строковый атрибут JSON или текстовый узел XML).</li>
<li>Специализация для <code>Convert&lt;YourCustomType, std::string&gt;</code> (реализованная через <code>IMPLEMENT_CONVERT</code>) используется во время десериализации. Если парсер считывает строковое значение из входных данных (например, из атрибута JSON), которое необходимо преобразовать в <code>YourCustomType</code> для <code>myField</code>, будет вызвана эта специализация.</li>
</ul>
<p>Предоставляя эти специализации функции <code>convert</code>, вы позволяете вашим пользовательским типам данных плавно интегрироваться с различными частями библиотеки Iridium, которые полагаются на преобразование типов, особенно для строковых представлений. Не забудьте объявить специализации с помощью <code>DEFINE_CONVERT</code> в заголовочном файле и реализовать их с помощью <code>IMPLEMENT_CONVERT</code> и вашей логики преобразования в исходном файле.</p>
<h1><a class="anchor" id="sec_define_enum"></a>
Обработка перечислений с помощью DEFINE_ENUM</h1>
<p>Библиотека Iridium часто предоставляет служебный макрос <code>DEFINE_ENUM</code> (обычно ожидаемый в заголовочном файле, таком как <code><a class="el" href="enum_8h.html" title="Предоставляет макросы для создания расширенных перечислений C++ с такими функциями,...">iridium/enum.h</a></code> или общем заголовочном файле утилит), чтобы упростить определение типов C++ <code>enum class</code> и автоматически интегрировать их с системой <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a></code>. Эта интеграция имеет решающее значение для простого логирования значений перечислений в виде удобочитаемых строк и для их сериализации/десериализации в конфигурационных файлах или форматах обмена данными.</p>
<p><b>Ключевая функциональность <code>DEFINE_ENUM</code>:</b></p>
<p>Когда вы используете <code>DEFINE_ENUM</code>, он обычно выполняет следующие действия:</p><ol type="1">
<li><b>Определяет <code>enum class</code></b>: Создает фактический C++ <code>enum class</code> с указанным именем и перечислителями.</li>
<li><b>Генерирует преобразования строк</b>: Что наиболее важно, он автоматически генерирует необходимые специализации для <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a></code>, чтобы разрешить:<ul>
<li>Преобразование значения перечисления в его строковое представление (например, <code>MyEnum::ValueOne</code> становится <code>"ValueOne"</code>).</li>
<li>Преобразование строкового представления обратно в значение перечисления (например, <code>"ValueOne"</code> становится <code>MyEnum::ValueOne</code>).</li>
</ul>
</li>
</ol>
<p><b>Типичный синтаксис:</b></p>
<p>Хотя точный синтаксис может незначительно отличаться в зависимости от конкретной реализации макроса, распространенным шаблоном является:</p>
<p><code><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет расширенный класс перечисления. Этот макрос генерирует класс, который оборачивает стандарт...">DEFINE_ENUM(EnumTypeName, Enumerator1, Enumerator2, ..., [OptionalDefaultOrUnknownEnumerator])</a></code></p>
<ul>
<li><code>EnumTypeName</code>: Желаемое имя для вашего <code>enum class</code>.</li>
<li><code>Enumerator1, Enumerator2, ...</code>: Список имен перечислителей.</li>
<li><code>[OptionalDefaultOrUnknownEnumerator]</code>: Часто последний перечислитель может быть назначен (например, назван <code>Unknown</code> или <code>Default</code>) для использования в качестве резервного значения, если строка не может быть успешно проанализирована в один из других определенных перечислителей. Если не указано, попытка преобразовать недопустимую строку в тип перечисления может привести к возврату первого перечислителя или, возможно, к ошибке, в зависимости от конструкции макроса.</li>
</ul>
<h2><a class="anchor" id="subsec_define_enum_example"></a>
Пример использования</h2>
<p>Проиллюстрируем это парой примеров. (Убедитесь, что вы включили заголовочный файл, предоставляющий <code>DEFINE_ENUM</code>, например, <code>#include "iridium/enum.h"</code>)</p>
<div class="fragment"><div class="line"><span class="comment">// Примечание: Макрос DEFINE_ENUM предоставляется библиотекой Iridium.</span></div>
<div class="line"><span class="comment">// Обычно для его использования вы бы включили заголовочный файл типа &lt;iridium/enum.h&gt;.</span></div>
<div class="line"><span class="comment">// mainpage_example_define_enum.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Предполагается, что &quot;iridium/enum.h&quot; или аналогичный заголовочный файл, определяющий DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// и &quot;iridium/convertion/convert.h&quot;, доступны.</span></div>
<div class="line"><span class="comment">// Для этого примера мы при необходимости имитируем ожидаемое поведение макроса для демонстрации,</span></div>
<div class="line"><span class="comment">// но в идеале он поступает из библиотеки.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример 1: Простое перечисление цветов</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(MyColor,</div>
<div class="line">    Red,    <span class="comment">// Сопоставляется с &quot;Red&quot;</span></div>
<div class="line">    Green,  <span class="comment">// Сопоставляется с &quot;Green&quot;</span></div>
<div class="line">    Blue    <span class="comment">// Сопоставляется с &quot;Blue&quot;</span></div>
<div class="line">) <span class="comment">// MyColor будет иметь MyColor::Red, MyColor::Green, MyColor::Blue</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример 2: Статус операции с явным значением Unknown/Default</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(OperationStatus,</div>
<div class="line">    Success,</div>
<div class="line">    Pending,</div>
<div class="line">    Failed,</div>
<div class="line">    Unknown <span class="comment">// Это может служить значением по умолчанию, если парсинг строки завершается неудачно</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/logging/logger.h&quot; // Для LOGI (концептуально)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_define_enum_usage() {</div>
<div class="line">    MyColor favoriteColor = MyColor::Green;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Преобразование перечисления в строку (например, для логирования или сериализации)</span></div>
<div class="line">    <span class="comment">// Ожидается, что макрос DEFINE_ENUM создал необходимую</span></div>
<div class="line">    <span class="comment">// специализацию iridium::convertion::convert&lt;std::string, MyColor&gt;.</span></div>
<div class="line">    std::string colorStr = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(favoriteColor);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Favorite color: &quot;</span> &lt;&lt; colorStr &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Green&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Концептуальное логирование:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;Current status: &quot; &lt;&lt; OperationStatus::Pending; // Выведет &quot;Pending&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Преобразование строки в перечисление (например, для десериализации из файла конфигурации)</span></div>
<div class="line">    std::string inputColorStr = <span class="stringliteral">&quot;Blue&quot;</span>;</div>
<div class="line">    MyColor parsedColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;MyColor&gt;</a>(inputColorStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed color from string &#39;&quot;</span> &lt;&lt; inputColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(parsedColor) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Blue&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример парсинга недопустимой строки для MyColor</span></div>
<div class="line">    std::string invalidColorStr = <span class="stringliteral">&quot;Purple&quot;</span>;</div>
<div class="line">    MyColor defaultOrFirstColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;MyColor&gt;</a>(invalidColorStr);</div>
<div class="line">    <span class="comment">// Поведение для недопустимой строки зависит от реализации DEFINE_ENUM.</span></div>
<div class="line">    <span class="comment">// Оно может по умолчанию использовать первый перечислитель (Red) или указанное значение &#39;Unknown&#39;, если макрос это поддерживает.</span></div>
<div class="line">    <span class="comment">// Наш концептуальный заполнитель по умолчанию использует &#39;Unknown&#39;, если доступно, или первый, если нет.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid color string &#39;&quot;</span> &lt;&lt; invalidColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(defaultOrFirstColor) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример с OperationStatus, у которого есть значение по умолчанию &#39;Unknown&#39;</span></div>
<div class="line">    std::string invalidStatusStr = <span class="stringliteral">&quot;NonExistentStatus&quot;</span>;</div>
<div class="line">    OperationStatus status = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;OperationStatus&gt;</a>(invalidStatusStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid status string &#39;&quot;</span> &lt;&lt; invalidStatusStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(status) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Unknown&quot;</span></div>
<div class="line"> </div>
<div class="line">    OperationStatus goodStatus = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;OperationStatus&gt;</a>(<span class="stringliteral">&quot;Success&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed valid status string &#39;Success&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(goodStatus) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Success&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aenum_8h_html_acf1825d3b8e6ea6b7e5f4dbc5bacae6d"><div class="ttname"><a href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a></div><div class="ttdeci">#define DEFINE_ENUM(TEnum,...)</div><div class="ttdoc">Определяет расширенный класс перечисления. Этот макрос генерирует класс, который оборачивает стандарт...</div><div class="ttdef"><b>Определения</b> enum.h:56</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_define_enum_impact"></a>
Влияние <code>DEFINE_ENUM</code></h2>
<p><b>Упрощенное логирование:</b> Поскольку <code>DEFINE_ENUM</code> обычно обрабатывает создание <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a>&lt;std::string, YourEnumType&gt;</code>, значения перечислений могут напрямую использоваться в операторах логирования, и они будут автоматически преобразованы в их удобочитаемые строковые имена: </p><div class="fragment"><div class="line"><span class="comment">// MyColor color = MyColor::Blue;</span></div>
<div class="line"><span class="comment">// LOGI &lt;&lt; &quot;Current color selection: &quot; &lt;&lt; color; // Залогирует &quot;Current color selection: Blue&quot;</span></div>
</div><!-- fragment --><p><b>Бесшовная сериализация:</b> Перечисления, определенные с помощью <code>DEFINE_ENUM</code>, плавно интегрируются с макросами сериализации Iridium. Если вы используете такое перечисление в качестве типа для атрибута: </p><div class="fragment"><div class="line"><span class="comment">// // Предполагая, что MyColor определен с использованием DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyWidgetConfig)</span></div>
<div class="line"><span class="comment">//   DEFINE_ATTRIBUTE(MyColor, WidgetColor)</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyWidgetConfig config;</span></div>
<div class="line"><span class="comment">// config.WidgetColor = MyColor::Red;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// // Сериализация &#39;config&#39; сохранит &quot;Red&quot; для атрибута &#39;widget-color&#39;.</span></div>
<div class="line"><span class="comment">// // Десериализация структуры, где &#39;widget-color&#39; равен &quot;Green&quot;, установит config.WidgetColor в MyColor::Green.</span></div>
</div><!-- fragment --><p> Система сериализации использует автоматически сгенерированные специализации <code>convert</code> для обработки преобразования между значениями перечислений и их строковыми представлениями в сериализованных данных (например, JSON, XML).</p>
<p>Таким образом, использование <code>DEFINE_ENUM</code> уменьшает количество шаблонного кода, обеспечивает согласованность и делает работу с перечислениями в Iridium намного удобнее. Всегда обращайтесь к конкретному заголовочному файлу <code><a class="el" href="enum_8h.html" title="Предоставляет макросы для создания расширенных перечислений C++ с такими функциями,...">iridium/enum.h</a></code> или эквивалентному в вашей версии библиотеки для получения точных возможностей и синтаксиса макроса <code>DEFINE_ENUM</code>.</p>
<h1><a class="anchor" id="sec_threading"></a>
Примитивы многопоточности</h1>
<p>Библиотека Iridium предоставляет несколько примитивов для помощи в разработке многопоточных приложений. К ним относятся инструменты для прямого управления потоками, синхронизации данных и обработки задач с помощью рабочих потоков и пулов.</p>
<p>Примечание: Некоторые конкретные классы, такие как <code><a class="el" href="class_c_thread.html" title="Конкретная реализация интерфейса IThread. Управляет фактическим std::thread для выполнения задачи IRu...">CThread</a></code>, <code><a class="el" href="class_c_worker.html" title="Реализует IWorker для обработки элементов из входной очереди и помещения результатов в выходную очере...">CWorker</a></code> и <code><a class="el" href="class_c_worker_pool.html">CWorkerPool</a></code>, находятся в пространстве имен <code><a class="el" href="namespaceiridium_1_1threading_1_1implementation.html" title="Содержит конкретные реализации интерфейсов, определенных в родительском пространстве имен threading.">iridium::threading::implementation</a></code>. Хотя у них могут быть фабричные методы <code>::create()</code>, предполагающие удобство использования, это пространство имен обычно указывает на то, что они являются фундаментальными блоками, возможно, предназначенными для обертывания высокоуровневыми абстракциями в некоторых случаях. Однако их прямое использование документируется здесь в соответствии с общими потребностями.</p>
<h2><a class="anchor" id="subsec_cthread"></a>
Использование CThread для прямого управления потоками</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_thread.html" title="Конкретная реализация интерфейса IThread. Управляет фактическим std::thread для выполнения задачи IRu...">iridium::threading::implementation::CThread</a></code> позволяет создавать и управлять выделенным потоком. Он выполняет задачу, определенную объектом, реализующим интерфейс <code><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></code>.</p>
<p><b>Интерфейс <code>IRunnable</code>:</b> Чтобы определить работу для <code><a class="el" href="class_c_thread.html" title="Конкретная реализация интерфейса IThread. Управляет фактическим std::thread для выполнения задачи IRu...">CThread</a></code>, вы создаете класс, который наследуется от <code><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></code>. Этот интерфейс требует реализации следующих методов:</p><ul>
<li><code>void initialize()</code>: Вызывается один раз после запуска потока для настройки.</li>
<li><code>void finalize()</code>: Вызывается один раз перед присоединением потока для очистки.</li>
<li><code>void run(std::atomic&lt;bool&gt;&amp; is_running)</code>: Это основная функция, выполняемая потоком. Она должна содержать логику вашей задачи и периодически проверять флаг <code>is_running</code>. Когда <code>is_running</code> становится <code>false</code>, метод <code>run</code> должен вернуться, чтобы позволить потоку корректно завершиться.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cthread.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2thread_8h.html">iridium/threading/implementation/thread.h</a>&quot;</span> <span class="comment">// Для CThread</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="runnable_8h.html">iridium/threading/runnable.h</a>&quot;</span>       <span class="comment">// Для IRunnable</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span>         <span class="comment">// Для iridium::threading::sleep, IThread (для getNameStatic)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span> <span class="comment">// Для std::chrono::milliseconds</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// Для std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Реализация IRunnable</span></div>
<div class="line"><span class="keyword">class </span>MyPeriodicTask : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Initializing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">run</a>(std::atomic&lt;bool&gt;&amp; is_running)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (is_running) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;): Working, count: &quot;</span> &lt;&lt; ++counter &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Имитация работы путем сна</span></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 5 &amp;&amp; is_running; ++i) { <span class="comment">// Проверяйте is_running чаще во время &quot;работы&quot;</span></div>
<div class="line">                 <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(200);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Exiting run loop.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Finalizing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cthread() {</div>
<div class="line">    <span class="comment">// 2. Создание экземпляра вашего IRunnable</span></div>
<div class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;MyPeriodicTask&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Создание и управление CThread</span></div>
<div class="line">    <span class="comment">// CThread::create принимает (имя, IRunnable::TSharedPtr)</span></div>
<div class="line">    <span class="keyword">auto</span> thread_obj = iridium::threading::implementation::CThread::create(<span class="stringliteral">&quot;MyWorker1&quot;</span>, task);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Initializing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;initialize(); <span class="comment">// Запускает поток и ожидает его запуска</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Sleeping for 3 seconds while thread runs...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(3000);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Finalizing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        thread_obj-&gt;finalize(); <span class="comment">// Сигнализирует потоку остановиться и ожидает его присоединения</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Thread finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Thread operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a5b8c613423cd12e98327a9279d8b9d64"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">iridium::pattern::IInitializable::initialize</a></div><div class="ttdeci">virtual void initialize()=0</div><div class="ttdoc">Выполняет инициализацию объекта. Этот метод должен быть вызван после конструирования объекта и перед ...</div></div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a93a1fb6f89e1e1f125455a8682e9ae59"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">iridium::pattern::IInitializable::finalize</a></div><div class="ttdeci">virtual void finalize()=0</div><div class="ttdoc">Выполняет финализацию или очистку объекта. Этот метод должен быть вызван, когда объект больше не нуже...</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></div><div class="ttdef"><b>Определения</b> runnable.h:19</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html_a8849596ba04c14d98b200c24491dcd97"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">iridium::threading::IRunnable::run</a></div><div class="ttdeci">virtual void run(std::atomic&lt; bool &gt; &amp;is_running)=0</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_aebf89ec3258e418ee6141cb9a5adb285"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a></div><div class="ttdeci">static std::string const &amp; getNameStatic()</div><div class="ttdoc">Получает имя текущего выполняющегося потока (статически, из локального хранилища потока).</div><div class="ttdef"><b>Определения</b> thread.cpp:51</div></div>
<div class="ttc" id="aimplementation_2thread_8h_html"><div class="ttname"><a href="implementation_2thread_8h.html">thread.h</a></div><div class="ttdoc">Определяет класс CThread, конкретную реализацию интерфейса IThread. Этот класс управляет std::thread ...</div></div>
<div class="ttc" id="anamespaceiridium_1_1threading_html_a77efc83dba79715684b3890184b31992"><div class="ttname"><a href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a></div><div class="ttdeci">void sleep(int const &amp;milliseconds)</div><div class="ttdoc">Приостанавливает выполнение текущего потока на указанную продолжительность.</div><div class="ttdef"><b>Определения</b> thread.cpp:41</div></div>
<div class="ttc" id="arunnable_8h_html"><div class="ttname"><a href="runnable_8h.html">runnable.h</a></div></div>
<div class="ttc" id="athread_8h_html"><div class="ttname"><a href="thread_8h.html">thread.h</a></div><div class="ttdoc">Определяет интерфейс IThread и связанные служебные функции для работы с потоками. Включает основной и...</div></div>
</div><!-- fragment --><p> В этом примере <code>MyPeriodicTask::run</code> будет выполняться в новом потоке, управляемом <code><a class="el" href="class_c_thread.html" title="Конкретная реализация интерфейса IThread. Управляет фактическим std::thread для выполнения задачи IRu...">CThread</a></code>. <code><a class="el" href="class_c_thread.html#a39b985df9f70f9502198035353b1eedc" title="Инициализирует поток, что включает запуск базового std::thread и ожидание сигнала об успешном запуске...">CThread::initialize()</a></code> запускает его, а <code><a class="el" href="class_c_thread.html#a66a1d7c2cba19611a23b645843b61474" title="Финализирует поток. Сигнализирует IRunnable об остановке, затем присоединяет базовый std::thread....">CThread::finalize()</a></code> устанавливает <code>is_running</code> в <code>false</code> и присоединяет поток.</p>
<h2><a class="anchor" id="subsec_synchronized"></a>
Использование Synchronized для защиты данных</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">iridium::threading::Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</code> — это шаблонный класс, предназначенный для защиты общих данных от одновременного доступа. Обычно он служит базовым классом для классов, содержащих данные, нуждающиеся в защите. Он использует мьютекс (например, <code>std::mutex</code>) и условную переменную.</p>
<p><b>Ключевой механизм: <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code></b> Макрос <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code> является основным способом взаимодействия с <code><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></code>. При размещении внутри метода класса, наследующего от <code><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></code>, он создает блокировку с ограниченной областью действия (экземпляр <code><a class="el" href="class_synchronized_1_1_locker.html" title="Класс для области видимости блокировки, который захватывает мьютекс объекта Synchronized при создании...">Synchronized::Locker</a></code>). Мьютекс захватывается при обнаружении <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code> и автоматически освобождается при выходе из области действия (благодаря RAII).</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span>    <span class="comment">// Для std::mutex</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span>   <span class="comment">// Для std::chrono</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/threading/implementation/thread.h&quot; // Для более сложной демонстрации с реальными потоками</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс, методы которого будут синхронизированы</span></div>
<div class="line"><span class="keyword">class </span>SafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; items_;</div>
<div class="line">    <span class="keywordtype">int</span> access_count_ = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addItem(<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Блокировка захвачена для этой области</span></div>
<div class="line">        items_.push_back(item);</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItem: Added &#39;&quot; &lt;&lt; item &lt;&lt; &quot;&#39;. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// Мьютекс автоматически освобождается здесь деструктором _____locked_scope_____</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> addItems(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; items_to_add) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item_to_add : items_to_add) { <span class="comment">// Исправлено имя переменной</span></div>
<div class="line">            items_.push_back(item_to_add);</div>
<div class="line">        }</div>
<div class="line">        access_count_++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItems: Added multiple items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; getItems() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// Возврат по значению гарантирует, что копия будет сделана, пока блокировка удерживается.</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;getItems: Returning copy of items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">return</span> items_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getAccessCount() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">return</span> access_count_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> waitUntilItemCountReaches(<span class="keywordtype">size_t</span> target_count, std::chrono::milliseconds timeout) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Waiting for item count &quot; &lt;&lt; target_count &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">while</span> (items_.size() &lt; target_count) {</div>
<div class="line">            <span class="keywordflow">if</span> (!_____locked_scope_____.wait(timeout)) {</div>
<div class="line">                <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Wait timed out or was interrupted.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Woke up, current count &quot; &lt;&lt; items_.size() &lt;&lt; std::endl;</span></div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// if (items_.size() &gt;= target_count) {</span></div>
<div class="line">        <span class="comment">//     std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Target count reached.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> notifyDataAdded() {</div>
<div class="line">        <span class="comment">// Деструктор Synchronized::Locker автоматически вызывает notify_one.</span></div>
<div class="line">        <span class="comment">// Для явного уведомления (например, всех) потребуется доступ к самой условной переменной.</span></div>
<div class="line">        <span class="comment">// Для этого шаблона вы обычно добавляете данные (что захватывает и освобождает блокировку),</span></div>
<div class="line">        <span class="comment">// и освобождение блокировки уведомляет одного ожидающего.</span></div>
<div class="line">        <span class="comment">// Если вам нужен notify_all, он не предоставляется напрямую только через LOCK_SCOPE для этого простого шаблона.</span></div>
<div class="line">        <span class="comment">// Класс Synchronized имеет m_cv.notify_all() в своем методе interrupt().</span></div>
<div class="line">        <span class="comment">// Этот пример полагается на неявное notify_one при уничтожении Locker.</span></div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Захват блокировки для обеспечения согласованности данных перед потенциальным уведомлением</span></div>
<div class="line">        <span class="comment">// (здесь нет изменения данных, но обычно вы изменяете данные перед уведомлением)</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;notifyDataAdded: Change occurred. Locker destruction will notify one waiter.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized() {</div>
<div class="line">    SafeDataContainer container;</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Apple&quot;</span>);</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; current_items = container.getItems();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : current_items) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Access count: &quot;</span> &lt;&lt; container.getAccessCount() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Концептуально: поток может ожидать условия</span></div>
<div class="line">    <span class="comment">// std::thread waiter([&amp;](){</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: waiting for 3 items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.waitUntilItemCountReaches(3, std::chrono::seconds(2));</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: finished waiting. Items: &quot; &lt;&lt; container.getItems().size() &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// std::thread adder([&amp;](){</span></div>
<div class="line">    <span class="comment">//    iridium::threading::sleep(500);</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Adder thread: adding &#39;Cherry&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.addItem(&quot;Cherry&quot;); // Это уведомит одного ожидающего через деструктор Locker</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// adder.join();</span></div>
<div class="line">    <span class="comment">// waiter.join();</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_synchronized_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a></div><div class="ttdoc">Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...</div><div class="ttdef"><b>Определения</b> synchronized.h:56</div></div>
<div class="ttc" id="asynchronized_8h_html"><div class="ttname"><a href="synchronized_8h.html">synchronized.h</a></div><div class="ttdoc">Определяет шаблон класса Synchronized для создания синхронизированных блоков кода и связанные вспомог...</div></div>
<div class="ttc" id="asynchronized_8h_html_aa07286a6c9966cc562c16a85887533fc"><div class="ttname"><a href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a></div><div class="ttdeci">#define LOCK_SCOPE()</div><div class="ttdoc">Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....</div><div class="ttdef"><b>Определения</b> synchronized.h:239</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_synchronized_logging"></a>
Логирование операций мьютекса</h2>
<p>Второй шаблонный параметр <code>is_tracable</code> в <code><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</code> можно установить в <code>true</code> для включения диагностического логирования операций мьютекса. Это может быть полезно для отладки проблем, связанных с блокировками, или для понимания поведения синхронизации в вашем приложении.</p>
<p>Когда трассировка включена, операции захвата и освобождения мьютекса, выполняемые через <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code>, будут выводить диагностическую информацию.</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized_traceable.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span> <span class="comment">// Для IThread::getNameStatic для контекста в выводе</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span> <span class="comment">// Для std::thread для демонстрации вывода</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс с возможностью трассировки операций мьютекса</span></div>
<div class="line"><span class="keyword">class </span>TraceableSafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex, true&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> doSomething() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Операции блокировки и разблокировки будут залогированы</span></div>
<div class="line">        <span class="comment">// ... какая-то работа с защищенными данными ...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;TraceableSafeDataContainer (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Executing doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized_traceable() {</div>
<div class="line">    TraceableSafeDataContainer container;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main thread (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;): Calling doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    container.doSomething();</div>
<div class="line"> </div>
<div class="line">    std::thread t1([&amp;]() {</div>
<div class="line">        <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a>(<span class="stringliteral">&quot;WorkerThread1&quot;</span>); <span class="comment">// Устанавливаем имя потока для лога</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;WorkerThread1 (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Calling doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        container.doSomething();</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    t1.join();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main thread (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;): WorkerThread1 finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">int main() {</span></div>
<div class="line"><span class="comment">    demo_synchronized_traceable();</span></div>
<div class="line"><span class="comment">    return 0;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_a065f967a26a86efde891ec209094560d"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a></div><div class="ttdeci">static void setNameStatic(std::string const &amp;name)</div><div class="ttdoc">Устанавливает имя для текущего выполняющегося потока (статически, в локальном хранилище потока)....</div><div class="ttdef"><b>Определения</b> thread.cpp:58</div></div>
</div><!-- fragment --><p>Когда используется <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code> с включенной трассировкой, операторы <code>printf</code> (или аналогичный механизм логирования низкого уровня, используемый реализацией) будут выводить информацию о захвате (<code>LM</code>) и освобождении (<code>UM</code>) мьютекса. Этот вывод обычно включает имя текущего потока (если установлено через <code><a class="el" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d" title="Устанавливает имя для текущего выполняющегося потока (статически, в локальном хранилище потока)....">iridium::threading::IThread::setNameStatic()</a></code>), исходный файл и номер строки, где была выполнена операция блокировки/разблокировки.</p>
<p>Пример ожидаемого формата вывода: </p><div class="fragment"><div class="line">ThreadName LM</div>
<div class="line">path/to/source.cpp:LINE_NUMBER</div>
<div class="line">TraceableSafeDataContainer (ThreadName): Executing doSomething.</div>
<div class="line">ThreadName UM</div>
<div class="line">path/to/source.cpp:LINE_NUMBER</div>
</div><!-- fragment --><p> Здесь <code>ThreadName</code> — это имя потока, <code>LM</code> означает "Lock Mutex" (захват мьютекса), а <code>UM</code> — "Unlock Mutex" (освобождение мьютекса). <code>path/to/source.cpp:LINE_NUMBER</code> указывает точное место в коде, где был вызван <code><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></code>.</p>
<p>Операции ожидания на объекте <code>Locker</code> (например, <code>wait()</code> или <code>wait(timeout)</code>) также логируются с маркером "WM" (Wait Mutex), предоставляя аналогичную контекстную информацию. Это помогает отслеживать, когда потоки начинают ожидать по условной переменной и когда они пробуждаются.</p>
<p>Класс <code><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></code> делает методы <code>SafeDataContainer</code> потокобезопасными. Деструктор <code>Locker</code> также вызывает <code>notify_one()</code> для внутренней условной переменной, которая может использоваться с методами <code>Locker::wait()</code>.</p>
<h2><a class="anchor" id="subsec_cworker"></a>
Использование CWorker для обработки задач</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html" title="Реализует IWorker для обработки элементов из входной очереди и помещения результатов в выходную очере...">iridium::threading::implementation::CWorker</a>&lt;TInputItem, TOutputItem&gt;</code> предоставляет один рабочий поток, который обрабатывает элементы из входной очереди и может помещать результаты в выходную очередь.</p>
<p><b>Интерфейс <code><a class="el" href="class_i_worker_1_1_i_handler.html">IWorker::IHandler</a></code>:</b> Вы определяете класс-обработчик, наследующий от <code><a class="el" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;TInputItem, TOutputItem&gt;::IHandler</code>. Его основной метод:</p><ul>
<li><code>TOutputItems handle(const TInputItems&amp; items)</code>: Получает список элементов из входной очереди и должен возвращать список выходных элементов.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworker.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2worker_8h.html">iridium/threading/implementation/worker.h</a>&quot;</span> <span class="comment">// Для CWorker</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// Для IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Для std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// Для toupper</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// Для std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Определение обработчика</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandler : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Initializing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Finalizing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line"> </div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Handler: Received &quot; &lt;&lt; items.size() &lt;&lt; &quot; items to process.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); }); <span class="comment">// Обеспечение приведения к char</span></div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_worker&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworker() {</div>
<div class="line">    <span class="keyword">auto</span> handler = std::make_shared&lt;ToUpperStringHandler&gt;();</div>
<div class="line">    <span class="keyword">auto</span> worker = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyStringToUpperWorker&quot;</span>, handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &#39;alpha&#39; and &#39;beta&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;push(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">        worker-&gt;push(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;gamma&quot;</span>});</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker&lt;std::string, std::string&gt;::TOutputItems</a> processed_batch;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// CWorkerRunnable обрабатывает по одному элементу из входной очереди за раз,</span></div>
<div class="line">        <span class="comment">// вызывает обработчик (который получает список из 1 элемента),</span></div>
<div class="line">        <span class="comment">// и обработчик возвращает список выходных элементов.</span></div>
<div class="line">        <span class="comment">// Таким образом, каждый вызов pop() будет извлекать результаты одного вызова handle().</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;alpha&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;<a class="code hl_function" href="classiridium_1_1threading_1_1_i_async_queue_popper.html#a69e6f12074937e6f482f8e688df03d2e">pop</a>(<span class="keyword">true</span>); <span class="comment">// true означает ожидание</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;beta&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;gamma&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: CWorker operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_async_queue_popper_html_a69e6f12074937e6f482f8e688df03d2e"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_async_queue_popper.html#a69e6f12074937e6f482f8e688df03d2e">iridium::threading::IAsyncQueuePopper::pop</a></div><div class="ttdeci">virtual TItems pop(bool const &amp;is_do_wait=true)=0</div><div class="ttdoc">Извлекает элементы из очереди. Извлекает один или несколько элементов из начала очереди....</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a></div><div class="ttdef"><b>Определения</b> worker.h:59</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker</a></div><div class="ttdoc">Реализует IWorker для обработки элементов из входной очереди и помещения результатов в выходную очере...</div><div class="ttdef"><b>Определения</b> worker.h:165</div></div>
<div class="ttc" id="aimplementation_2worker_8h_html"><div class="ttname"><a href="implementation_2worker_8h.html">worker.h</a></div><div class="ttdoc">Определяет реализации рабочих классов (CWorkerPusher, CWorkerPopper, CWorker), которые управляют пото...</div></div>
<div class="ttc" id="aworker_8h_html"><div class="ttname"><a href="worker_8h.html">worker.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_cworkerpool"></a>
Использование CWorkerPool для параллельной обработки задач</h2>
<p><code><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a>&lt;TInputItem, TOutputItem&gt;</code> управляет пулом из нескольких рабочих потоков для параллельной обработки элементов из общей входной очереди в общую выходную очередь.</p>
<p><b>Ключевые аспекты:</b></p><ul>
<li>Конструктор принимает список общих указателей <code>IHandler</code> (<code>THandlers</code>).</li>
<li>Помещенные элементы распределяются между рабочими потоками.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworkerpool.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker__pool_8h.html">iridium/threading/implementation/worker_pool.h</a>&quot;</span> <span class="comment">// Для CWorkerPool</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// Для IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// Для std::make_shared</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Для std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// Для toupper</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO </span><span class="comment">// Защита, если включено несколько раз</span></div>
<div class="line"><span class="preprocessor">#define TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandlerForPool : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string handler_id_;</div>
<div class="line">    ToUpperStringHandlerForPool(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>) : handler_id_(id) {}</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Init&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Final&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Handling &quot; &lt;&lt; items.size() &lt;&lt; &quot; items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); });</div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_pool_&quot;</span> + handler_id_);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworkerpool() {</div>
<div class="line">    <span class="keywordtype">int</span> num_pool_threads = 2;</div>
<div class="line">    std::list&lt;iridium::threading::IWorker&lt;std::string, std::string&gt;::IHandler::TSharedPtr&gt; handlers_list;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_pool_threads; ++i) {</div>
<div class="line">        handlers_list.push_back(std::make_shared&lt;ToUpperStringHandlerForPool&gt;(<span class="stringliteral">&quot;H&quot;</span> + std::to_string(i)));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> pool = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyDemoPool&quot;</span>, handlers_list);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::string&gt; all_tasks = {<span class="stringliteral">&quot;task1&quot;</span>, <span class="stringliteral">&quot;task2&quot;</span>, <span class="stringliteral">&quot;task3&quot;</span>, <span class="stringliteral">&quot;task4&quot;</span>, <span class="stringliteral">&quot;task5&quot;</span>};</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &quot; &lt;&lt; all_tasks.size() &lt;&lt; &quot; tasks to the pool.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;push(all_tasks); <span class="comment">// Помещение пакета. Они будут добавлены в общую входную очередь.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Сбор результатов. Каждый рабочий поток обрабатывает по одному элементу из входной очереди за раз,</span></div>
<div class="line">        <span class="comment">// его обработчик создает список выходных элементов, которые добавляются в выходную очередь пула.</span></div>
<div class="line">        <span class="comment">// Таким образом, мы ожидаем извлечь &#39;all_tasks.size()&#39; списков результатов.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; all_tasks.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> results_batch = pool-&gt;pop(<span class="keyword">true</span>); <span class="comment">// Ожидание пакета результатов от одного вызова обработчика</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; res : results_batch) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Pool result: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker pool finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Worker Pool operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_pool_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a></div><div class="ttdef"><b>Определения</b> worker_pool.h:89</div></div>
<div class="ttc" id="aworker__pool_8h_html"><div class="ttname"><a href="worker__pool_8h.html">worker_pool.h</a></div></div>
</div><!-- fragment --><p> <code><a class="el" href="class_c_worker_pool.html">CWorkerPool</a></code> эффективен для распараллеливания независимых задач. Порядок результатов из <code>pop</code> может не строго соответствовать порядку <code>push</code>.</p>
<p>Эти примитивы предоставляют фундаментальные инструменты для создания параллельных и многопоточных приложений с использованием Iridium.</p>
<h1><a class="anchor" id="sec_testing"></a>
Тестирование с Iridium</h1>
<p>Библиотека Iridium предоставляет встроенный фреймворк для написания и запуска модульных тестов, а также для создания мок-объектов для изоляции тестируемого кода. Этот фреймворк помогает обеспечить качество и надежность кода, разработанного с использованием Iridium.</p>
<h2><a class="anchor" id="subsec_testing_core_concepts"></a>
Основные концепции</h2>
<p>Фундаментом системы тестирования Iridium являются два ключевых интерфейса/класса:</p>
<ul>
<li><code><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Интерфейс для запускаемого тестового случая. Конкретные тестовые классы должны реализовывать этот инт...">iridium::testing::ITest</a></code> (определен в <code><a class="el" href="test_8h.html">iridium/testing/test.h</a></code>): Это базовый интерфейс для любого запускаемого тестового случая. Каждый класс, представляющий собой тест, должен реализовывать метод <code>virtual void run() = 0;</code>. В этом методе заключается логика самого теста, включая вызовы тестируемого кода и проверки утверждений (assertions).</li>
<li><code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> (определен в <code><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></code>): Этот класс служит базовым классом для ваших тестов (обычно неявно через макрос <code>TEST</code>). Он предоставляет набор методов для выполнения различных утверждений, таких как проверка равенства, сравнения, истинности условий или выбрасывания ожидаемых исключений. В случае провала утверждения, эти методы генерируют специальное исключение, которое сигнализирует о неудаче теста.</li>
</ul>
<h2><a class="anchor" id="subsec_testing_writing_tests"></a>
Написание тестов</h2>
<p>Основным инструментом для создания тестовых случаев в Iridium является макрос <code>TEST</code>.</p>
<h3><a class="anchor" id="subsubsec_testing_test_macro"></a>
Макрос TEST</h3>
<p>Макрос <code><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST(TestCaseName)</a></code> (определенный в <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>) используется для определения тестового случая. <code>TestCaseName</code> должно быть уникальным идентификатором для вашего теста. Этот макрос автоматически создает класс, наследующий <code><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Интерфейс для запускаемого тестового случая. Конкретные тестовые классы должны реализовывать этот инт...">iridium::testing::ITest</a></code> и <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code>, и регистрирует его в системе тестирования. Вам нужно только предоставить тело для метода <code>run()</code>, где будет содержаться логика теста.</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для TEST и макроса ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span>                   <span class="comment">// Для std::string в примере</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span>                <span class="comment">// Для std::runtime_error в примере</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert (если нужны свои типы в ASSERT)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример пользовательского типа для демонстрации вывода в ASSERT</span></div>
<div class="line"><span class="keyword">struct </span>MyCustomType {</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    std::string value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Для сравнения в тестах</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyCustomType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> == other.id &amp;&amp; value == other.value;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Специализация convert для MyCustomType, чтобы ASSERT мог ее печатать</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">std::string <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert</a>(MyCustomType <span class="keyword">const</span> &amp;obj) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyCustomType(id=&quot;</span> + <a class="code hl_function" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d">iridium::convertion::convert&lt;std::string&gt;</a>(obj.id) + <span class="stringliteral">&quot;, value=&quot;</span><span class="stringliteral">&quot; + obj.value + &quot;</span><span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример тестируемого класса (замените на свой)</span></div>
<div class="line"><span class="keyword">class </span>MyClassToTest {</div>
<div class="line">    std::string param_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassToTest(<span class="keyword">const</span> std::string&amp; p = <span class="stringliteral">&quot;&quot;</span>) : param_(p) {}</div>
<div class="line">    std::string getParameter()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> param_; }</div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
<div class="line">    MyCustomType getCustomType(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; val) { <span class="keywordflow">return</span> {id, val}; }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatThrows() { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Expected exception&quot;</span>); }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatDoesNotThrow() { <span class="comment">/* No-op */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassConstruction) {</div>
<div class="line">    MyClassToTest obj(<span class="stringliteral">&quot;test_param&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getParameter(), equal, <span class="stringliteral">&quot;test_param&quot;</span>); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassAddsNumbers) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(2, 3), equal, 5);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), greaterEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), lessEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(5, 5), greater, 9);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), less, 3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyCustomTypeAssertion) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    MyCustomType expected = {1, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getCustomType(1, <span class="stringliteral">&quot;hello&quot;</span>), equal, expected);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(BooleanAssertions) {</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">true</span>); <span class="comment">// Проверка истинности</span></div>
<div class="line">    <span class="keywordtype">bool</span> my_flag = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(!my_flag); <span class="comment">// Проверка ложности через отрицание</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassThrowsException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.doSomethingThatThrows(), std::runtime_error);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassDoesNotThrowException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <span class="keywordtype">bool</span> did_not_throw = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        obj.doSomethingThatDoesNotThrow();</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        did_not_throw = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(did_not_throw);</div>
<div class="line">}</div>
<div class="ttc" id="atester_8h_html"><div class="ttname"><a href="tester_8h.html">tester.h</a></div></div>
<div class="ttc" id="atester_8h_html_a45feb1f37ce559e49baf8655d769ef85"><div class="ttname"><a href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a></div><div class="ttdeci">#define TEST(name)</div><div class="ttdoc">Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...</div><div class="ttdef"><b>Определения</b> tester.h:153</div></div>
<div class="ttc" id="atester_8h_html_a821326052e3e2bf1fb2d678e9e9a6004"><div class="ttname"><a href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a></div><div class="ttdeci">#define ASSERT(...)</div><div class="ttdoc">Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...</div><div class="ttdef"><b>Определения</b> tester.h:218</div></div>
</div><!-- fragment --><h3><a class="anchor" id="subsubsec_testing_assertions"></a>
Макрос утверждений ASSERT</h3>
<p>Класс <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> (от которого неявно наследуются тесты, созданные макросом <code>TEST</code>) предоставляет различные методы для проверки условий. Основным способом их использования в тестах является макрос <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(...)</a></code> (определенный в <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>). Если утверждение не выполняется, выбрасывается исключение, и тест помечается как проваленный.</p>
<p>Макрос <code>ASSERT</code> является вариативным (принимает разное количество аргументов) и используется следующим образом:</p>
<ol type="1">
<li><b>Проверка булева условия: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(condition)</a></code></b><ul>
<li>Используется для проверки истинности (<code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(true_condition)</a>;</code>) или ложности (<code>ASSERT(!false_condition);</code>).</li>
<li>Технически, это вызов <code>ASSERT_1</code>, который передает <code>condition</code> в метод <code>UnitTest::assert_()</code>.</li>
<li>Пример: <code>ASSERT(x &gt; 5);</code></li>
</ul>
</li>
<li><b>Проверка на сравнение: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, comparison_symbol, value2)</a></code></b><ul>
<li>Используется для различных видов сравнений, где <code>value1</code> представляет ожидаемое значение, а <code>value2</code> — фактическое (полученное) значение. <code>comparison_symbol</code> — это имя метода сравнения из класса <code>UnitTest</code>.</li>
<li>При сравнении (<code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, comparison_symbol, value2)</a></code>), ожидаемое значение (<code>value1</code>) приводится к типу фактического значения (<code>value2</code>). Например, в шаблонных методах <code><a class="el" href="classiridium_1_1testing_1_1_unit_test.html">iridium::testing::UnitTest</a></code> (см. <code><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></code>) используется конструкция вида <code>TRight left_(left);</code> или <code>static_cast&lt;TRight&gt;(left)</code>, где <code>left</code> — это <code>value1</code> (ожидаемое), а <code>TRight</code> — это тип <code>value2</code> (фактическое). Таким образом, фактическое сравнение (<code>left_ == right</code>, <code>left_ &lt; right</code> и т.д.) происходит между значениями одного типа — типа <code>TRight</code>. Для преобразования значений в строки при выводе сообщений об ошибках используется <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a></code>.</li>
<li>Технически, это вызов <code>ASSERT_3</code>, который вызывает <code>UnitTest::comparison_symbol(value1, value2, "value1 symbol value2", "file:line")</code>.</li>
<li>Доступные <code>comparison_symbol</code>:<ul>
<li><code>equal</code>: Проверяет, что <code>value1 == value2</code>.</li>
<li><code>less</code>: Проверяет, что <code>value1 &lt; value2</code>.</li>
<li><code>lessEqual</code>: Проверяет, что <code>value1 &lt;= value2</code>.</li>
<li><code>greater</code>: Проверяет, что <code>value1 &gt; value2</code>.</li>
<li><code>greaterEqual</code>: Проверяет, что <code>value1 &gt;= value2</code>.</li>
</ul>
</li>
<li>Примеры: <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(sum, equal, 10);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(count, less, max_count);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(actual_value, greaterEqual, expected_minimum);</div>
</div><!-- fragment --></li>
<li>Примечание: Хотя вы также можете написать <code>ASSERT(value1 == value2);</code> (используя <code>ASSERT_1</code>), использование <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, equal, value2)</a>;</code> предпочтительнее для сравнений, так как это позволяет фреймворку потенциально выводить значения <code>value1</code> и <code>value2</code> при ошибке более информативно.</li>
</ul>
</li>
<li><b>Проверка на выбрасывание исключения: <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(expression, ExpectedExceptionType)</a></code></b><ul>
<li>Технически, это вызов <code>ASSERT_2</code>, который передает лямбда-функцию с <code>expression</code> и <code>ExpectedExceptionType</code> в метод <code>UnitTest::assert_&lt;TFunction, TException&gt;()</code>.</li>
<li>Проверяет, что выполнение <code>expression</code> приводит к выбрасыванию исключения типа <code>ExpectedExceptionType</code> (или его наследника).</li>
<li>Пример: <code>ASSERT(myObject.methodThatThrows(), std::runtime_error);</code></li>
</ul>
</li>
<li><b>Безусловный провал теста:</b><ul>
<li>Прямого макроса <code>FAIL(message)</code> нет. Для безусловного провала теста используйте <code><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(false)</a>;</code>. Вы можете добавить комментарий для пояснения причины. <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">false</span>); <span class="comment">// Тест провален, так как условие X не выполнено</span></div>
</div><!-- fragment --></li>
</ul>
</li>
</ol>
<p><b>Вывод значений при ошибках и <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a></code>:</b> Очень важной особенностью макроса <code>ASSERT</code> (особенно при сравнениях) является то, как он отображает значения при сбое утверждения. Чтобы вывести значения <code>value1</code> и <code>value2</code> (или значение из <code>condition</code> для <code>ASSERT_1</code>) в читаемом виде, система тестирования использует <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a>&lt;std::string&gt;(your_value)</code>. Если вы используете в <code>ASSERT</code> пользовательские типы, убедитесь, что для них существует специализация <code><a class="el" href="namespaceiridium_1_1convertion.html#a5afe4d5e065e8b085dcd6b8b391f2c2d" title="Предоставляет доступ к основной шаблонной функции преобразования из пространства имен реализации....">iridium::convertion::convert</a></code> в <code>std::string</code>. В противном случае, вы можете увидеть неинформативный вывод (например, только имя типа или адрес). Подробнее о создании специализаций <code>convert</code> см. в разделе <a class="el" href="#sec_custom_type_conversion">Интеграция пользовательских типов с <code>iridium::convertion::convert</code></a>.</p>
<p>Макрос <code>ASSERT</code> автоматически включает имя файла и номер строки в информацию об ошибке, что помогает быстро найти место провала теста.</p>
<h2><a class="anchor" id="subsec_testing_running_tests"></a>
Запуск тестов</h2>
<p>После написания тестов их необходимо скомпилировать и запустить. Фреймворк Iridium упрощает этот процесс.</p>
<h3><a class="anchor" id="subsubsec_testing_main"></a>
Макрос IMPLEMENT_TEST_MAIN</h3>
<p>Для создания исполняемого файла, который запустит все определенные тесты, используется макрос <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></code> (определенный в <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>). Этот макрос генерирует стандартную функцию <code>main()</code>, которая инициализирует и запускает тестовый фреймворк.</p>
<p>Обычно вы создаете отдельный <code>.cpp</code> файл (например, <code>tests_main.cpp</code>), который включает все ваши тестовые файлы (или заголовки, если тесты определены в них) и затем вызывает <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></code>.</p>
<p>Пример (<code>tests_main.cpp</code>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для IMPLEMENT_TEST_MAIN</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Включите здесь ваши тестовые файлы или файлы, где определены тесты TEST(...)</span></div>
<div class="line"><span class="comment">// Например:</span></div>
<div class="line"><span class="comment">// #include &quot;my_class_tests.cpp&quot; </span></div>
<div class="line"><span class="comment">// #include &quot;another_module_tests.cpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a>()</div>
<div class="ttc" id="atester_8h_html_ae18dbf9ed64402b9c94239f90547eceb"><div class="ttname"><a href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a></div><div class="ttdeci">#define IMPLEMENT_TEST_MAIN()</div><div class="ttdoc">Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...</div><div class="ttdef"><b>Определения</b> tester.h:230</div></div>
</div><!-- fragment --><p> При компиляции этого файла вместе с вашими тестами и библиотекой Iridium вы получите исполняемый файл, который при запуске выполнит все обнаруженные тесты.</p>
<h3><a class="anchor" id="subsubsec_testing_tester"></a>
Роль класса Tester</h3>
<p>Класс <code><a class="el" href="classiridium_1_1testing_1_1_tester.html" title="Класс-одиночка, отвечающий за регистрацию, управление и запуск всех тестов в рамках фреймворка....">iridium::testing::Tester</a></code> (определенный в <code><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></code>) является центральным компонентом системы тестирования. Это синглтон, который:</p><ul>
<li>Регистрирует все тестовые случаи, определенные с помощью макроса <code>TEST</code>.</li>
<li>Управляет выполнением тестов. Метод <code>Tester::run(argc, argv, main_cpp_path)</code> вызывается из сгенерированной <code>main()</code> функции.</li>
<li>Позволяет фильтровать тесты на основе аргументов командной строки (эта функциональность может быть не полностью детализирована здесь, но <code>Tester</code> ее предусматривает).</li>
<li>Собирает результаты тестов.</li>
</ul>
<h3><a class="anchor" id="subsubsec_testing_itestrunner"></a>
Интерфейс ITestRunner (для продвинутых сценариев)</h3>
<p>Для более гибкого управления процессом выполнения тестов существует интерфейс <code><a class="el" href="classiridium_1_1testing_1_1_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">iridium::testing::ITestRunner</a></code> (определенный в <code><a class="el" href="test__runner_8h.html">iridium/testing/test_runner.h</a></code>). Этот интерфейс абстрагирует способ запуска тестов. Библиотека Iridium предоставляет как минимум две его реализации:</p><ul>
<li><code>iridium::testing::implementation::TestRunnerRaw</code>: Запускает тесты в том же процессе.</li>
<li><code>iridium::testing::implementation::TestRunnerFork</code>: Может запускать тесты в отдельных процессах (форках), что обеспечивает лучшую изоляцию (обычно на POSIX-системах).</li>
</ul>
<p>Хотя прямое взаимодействие с <code><a class="el" href="class_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">ITestRunner</a></code> обычно не требуется для написания и запуска тестов, знание о его существовании полезно для понимания архитектуры фреймворка и для возможных расширений или кастомизации процесса тестирования. Класс <code>Tester</code> использует реализацию <code><a class="el" href="class_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">ITestRunner</a></code> для фактического выполнения тестов.</p>
<h3><a class="anchor" id="subsubsec_testing_cli"></a>
Аргументы командной строки</h3>
<p>Исполняемый файл тестов, созданный с помощью <code><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></code>, поддерживает следующие аргументы командной строки для управления процессом тестирования. Предположим, ваше приложение для тестов называется <code>ваше_приложение_тестов</code>.</p>
<ol type="1">
<li><b><code>help</code></b>: Выводит справочную информацию по использованию. <div class="fragment"><div class="line">./ваше_приложение_тестов help</div>
</div><!-- fragment --> Пример вывода: <div class="fragment"><div class="line">main thread: 281473424756000</div>
<div class="line">2025-06-06 10:30:56.839 I 281473424756000 </div>
<div class="line">usage:</div>
<div class="line">./ваше_приложение_тестов help</div>
<div class="line">./ваше_приложение_тестов list</div>
<div class="line">./ваше_приложение_тестов run [ --mode=raw|serial|parallel ] [ --print-result=json ] [ --timeout=seconds ] [ include_path ] [ exclude_path ] ... [ exclude_path ]</div>
<div class="line">example:</div>
<div class="line">./ваше_приложение_тестов run / </div>
</div><!-- fragment --> (Примечание: фактический номер потока и временная метка в вашем выводе будут отличаться.)</li>
<li><b><code>list</code></b>: Отображает иерархический список (дерево) всех тестовых случаев, обнаруженных фреймворком. Тесты группируются по пути к файлу и затем по имени теста, определенному в макросе <code><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST()</a></code>. <div class="fragment"><div class="line">./ваше_приложение_тестов list</div>
</div><!-- fragment --> Это полезно для просмотра структуры тестов и их полных путей, которые могут использоваться в качестве <code>путь_включения</code> или <code>путь_исключения</code> для команды <code>run</code>. Пример вывода: <div class="fragment"><div class="line">main thread: 281473794346272</div>
<div class="line">2025-06-06 10:30:22.166 I 281473794346272 </div>
<div class="line"><span class="stringliteral">&#39;root&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;convertion&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;convert.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;enum_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;strings&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;types&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;testing&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;example.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;bool_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;comparing_equal&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;mock&#39;</span></div>
<div class="line"><span class="preprocessor">  # ... (и так далее для других модулей и тестов)</span></div>
</div><!-- fragment --> (Примечание: фактический номер потока, временная метка и полный список тестов в вашем выводе будут отличаться.)</li>
<li><p class="startli"><b><code>run</code></b>: Запускает тесты. Это команда по умолчанию, если не указана другая. </p><div class="fragment"><div class="line">./ваше_приложение_тестов run [опции] [путь_включения] [путь_исключения_1] [путь_исключения_2] ...</div>
</div><!-- fragment --><p> Стандартный вывод при запуске тестов (без <code>--print-result=json</code>) включает логирование каждого запускаемого теста и его результата: </p><div class="fragment"><div class="line">main thread: 281473243745568</div>
<div class="line">2025-06-06 10:30:39.744 I 281473243745568 RUN  /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 RUN  /testing/example.cpp/comparing_equal</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/comparing_equal</div>
<div class="line"><span class="preprocessor"># ... (и так далее для других тестов)</span></div>
<div class="line"><span class="preprocessor"># ... (в случае ошибки будет FAILED вместо OK и сообщение об ошибке)</span></div>
<div class="line">2025-06-06 10:30:39.747 I 281473243745568 </div>
<div class="line">passed: 8</div>
<div class="line">failed: 0</div>
<div class="line">total:  51 </div>
</div><!-- fragment --><p> (Примечание: фактические номера потоков, временные метки и результаты в вашем выводе будут отличаться.)</p>
<p class="startli">Доступные опции для команды <code>run</code>:</p><ul>
<li><code>--mode=РЕЖИМ</code>: Определяет режим запуска тестов. Возможные значения для <code>РЕЖИМ</code>:<ul>
<li><code>raw</code> (по умолчанию): Тесты запускаются в том же процессе.</li>
<li><code>serial</code>: Тесты запускаются последовательно, каждый в отдельном процессе.</li>
<li><code>parallel</code>: Тесты запускаются параллельно в отдельных процессах.</li>
</ul>
</li>
<li><code>--print-result=ФОРМАТ</code>: Управляет форматом вывода результатов.<ul>
<li>Если не указана, используется стандартный текстовый формат (см. пример выше).</li>
<li><code>json</code>: Результаты выводятся в формате JSON.</li>
</ul>
</li>
<li><code>--timeout=СЕКУНДЫ</code>: Устанавливает максимальное время ожидания для тестов в секундах (по умолчанию 60).</li>
</ul>
<p class="startli">Параметры команды <code>run</code>:</p><ul>
<li><code>путь_включения</code> (необязательный): Если указан, запускаются только тесты, чей путь (как в выводе <code>list</code>) начинается с <code>путь_включения</code>. По умолчанию <code>/</code> (все тесты).</li>
<li><code>путь_исключения_...</code> (необязательные): Один или несколько путей для исключения. Тесты, чей путь начинается с одного из этих путей, не будут запущены.</li>
</ul>
</li>
</ol>
<p>Примеры использования команды <code>run</code>:</p>
<ul>
<li>Запустить все тесты: <div class="fragment"><div class="line">./ваше_приложение_тестов run</div>
</div><!-- fragment --> (или просто <code>./ваше_приложение_тестов</code>)</li>
<li>Запустить все тесты в параллельном режиме с таймаутом 120 секунд: <div class="fragment"><div class="line">./ваше_приложение_тестов run --mode=parallel --timeout=120</div>
</div><!-- fragment --></li>
<li>Запустить только тесты из модуля <code>testing</code> и файла <code>example.cpp</code>: <div class="fragment"><div class="line">./ваше_приложение_тестов run /testing/example.cpp/</div>
</div><!-- fragment --></li>
<li>Запустить все тесты из модуля <code>parsing</code>, но исключить те, что находятся в <code>node.cpp</code> внутри <code>parsing</code>: <div class="fragment"><div class="line">./ваше_приложение_тестов run /parsing/ /parsing/node.cpp/</div>
</div><!-- fragment --></li>
<li>Запустить все тесты и вывести результат в формате JSON: <div class="fragment"><div class="line">./ваше_приложение_тестов run --print-result=json</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="subsec_testing_mocking"></a>
Мокирование зависимостей</h2>
<p>Мокирование (от англ. mocking) — это процесс создания объектов-заменителей (моков или мок-объектов) для имитации поведения реальных зависимостей тестируемого компонента. Это позволяет изолировать тестируемый код и сделать тесты более предсказуемыми и стабильными. Фреймворк тестирования Iridium предоставляет инструменты для создания моков (определенные в <code><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></code>).</p>
<h3><a class="anchor" id="subsubsec_testing_defining_mocks"></a>
Определение мок-классов</h3>
<p>Для создания мока для интерфейса или класса используется макрос <code><a class="el" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee" title="Определяет мок-класс с именем Interface##Mock, который наследует от Interface и iridium::testing::Moc...">DEFINE_MOCK_CLASS(InterfaceName)</a></code>. Этот макрос создает новый класс с именем <code>InterfaceNameMock</code>, который наследует ваш <code>InterfaceName</code> и <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для создания мок-объектов. Для создания мока для интерфейса или класса TClass,...">iridium::testing::Mock</a>&lt;InterfaceName&gt;</code>.</p>
<p>Внутри этого мок-класса вы объявляете, какие методы интерфейса вы хотите мокировать, используя макросы <code>DEFINE_MOCK_METHOD</code> (для неконстантных методов) и <code>DEFINE_MOCK_METHOD_CONST</code> (для константных методов).</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Предположим, это интерфейс, который мы хотим мокировать</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="comment">// Конструктор с аргументами для демонстрации DEFINE_MOCK_CONSTRUCTOR</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; <span class="comment">// Добавим конструктор по умолчанию, если он тоже нужен</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение мок-класса для IMyDependency</span></div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Если базовый класс IMyDependency имеет конструктор с аргументами,</span></div>
<div class="line">    <span class="comment">// и вы хотите его вызывать из мока:</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Мокирование методов интерфейса</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)          <span class="comment">// int getValue(int key)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)  <span class="comment">// std::string getName() const</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;) <span class="comment">// void processData(const std::vector&lt;int&gt;&amp; data)</span></div>
<div class="line">};</div>
<div class="ttc" id="amock_8h_html"><div class="ttname"><a href="mock_8h.html">mock.h</a></div></div>
<div class="ttc" id="amock_8h_html_a1aa823f3557d4e07d5a6cce9bb497aee"><div class="ttname"><a href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a></div><div class="ttdeci">#define DEFINE_MOCK_CLASS(Interface)</div><div class="ttdoc">Определяет мок-класс с именем Interface##Mock, который наследует от Interface и iridium::testing::Moc...</div><div class="ttdef"><b>Определения</b> mock.h:760</div></div>
<div class="ttc" id="amock_8h_html_a45da68ed3f119848c88d8ef01622bcec"><div class="ttname"><a href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD(...)</div><div class="ttdoc">Макрос-переключатель для определения переопределений неконстантных мок-методов, диспетчеризующий в DE...</div><div class="ttdef"><b>Определения</b> mock.h:682</div></div>
<div class="ttc" id="amock_8h_html_a4d8f3f37a1da67b31d455e5086be40f3"><div class="ttname"><a href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a></div><div class="ttdeci">#define DEFINE_MOCK_CONSTRUCTOR(Interface)</div><div class="ttdoc">Определяет конструктор для мок-класса (Interface##Mock), который передает свои аргументы конструктору...</div><div class="ttdef"><b>Определения</b> mock.h:769</div></div>
<div class="ttc" id="amock_8h_html_ae47eed5af62161b8cb04261fded66530"><div class="ttname"><a href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD_CONST(...)</div><div class="ttdoc">Макрос-переключатель для определения переопределений константных мок-методов, диспетчеризующий в DEFI...</div><div class="ttdef"><b>Определения</b> mock.h:751</div></div>
</div><!-- fragment --><p> Макросы <code>DEFINE_MOCK_METHOD</code> принимают тип возвращаемого значения, имя метода и в круглых скобках типы аргументов метода (без имен переменных).</p>
<h3><a class="anchor" id="subsubsec_testing_mock_behavior"></a>
Определение поведения моков</h3>
<p>После создания экземпляра мок-объекта вы можете определить его поведение с помощью макроса <code>DEFINE_MOCK_BEHAVIOR</code> (для неконстантных методов) или <code>DEFINE_MOCK_BEHAVIOR_CONST</code> (для константных методов). Этот макрос позволяет присвоить лямбда-функцию, которая будет вызываться при обращении к мокированному методу.</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span>   <span class="comment">// Для макросов мокирования</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// Для std::runtime_error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Для полноты примера, скопируем определения IMyDependency и IMyDependencyMock сюда</span></div>
<div class="line"><span class="comment">// В реальном коде они были бы в заголовочных файлах</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;)</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Конец скопированных определений</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс, который использует IMyDependency</span></div>
<div class="line"><span class="keyword">class </span>MyClassUsesDependency {</div>
<div class="line">    IMyDependency* dependency_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassUsesDependency(IMyDependency* dep) : dependency_(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> fetchValue(<span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Key cannot be negative&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getValue(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string getDepName()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getName();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> sendData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) {</div>
<div class="line">        dependency_-&gt;processData(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassUsesDependency_Behavior) {</div>
<div class="line">    IMyDependencyMock mockDep; <span class="comment">// Создаем экземпляр мока</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем поведение для getValue</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, <span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="comment">// Это лямбда-функция: [=](int key_param) -&gt; int { ... }</span></div>
<div class="line">        <span class="comment">// Имена параметров в лямбде могут быть любыми, но типы должны совпадать с объявленными в DEFINE_MOCK_METHOD</span></div>
<div class="line">        <span class="keywordflow">if</span> (key == 1) <span class="keywordflow">return</span> 100;</div>
<div class="line">        <span class="keywordflow">if</span> (key == 42) <span class="keywordflow">return</span> 420;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем поведение для getName (константный метод)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a>(std::string, getName, mockDep) {</div>
<div class="line">        <span class="comment">// Лямбда для метода без аргументов: [=]() -&gt; std::string { ... }</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;MockedName&quot;</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Определяем поведение для processData (void метод)</span></div>
<div class="line">    std::vector&lt;int&gt; received_data;</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;data) {</div>
<div class="line">        <span class="comment">// Лямбда для void метода: [=](const std::vector&lt;int&gt;&amp; data_param) -&gt; void { ... }</span></div>
<div class="line">        received_data = data; <span class="comment">// Копируем данные для проверки</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClassUsesDependency mainObj(&amp;mockDep);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(1),   equal, 100);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(42),  equal, 420);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(10),  equal, -1);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.getDepName(),    equal, <span class="stringliteral">&quot;MockedName&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int&gt; data_to_send = {1, 2, 3};</div>
<div class="line">    mainObj.sendData(data_to_send);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data.size(),    equal, 3);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data[0],        equal, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Проверка вызова исключения из основного класса, не из мока</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(-1), std::runtime_error);</div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_a8178900fca49688815d093d8c46b1c15"><div class="ttname"><a href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR_CONST(result_type, method_name, mock_object,...)</div><div class="ttdoc">Устанавливает поведение для константного мокированного метода. Аналогичен DEFINE_MOCK_BEHAVIOR,...</div><div class="ttdef"><b>Определения</b> mock.h:814</div></div>
<div class="ttc" id="amock_8h_html_aed1edc22e98dd2dc94c0368764223576"><div class="ttname"><a href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR(result_type, method_name, mock_object,...)</div><div class="ttdoc">Устанавливает поведение для неконстантного мокированного метода. Этот макрос используется для указани...</div><div class="ttdef"><b>Определения</b> mock.h:790</div></div>
</div><!-- fragment --><p> В лямбда-функции, определяющей поведение, вы можете получить доступ к аргументам, с которыми был вызван мокированный метод, и вернуть соответствующее значение или выполнить необходимые действия. Типы аргументов в лямбде должны совпадать с типами, указанными в <code>DEFINE_MOCK_METHOD</code>.</p>
<p>Использование <code>DEFINE_MOCK_CONSTRUCTOR</code> необходимо, если ваш исходный интерфейс/класс имеет конструкторы с параметрами, которые вы хотите вызывать при создании мок-объекта (например, если мок наследует от класса, а не чистого интерфейса, и конструктор базового класса должен быть вызван).</p>
<h3><a class="anchor" id="subsubsec_testing_mock_auto_creation"></a>
Автоматическое создание и предоставление мок-объектов через <code>create()</code></h3>
<p>Фреймворк Iridium предоставляет механизм, позволяющий статическим методам <code>create()</code> возвращать мок-объекты вместо реальных во время тестирования. Это особенно полезно, когда тестируемый класс создает свои зависимости внутри себя. Понимание этого механизма требует рассмотрения нескольких макросов и пользовательских соглашений.</p>
<p><b>Ключевые макросы и их взаимодействие:</b></p>
<ol type="1">
<li><b><code>DEFINE_MOCK_CREATE</code> (символ препроцессора):</b><ul>
<li>Это <b>символ препроцессора</b>, который пользователи должны определять для своих тестовых сборок. Это можно сделать, например, добавив <code>#define DEFINE_MOCK_CREATE</code> в начале тестового файла (до включения заголовочных файлов Iridium, таких как <code><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></code>) или через опцию компилятора (например, <code>-DDEFINE_MOCK_CREATE</code>).</li>
<li>Макрос Iridium <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса TClass. Если DEFINE_MOCK_CREATE не определен...">DEFINE_CREATE(TClass)</a></code> (находящийся в <code><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></code>) использует директиву препроцессора <code>#ifdef DEFINE_MOCK_CREATE</code> для условной компиляции статического метода <code>TClass::create(...)</code>.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса TClass. Если DEFINE_MOCK_CREATE не определен...">DEFINE_CREATE(TClass)</a></code> (макрос Iridium из <code><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>Этот макрос генерирует статический метод <code>TClass::create(...)</code>.</li>
<li>Благодаря проверке <code>#ifdef DEFINE_MOCK_CREATE</code> внутри <code>DEFINE_CREATE</code>:<ul>
<li>Если <code>DEFINE_MOCK_CREATE</code> определен на момент обработки <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса TClass. Если DEFINE_MOCK_CREATE не определен...">DEFINE_CREATE(TClass)</a></code>, то результирующий метод <code>TClass::create(...)</code> будет вызывать <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для создания мок-объектов. Для создания мока для интерфейса или класса TClass,...">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</code>.</li>
<li>Если <code>DEFINE_MOCK_CREATE</code> <em>не</em> определен, то <code>TClass::create(...)</code> будет вызывать <code>std::make_shared&lt;TClass&gt;(...)</code> для создания реального объекта.</li>
</ul>
</li>
</ul>
</li>
<li><b><code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для создания мок-объектов. Для создания мока для интерфейса или класса TClass,...">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</code> (из <code><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></code>):</b><ul>
<li>Этот метод вызывается, когда <code>TClass::create(...)</code> был сгенерирован в "мок-режиме" (благодаря <code>DEFINE_MOCK_CREATE</code>).</li>
<li>Он проверяет внутренний статический флаг <code>Mock&lt;TClass&gt;::m_is_mocked</code>.</li>
<li>Если <code>m_is_mocked == true</code> (этот флаг устанавливается при создании экземпляра мок-класса, например, <code>TClassMock</code>), то <code>Mock&lt;TClass&gt;::create(...)</code> пытается вернуть ранее зарегистрированный экземпляр <code>TClassMock</code>. Если подходящих моков нет, выбрасывается исключение.</li>
<li>Если <code>m_is_mocked == false</code>, то <code>Mock&lt;TClass&gt;::create(...)</code> пытается создать реальный объект через <code>std::make_shared&lt;TClass&gt;(...)</code>. <b>Важно:</b> если <code>TClass</code> является абстрактным интерфейсом, эта попытка приведет к ошибке компиляции.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...">DEFINE_IMPLEMENTATION(TClass)</a></code> (из <code><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>Этот макрос Iridium используется для конкретных классов. Он внутри себя вызывает <code><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса TClass. Если DEFINE_MOCK_CREATE не определен...">DEFINE_CREATE(TClass)</a></code>.</li>
<li>Следовательно, статический метод <code>create()</code> для классов, определенных с <code>DEFINE_IMPLEMENTATION</code>, будет автоматически поддерживать переключение между реальным созданием и мок-созданием в зависимости от наличия <code>DEFINE_MOCK_CREATE</code>.</li>
</ul>
</li>
<li><b><code><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE(Interface)</a></code> (из <code><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></code>):</b><ul>
<li>Этот макрос Iridium используется для определения интерфейсов. Он определяет typedef-ы для умных указателей и виртуальный деструктор.</li>
<li><b>Важно:</b> <code>DEFINE_INTERFACE</code> <b>не использует</b> <code>DEFINE_CREATE</code>. Таким образом, интерфейсы, определенные только с <code>DEFINE_INTERFACE</code>, не получают автоматически статический метод <code>create()</code>, управляемый <code>DEFINE_MOCK_CREATE</code>.</li>
</ul>
</li>
</ol>
<p><b>Сценарии использования:</b></p>
<ul>
<li><b>Мокирование конкретного класса:</b> Если у вас есть конкретный класс <code>CMyImpl</code>, определенный с <code><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...">DEFINE_IMPLEMENTATION(CMyImpl)</a></code>, и вы определяете <code>DEFINE_MOCK_CREATE</code> в вашем тесте, то вызов <code>CMyImpl::create(...)</code> автоматически перенаправится на <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для создания мок-объектов. Для создания мока для интерфейса или класса TClass,...">iridium::testing::Mock</a>&lt;CMyImpl&gt;::create(...)</code>. Затем, если вы создали экземпляр <code>CMyImplMock</code>, он будет предоставлен.</li>
<li><b>Мокирование через интерфейс:</b> Если вы хотите, чтобы <code>IMyInterface::create(...)</code> возвращал мок, а <code>IMyInterface</code> определен только с <code>DEFINE_INTERFACE</code>, вам нужно <b>самостоятельно реализовать</b> статический метод <code>IMyInterface::create(...)</code>. В этой вашей реализации вы можете использовать <code>DEFINE_MOCK_CREATE</code> (или другой ваш флаг) для выбора между <code>std::make_shared&lt;CMyRealImpl&gt;(...)</code> и <code><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для создания мок-объектов. Для создания мока для интерфейса или класса TClass,...">iridium::testing::Mock</a>&lt;IMyInterface&gt;::create(...)</code>.</li>
</ul>
<p><b>Пример (мокирование конкретной реализации, как в <code>iridium-test/testing/example.cpp</code>):</b></p>
<div class="fragment"><div class="line"><span class="comment">// --- Начало примера кода ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Включаем заголовки Iridium. Порядок важен, если `DEFINE_MOCK_CREATE` влияет на них.</span></div>
<div class="line"><span class="comment">// В данном случае, `DEFINE_MOCK_CREATE` должен быть определен до smart_ptr.h, где находится DEFINE_CREATE.</span></div>
<div class="line"><span class="comment">// Для этого примера, мы разместим DEFINE_MOCK_CREATE прямо в &quot;тестовом файле&quot;.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: IDataService.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// Для DEFINE_INTERFACE</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IDataService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a>(IDataService); <span class="comment">// Не создает IDataService::create()</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: CDataServiceImpl.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;IDataService.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// Для DEFINE_IMPLEMENTATION</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CDataServiceImpl : <span class="keyword">public</span> IDataService {</div>
<div class="line">    std::string m_serviceName;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Конструктор для реальной реализации</span></div>
<div class="line">    CDataServiceImpl(<span class="keyword">const</span> std::string&amp; name) : m_serviceName(name) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// DEFINE_IMPLEMENTATION включает DEFINE_CREATE, который будет учитывать DEFINE_MOCK_CREATE</span></div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a>(CDataServiceImpl);</div>
<div class="line"> </div>
<div class="line">    std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Real data for id &quot;</span> + std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot; from &quot;</span> + m_serviceName;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: CDataServiceImplMock.h (или прямо в тестовом .cpp)</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Мокируем конкретный класс</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(CDataServiceImpl) { <span class="comment">// Создает CDataServiceImplMock</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Так как CDataServiceImpl имеет конструктор с параметрами,</span></div>
<div class="line">    <span class="comment">// мок должен его вызвать через DEFINE_MOCK_CONSTRUCTOR.</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(CDataServiceImpl)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(std::string, fetchData, <span class="keywordtype">int</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: DataConsumer.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Зависит от конкретной реализации для вызова CDataServiceImpl::create()</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataConsumer {</div>
<div class="line">    std::shared_ptr&lt;CDataServiceImpl&gt; m_dataService; <span class="comment">// Использует конкретный класс</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataConsumer() {</div>
<div class="line">        <span class="comment">// Вызываем CDataServiceImpl::create(), который будет управляться DEFINE_MOCK_CREATE</span></div>
<div class="line">        m_dataService = CDataServiceImpl::create(<span class="stringliteral">&quot;MyRealService&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string processData(<span class="keywordtype">int</span> recordId) {</div>
<div class="line">        <span class="keywordflow">if</span> (!m_dataService) <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error: Service not created&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Consumed: &quot;</span> + m_dataService-&gt;fetchData(recordId);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: test_main.cpp (или ваш тестовый файл)</span></div>
<div class="line"><span class="comment">// ЭТО КЛЮЧЕВОЙ МОМЕНТ: DEFINE_MOCK_CREATE должен быть определен ПЕРЕД включением</span></div>
<div class="line"><span class="comment">// iridium/smart_ptr.h, если он должен повлиять на DEFINE_CREATE в нем.</span></div>
<div class="line"><span class="comment">// В данном случае, для простоты, мы предполагаем, что заголовки CDataServiceImpl.h</span></div>
<div class="line"><span class="comment">// (который тянет smart_ptr.h) будут обработаны компилятором уже после этого дефайна.</span></div>
<div class="line"><span class="preprocessor">#define DEFINE_MOCK_CREATE</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;DataConsumer.h&quot;       // Уже включены концептуально выше</span></div>
<div class="line"><span class="comment">// #include &quot;CDataServiceImplMock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(DataConsumer_UsesMockService) {</div>
<div class="line">    <span class="comment">// 1. Создаем экземпляр мока CDataServiceImplMock.</span></div>
<div class="line">    <span class="comment">//    Это действие установит Mock&lt;CDataServiceImpl&gt;::m_is_mocked = true;</span></div>
<div class="line">    <span class="comment">//    и зарегистрирует данный mockService в списке доступных моков.</span></div>
<div class="line">    <span class="comment">//    Передаем аргумент конструктора, как и для реального CDataServiceImpl.</span></div>
<div class="line">    CDataServiceImplMock mockService(<span class="stringliteral">&quot;MockedServiceInstance&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Задаем поведение для мок-метода fetchData</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(std::string, fetchData, mockService, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 101) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;mocked_payload_for_101&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;generic_mock_payload&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Создаем DataConsumer. Его конструктор вызовет CDataServiceImpl::create(&quot;MyRealService&quot;).</span></div>
<div class="line">    <span class="comment">//    Поскольку DEFINE_MOCK_CREATE активен, CDataServiceImpl::create() был сгенерирован так,</span></div>
<div class="line">    <span class="comment">//    чтобы вызвать iridium::testing::Mock&lt;CDataServiceImpl&gt;::create(...).</span></div>
<div class="line">    <span class="comment">//    Так как mockService (типа CDataServiceImplMock) был создан и зарегистрирован,</span></div>
<div class="line">    <span class="comment">//    он будет возвращен (аргумент &quot;MyRealService&quot; будет использован конструктором мока, если он его принимает,</span></div>
<div class="line">    <span class="comment">//    или проигнорирован, если Mock&lt;T&gt;::create так решит для моков).</span></div>
<div class="line">    DataConsumer consumer;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Проверяем, что DataConsumer получил и использует мокированные данные</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(101), equal, <span class="stringliteral">&quot;Consumed: mocked_payload_for_101&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(200), equal, <span class="stringliteral">&quot;Consumed: generic_mock_payload&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// --- Конец примера кода ---</span></div>
<div class="ttc" id="asmart__ptr_8h_html"><div class="ttname"><a href="smart__ptr_8h.html">smart_ptr.h</a></div><div class="ttdoc">Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...</div></div>
<div class="ttc" id="asmart__ptr_8h_html_a5314379c214998b38c9b5d50b1e1ac9d"><div class="ttname"><a href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a></div><div class="ttdeci">#define DEFINE_INTERFACE(TClass)</div><div class="ttdoc">Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...</div><div class="ttdef"><b>Определения</b> smart_ptr.h:96</div></div>
<div class="ttc" id="asmart__ptr_8h_html_ad4d8992039d0faf9ae66c4f596277280"><div class="ttname"><a href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a></div><div class="ttdeci">#define DEFINE_IMPLEMENTATION(TClass)</div><div class="ttdoc">Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...</div><div class="ttdef"><b>Определения</b> smart_ptr.h:110</div></div>
</div><!-- fragment --><p><b>Итог по интерфейсам:</b></p>
<p>Если вы хотите получить мок для интерфейса <code>IExample</code> через вызов <code>IExample::create()</code>, то, поскольку <code>DEFINE_INTERFACE</code> не предоставляет <code>create()</code>, вы должны написать этот метод сами. Например:</p>
<div class="fragment"><div class="line"><span class="comment">// В IExample.h или IExample.cpp</span></div>
<div class="line"><span class="comment">// #include &quot;CRealExampleImpl.h&quot; // Ваша реальная реализация</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/testing/mock.h&quot; // Для Mock&lt;IExample&gt;::create()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::shared_ptr&lt;IExample&gt; IExample::create() { // Предполагаем, что вы объявили static create() в IExample</span></div>
<div class="line"><span class="comment">// #ifdef USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</span></div>
<div class="line"><span class="comment">//     return iridium::testing::Mock&lt;IExample&gt;::create();</span></div>
<div class="line"><span class="comment">// #else</span></div>
<div class="line"><span class="comment">//     return std::make_shared&lt;CRealExampleImpl&gt;();</span></div>
<div class="line"><span class="comment">// #endif</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><p> В этом случае, <code>DEFINE_MOCK_CREATE</code> напрямую не используется Iridium для <code>IExample::create()</code>, но вы можете использовать его или аналогичный флаг (<code>USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</code>) в вашей собственной реализации <code>IExample::create()</code>.</p>
<p>Эта детальная информация должна корректно отражать механизм мокирования при использовании <code>create()</code> в Iridium.</p>
<h2><a class="anchor" id="subsec_testing_sequences"></a>
Тестирование последовательностей вызовов</h2>
<p>Иногда важно не только то, какие методы мок-объекта вызываются, но и в каком порядке это происходит. Фреймворк мокирования Iridium предоставляет средства для определения и проверки последовательностей вызовов.</p>
<h3><a class="anchor" id="subsubsec_testing_defining_sequences"></a>
Определение последовательности (DEFINE_MOCK_SEQUENCE)</h3>
<p>Макрос <code><a class="el" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27" title="Определяет объект MockSequence для проверки упорядоченных ожиданий.">DEFINE_MOCK_SEQUENCE(sequence_name, mock_object)</a></code> используется для создания объекта последовательности.</p><ul>
<li><code>sequence_name</code>: Имя, которое вы даете этой последовательности (будет создана переменная <code>sequence_&lt;sequence_name&gt;</code>).</li>
<li><code>mock_object</code>: Экземпляр мок-объекта, для которого вы определяете последовательность вызовов.</li>
</ul>
<p>Этот макрос должен вызываться в начале вашего теста, где вы хотите определить ожидания по порядку вызовов.</p>
<h3><a class="anchor" id="subsubsec_testing_sequence_expectations"></a>
Ожидания в последовательности (DEFINE_MOCK_SEQUENCE_EXPECTATION)</h3>
<p>После определения объекта последовательности, вы добавляете в нее ожидаемые вызовы с помощью макроса <code><a class="el" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57" title="Добавляет ожидание в MockSequence. Этот макрос, вероятно, предназначен для использования в цепочке вы...">DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock_object, method_name, arg1, arg2, ...)</a></code>.</p><ul>
<li><code>sequence_name</code>: Имя ранее определенной последовательности.</li>
<li><code>mock_object</code>: Тот же мок-объект.</li>
<li><code>method_name</code>: Имя мокированного метода, который должен быть вызван.</li>
<li><code>(arg1, arg2, ...)</code>: Ожидаемые аргументы для этого вызова, заключенные в круглые скобки.</li>
</ul>
<p>Каждый вызов <code>DEFINE_MOCK_SEQUENCE_EXPECTATION</code> добавляет одно ожидание в указанную последовательность. Порядок этих макросов определяет ожидаемый порядок вызовов методов.</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Для полноты примера, определим IMyDependency и его мок здесь же.</span></div>
<div class="line"><span class="comment">// В реальном коде они были бы в заголовочных файлах.</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> setup() = 0; <span class="comment">// Новый метод для демонстрации последовательности</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt;&amp;)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, setup) <span class="comment">// Мок для нового метода</span></div>
<div class="line">};</div>
<div class="line"><span class="comment">// Конец определений IMyDependency и мока</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс, демонстрирующий вызовы в определенной последовательности</span></div>
<div class="line"><span class="keyword">class </span>ServiceWithOrderedCalls {</div>
<div class="line">    IMyDependency* dep_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ServiceWithOrderedCalls(IMyDependency* dep) : dep_(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initializeAndGetData(<span class="keywordtype">int</span> val_key) {</div>
<div class="line">        dep_-&gt;setup(); <span class="comment">// Первый ожидаемый вызов</span></div>
<div class="line">        std::vector&lt;int&gt; data_vec = {val_key, val_key * 2};</div>
<div class="line">        dep_-&gt;processData(data_vec); <span class="comment">// Второй ожидаемый вызов</span></div>
<div class="line">        dep_-&gt;getValue(val_key); <span class="comment">// Третий ожидаемый вызов</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(ServiceOrderedTest) {</div>
<div class="line">    IMyDependencyMock mockDep;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем поведение для методов, чтобы они просто работали</span></div>
<div class="line">    <span class="comment">// (для проверки последовательности важно, чтобы вызовы происходили,</span></div>
<div class="line">    <span class="comment">// а не что они возвращают, если это не часть логики теста)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, setup, mockDep) {};</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;data) {};</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, <span class="keywordtype">int</span> key) { <span class="keywordflow">return</span> key + 1; };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем последовательность &#39;s1&#39; для объекта &#39;mockDep&#39;</span></div>
<div class="line">    <span class="comment">// Имя объекта последовательности будет sequence_s1</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27">DEFINE_MOCK_SEQUENCE</a>(s1, mockDep); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Добавляем ожидания в последовательность s1</span></div>
<div class="line">    <span class="comment">// Ожидается вызов mockDep.setup() без аргументов</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, setup); </div>
<div class="line">    <span class="comment">// Ожидается вызов mockDep.processData() с конкретным вектором</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, processData, {10, 20}); </div>
<div class="line">    <span class="comment">// Ожидается вызов mockDep.getValue() с аргументом 10</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a>(s1, mockDep, getValue, 10); </div>
<div class="line"> </div>
<div class="line">    ServiceWithOrderedCalls service(&amp;mockDep);</div>
<div class="line">    service.initializeAndGetData(10); <span class="comment">// Этот метод должен вызвать методы mockDep в указанном порядке</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Проверка последовательности происходит автоматически. Если порядок нарушен,</span></div>
<div class="line">    <span class="comment">// или один из ожидаемых вызовов не произошел в нужном месте,</span></div>
<div class="line">    <span class="comment">// или были вызваны незадекларированные в последовательности методы мока,</span></div>
<div class="line">    <span class="comment">// MockSequence::step выбросит исключение, и тест провалится.</span></div>
<div class="line">    <span class="comment">// Если все вызовы произошли в правильном порядке с правильными аргументами, тест пройдет.</span></div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_aae10d30862b8ed496a69f53cc93d7c57"><div class="ttname"><a href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57">DEFINE_MOCK_SEQUENCE_EXPECTATION</a></div><div class="ttdeci">#define DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock, method)</div><div class="ttdoc">Добавляет ожидание в MockSequence. Этот макрос, вероятно, предназначен для использования в цепочке вы...</div><div class="ttdef"><b>Определения</b> mock.h:849</div></div>
<div class="ttc" id="amock_8h_html_ace4b22cc417f51770cfce95652a56f27"><div class="ttname"><a href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27">DEFINE_MOCK_SEQUENCE</a></div><div class="ttdeci">#define DEFINE_MOCK_SEQUENCE(name)</div><div class="ttdoc">Определяет объект MockSequence для проверки упорядоченных ожиданий.</div><div class="ttdef"><b>Определения</b> mock.h:830</div></div>
</div><!-- fragment --><p><b>Важные замечания:</b></p><ul>
<li>Если метод вызывается с аргументами, отличными от тех, что указаны в <code>DEFINE_MOCK_SEQUENCE_EXPECTATION</code>, это считается нарушением последовательности.</li>
<li>Если в ходе выполнения кода происходят вызовы мокированных методов, которые не являются частью текущего ожидаемого шага в последовательности (или вообще не ожидаются в рамках какой-либо активной последовательности), это также может привести к ошибке, в зависимости от строгости реализации мок-фреймворка. Обычно ожидается точное совпадение.</li>
<li>Проверка последовательности выполняется на каждом шаге (<code>step</code> внутри <code>MockSequence</code>). Если порядок нарушается, исключение будет выброшено немедленно.</li>
</ul>
<p>Использование последовательностей особенно полезно для тестирования протоколов взаимодействия или сложных сценариев, где порядок операций критичен. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
