<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iridium: Iridium</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iridium<span id="projectnumber">&#160;0.9.95</span>
   </div>
   <div id="projectbrief">Легковесный C++ фреймворк (логгер, сериализация, потоки, процессы, ввод/вывод, тестирование)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Поиск',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iridium </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_mainpage__ru"></a> </p><div style="float: left; margin-right: 15px; max-height: 50px;"> <div class="image">
<img src="logo.png" alt="" width="100px"/>
</div>
 </div><p>Добро пожаловать в документацию по библиотеке Iridium!</p>
<p>Эта документация предоставляет информацию о том, как использовать различные компоненты библиотеки Iridium. Изучите разделы ниже, чтобы узнать о ее возможностях.</p>
<h1 class="doxsection"><a class="anchor" id="sec_parsers_serializers"></a>
Парсеры и сериализаторы</h1>
<p>Библиотека Iridium предоставляет гибкий механизм для парсинга данных из строковых представлений в структурированное дерево узлов и для сериализации (компоновки) этих деревьев узлов обратно в строки. В основном это достигается через интерфейс <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Интерфейс для обобщенного парсера.">iridium::parsing::IParser</a></span>.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_iparser"></a>
Интерфейс IParser</h2>
<p>Интерфейс <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1_i_parser.html" title="Интерфейс для обобщенного парсера.">iridium::parsing::IParser</a></span> (определенный в <span class="tt"><a class="el" href="parser_8h.html" title="Определяет интерфейс IParser для разбора и формирования структурированных данных. Этот интерфейс пред...">iridium/parsing/parser.h</a></span>) является основным компонентом для парсинга и сериализации. Он предоставляет два основных метода:</p><ul>
<li><span class="tt">parse(const std::string&amp; source)</span>: Принимает строку в качестве входных данных и возвращает <span class="tt">iridium::parsing::INode::TSharedPtr</span>, который является корнем древовидной структуры, представляющей разобранные данные.</li>
<li><span class="tt">compose(iridium::parsing::INode::TConstSharedPtr const&amp; root_node)</span>: Принимает корневой узел древовидной структуры и возвращает его строковое представление.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_obtaining_parser"></a>
Получение парсера</h2>
<p>Конкретные реализации парсеров предоставляются для различных форматов данных. Например, чтобы создать JSON-парсер, вы можете использовать его статический метод <span class="tt">create()</span>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span> <span class="comment">// Для CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span> <span class="comment">// Для IParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span>   <span class="comment">// Для INode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (jsonParser) {</div>
<div class="line">        <span class="comment">// Используйте парсер...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;JSON Parser created successfully.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anode_8h_html"><div class="ttname"><a href="node_8h.html">node.h</a></div><div class="ttdoc">Определяет typedef INode, специализацию INodeType&lt;std::string&gt;. Служит основным типом для представлен...</div></div>
<div class="ttc" id="aparser_8h_html"><div class="ttname"><a href="parser_8h.html">parser.h</a></div><div class="ttdoc">Определяет интерфейс IParser для разбора и формирования структурированных данных. Этот интерфейс пред...</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_parsing_example"></a>
Пример парсинга (JSON)</h2>
<p>Вот как вы можете разобрать JSON-строку в дерево <span class="tt">INode</span>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string jsonString = R<span class="stringliteral">&quot;({ &quot;name&quot;: &quot;IridiumApp&quot;, &quot;version&quot;: 1.0, &quot;modules&quot;: [&quot;parsing&quot;, &quot;logging&quot;] })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonString);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;JSON parsed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Теперь вы можете исследовать структуру дерева rootNode.</span></div>
<div class="line">            <span class="comment">// Например, чтобы получить атрибут &#39;name&#39;:</span></div>
<div class="line">            iridium::parsing::INode::TSharedPtr nameNode = rootNode-&gt;getChild(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (nameNode) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Application Name: &quot;</span> &lt;&lt; nameNode-&gt;getValue() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Parsing returned a null node (empty input or other non-error case).&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_serializing_example"></a>
Пример сериализации (JSON)</h2>
<p>Чтобы сериализовать дерево <span class="tt">INode</span> (например, созданное программно или полученное в результате парсинга) обратно в JSON-строку:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="parser_8h.html">iridium/parsing/parser.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">iridium/parsing/node.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// Для CNode</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    iridium::parsing::IParser::TSharedPtr jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Создание простой структуры узлов программно</span></div>
<div class="line">    iridium::parsing::INode::TSharedPtr root = iridium::parsing::implementation::CNode::create(<span class="stringliteral">&quot;config&quot;</span>);</div>
<div class="line">    root-&gt;addChild(<span class="stringliteral">&quot;setting1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line">    iridium::parsing::INode::TSharedPtr subNode = root-&gt;addChild(<span class="stringliteral">&quot;advanced_settings&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;timeout&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>);</div>
<div class="line">    subNode-&gt;addChild(<span class="stringliteral">&quot;retries&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::string composedJson = jsonParser-&gt;compose(root);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Composed JSON: &quot;</span> &lt;&lt; composedJson &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Composition failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aimplementation_2node_8h_html"><div class="ttname"><a href="implementation_2node_8h.html">node.h</a></div><div class="ttdoc">Определяет typedef CNode, конкретную реализацию узла на основе CNodeType&lt;std::string&gt;....</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_serialization_macros"></a>
Типизированная сериализация с NodeView</h2>
<p>Для более сложных структур данных C++ библиотека Iridium предлагает мощный фреймворк сериализации/десериализации, основанный на <span class="tt"><a class="el" href="classiridium_1_1parsing_1_1serialization_1_1_node_view.html" title="Класс-представление для узла с определенным типом значения. Предоставляет удобный способ доступа и из...">iridium::parsing::serialization::NodeView</a></span> и наборе макросов (таких как <span class="tt"><a class="el" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></span>, <span class="tt"><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></span>, <span class="tt"><a class="el" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></span> и т.д.). Эти инструменты позволяют определять структуры и классы C++, которые могут быть легко преобразованы в дерево <span class="tt">INode</span> и обратно, а затем в строковые форматы, такие как JSON, и обратно.</p>
<p>Эта система обеспечивает типизированный доступ к дереву узлов и автоматизирует большую часть шаблонного кода для сериализации и десериализации. Для получения подробной информации об использовании и примерах, пожалуйста, обратитесь к заголовочному файлу <span class="tt"><a class="el" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a></span>.</p>
<p>Вот более конкретный пример использования этих макросов:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="serialization_2node_8h.html">iridium/parsing/serialization/node.h</a>&quot;</span> <span class="comment">// Для макросов сериализации</span></div>
<div class="line"><span class="preprocessor">#include &quot;iridium/parsing/implementation/parser_json.h&quot;</span> <span class="comment">// Для CJSONParser</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2node_8h.html">iridium/parsing/implementation/node.h</a>&quot;</span> <span class="comment">// Для CNode (используется макросами)</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для convert (используется макросами)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span> <span class="comment">// Используется NodeViewList</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Требуется для компиляции макросов, если необходимы преобразования строк.</span></div>
<div class="line"><span class="comment">// Обычно у вас должны быть эти специализации для ваших пользовательских типов, если они не являются базовыми.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение простой структуры элемента данных</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MyDataItem) <span class="comment">// Корневой узел для прямого использования или вложения, по умолчанию использует разделитель &#39;-&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::string, Name, <span class="stringliteral">&quot;DefaultName&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, Value, 0)</div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение более сложной структуры настроек</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a>(MySettings) <span class="comment">// Корневой узел, использует разделитель &#39;-&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ConfigName, <span class="stringliteral">&quot;DefaultConfig&quot;</span>)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">bool</span>, IsEnabled, true)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определение вложенного узла с использованием ранее определенной структуры корневого узла</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a>(MyDataItem) <span class="comment">// Имя члена будет &#39;MyDataItem&#39;, имя узла &#39;my-data-item&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определение списка MyDataItem</span></div>
<div class="line">    <span class="comment">// Член списка будет называться &#39;ItemList&#39;, а каждый узел элемента будет называться &#39;item&#39;</span></div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a>(Item) <span class="comment">// Это определяет TItem и TItemList</span></div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(std::<span class="keywordtype">string</span>, ItemName, <span class="stringliteral">&quot;DefaultItem&quot;</span>)</div>
<div class="line">        <a class="code hl_define" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a>(<span class="keywordtype">int</span>, ItemId, 0)</div>
<div class="line">    <a class="code hl_define" href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a>(Item) <span class="comment">// Член с именем &#39;Item&#39; типа TItemList</span></div>
<div class="line"><a class="code hl_define" href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a>()</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Создание экземпляра JSON-парсера</span></div>
<div class="line">    <span class="keyword">auto</span> jsonParser = iridium::parsing::implementation::CJSONParser::create();</div>
<div class="line">    <span class="keywordflow">if</span> (!jsonParser) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create JSON parser.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Пример сериализации ---</span></div>
<div class="line">    MySettings settingsToSerialize;</div>
<div class="line">    settingsToSerialize.ConfigName = <span class="stringliteral">&quot;UserSettings&quot;</span>;</div>
<div class="line">    settingsToSerialize.IsEnabled = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    settingsToSerialize.MyDataItem.Name = <span class="stringliteral">&quot;Special Item&quot;</span>;</div>
<div class="line">    settingsToSerialize.MyDataItem.Value = 123;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Добавление элементов в список</span></div>
<div class="line">    MySettings::TItem item1; <span class="comment">// Примечание: TItem вложен в MySettings из-за DEFINE_NODE_LIST_BEGIN</span></div>
<div class="line">    item1.ItemName = <span class="stringliteral">&quot;FirstListItem&quot;</span>;</div>
<div class="line">    item1.ItemId = 1;</div>
<div class="line">    settingsToSerialize.Item.add(item1);</div>
<div class="line"> </div>
<div class="line">    MySettings::TItem item2;</div>
<div class="line">    item2.ItemName = <span class="stringliteral">&quot;SecondListItem&quot;</span>;</div>
<div class="line">    item2.ItemId = 2;</div>
<div class="line">    settingsToSerialize.Item.add(item2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// Получение INode из нашего объекта настроек и его компоновка в JSON</span></div>
<div class="line">        std::string jsonOutput = jsonParser-&gt;compose(settingsToSerialize.getNode());</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Serialized JSON:&quot;</span> &lt;&lt; std::endl &lt;&lt; jsonOutput &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Ожидаемая структура вывода:</span></div>
<div class="line">        <span class="comment">// {</span></div>
<div class="line">        <span class="comment">//   &quot;config-name&quot;: &quot;UserSettings&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;is-enabled&quot;: &quot;true&quot;,</span></div>
<div class="line">        <span class="comment">//   &quot;my-data-item&quot;: {</span></div>
<div class="line">        <span class="comment">//     &quot;name&quot;: &quot;Special Item&quot;,</span></div>
<div class="line">        <span class="comment">//     &quot;value&quot;: &quot;123&quot;</span></div>
<div class="line">        <span class="comment">//   },</span></div>
<div class="line">        <span class="comment">//   &quot;item&quot;: [</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;FirstListItem&quot;, &quot;item-id&quot;: &quot;1&quot; },</span></div>
<div class="line">        <span class="comment">//     { &quot;item-name&quot;: &quot;SecondListItem&quot;, &quot;item-id&quot;: &quot;2&quot; }</span></div>
<div class="line">        <span class="comment">//   ]</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Serialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Пример десериализации ---</span></div>
<div class="line">    std::string jsonInput = R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">        &quot;config-name&quot;: &quot;LoadedSettings&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;is-enabled&quot;: &quot;false&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;my-data-item&quot;: {</span></div>
<div class="line"><span class="stringliteral">            &quot;name&quot;: &quot;LoadedItem&quot;,</span></div>
<div class="line"><span class="stringliteral">            &quot;value&quot;: &quot;456&quot;</span></div>
<div class="line"><span class="stringliteral">        },</span></div>
<div class="line"><span class="stringliteral">        &quot;item&quot;: [</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem1&quot;, &quot;item-id&quot;: &quot;10&quot; },</span></div>
<div class="line"><span class="stringliteral">            { &quot;item-name&quot;: &quot;LoadedListItem2&quot;, &quot;item-id&quot;: &quot;20&quot; }</span></div>
<div class="line"><span class="stringliteral">        ]</span></div>
<div class="line"><span class="stringliteral">    })&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">try</span> {</div>
<div class="line">        iridium::parsing::INode::TSharedPtr rootNode = jsonParser-&gt;parse(jsonInput);</div>
<div class="line">        <span class="keywordflow">if</span> (rootNode) {</div>
<div class="line">            MySettings deserializedSettings(rootNode); <span class="comment">// Создание MySettings из INode</span></div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Deserialized Settings:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Config Name: &quot;</span> &lt;&lt; deserializedSettings.ConfigName.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Is Enabled: &quot;</span> &lt;&lt; (deserializedSettings.IsEnabled.get() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Name: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Name.get() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Nested Item Value: &quot;</span> &lt;&lt; deserializedSettings.MyDataItem.Value.get() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;List Items:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : deserializedSettings.Item) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  - Name: &quot;</span> &lt;&lt; item.ItemName.get() &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; item.ItemId.get() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Parsing input JSON returned a null node.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Deserialization failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconvert_8h_html"><div class="ttname"><a href="convert_8h.html">convert.h</a></div><div class="ttdoc">Предоставляет обобщенный фреймворк для преобразования типов.</div></div>
<div class="ttc" id="aserialization_2node_8h_html"><div class="ttname"><a href="serialization_2node_8h.html">node.h</a></div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1547f0c86e3c410b26dcf1d13d1fcec7"><div class="ttname"><a href="serialization_2node_8h.html#a1547f0c86e3c410b26dcf1d13d1fcec7">DEFINE_NODE_LIST_END</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_END(class_name)</div><div class="ttdef"><b>Определения</b> node.h:464</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a1c49dbc67050d59e4b5e7d095067a81a"><div class="ttname"><a href="serialization_2node_8h.html#a1c49dbc67050d59e4b5e7d095067a81a">DEFINE_NODE_LIST_BEGIN</a></div><div class="ttdeci">#define DEFINE_NODE_LIST_BEGIN(class_name)</div><div class="ttdef"><b>Определения</b> node.h:452</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a6ae6809e071cbeb286389a6ea722e126"><div class="ttname"><a href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE</a></div><div class="ttdeci">#define DEFINE_ATTRIBUTE(...)</div><div class="ttdef"><b>Определения</b> node.h:447</div></div>
<div class="ttc" id="aserialization_2node_8h_html_a7b4e724573d774904e29ede08ef7b17a"><div class="ttname"><a href="serialization_2node_8h.html#a7b4e724573d774904e29ede08ef7b17a">DEFINE_ROOT_NODE_END</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_END()</div><div class="ttdef"><b>Определения</b> node.h:414</div></div>
<div class="ttc" id="aserialization_2node_8h_html_aac8f5e72dee27b1c9479d82a20f96f62"><div class="ttname"><a href="serialization_2node_8h.html#aac8f5e72dee27b1c9479d82a20f96f62">DEFINE_ROOT_NODE_BEGIN</a></div><div class="ttdeci">#define DEFINE_ROOT_NODE_BEGIN(...)</div><div class="ttdef"><b>Определения</b> node.h:410</div></div>
<div class="ttc" id="aserialization_2node_8h_html_ac671d110728b8a4bd1ea52fc352c9120"><div class="ttname"><a href="serialization_2node_8h.html#ac671d110728b8a4bd1ea52fc352c9120">DEFINE_NODE_EXTERNAL</a></div><div class="ttdeci">#define DEFINE_NODE_EXTERNAL(class_name)</div><div class="ttdef"><b>Определения</b> node.h:495</div></div>
</div><!-- fragment --><p>Этот пример демонстрирует определение структур с атрибутами, вложенными узлами и списками узлов. Затем он показывает, как заполнить экземпляр такой структуры, сериализовать его в JSON и десериализовать JSON обратно в структуру, используя интерфейс <span class="tt">IParser</span> в сочетании с представлениями узлов, генерируемыми макросами. Метод <span class="tt">getNode()</span> в структуре, определенной макросом, предоставляет <span class="tt">INode</span>, необходимый для <span class="tt">compose</span>, а конструктор структуры может принимать <span class="tt">INode</span> (из <span class="tt">parse</span>) для своего заполнения. Помните, что фактические имена узлов в JSON (например, "config-name") выводятся из имен членов C++ путем преобразования CamelCase и вставки разделителя (по умолчанию '-').</p>
<h1 class="doxsection"><a class="anchor" id="sec_logging"></a>
Использование и конфигурация логгера</h1>
<p>Библиотека Iridium включает гибкую систему логирования для помощи в инструментировании вашего приложения и диагностике проблем. Она поддерживает несколько мест назначения вывода (приемников), настраиваемые уровни логирования и асинхронное логирование.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_logging_macros"></a>
Базовое логирование</h2>
<p>Самый простой способ логирования сообщений — использование предоставленных макросов логирования:</p><ul>
<li><span class="tt"><a class="el" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; "Trace message";</span> (Уровень трассировки, часто включает файл/строку, обычно для отладочных сборок)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; "Debug message";</span> (Уровень отладки, обычно для отладочных сборок)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; "Informational message";</span> (Информационный уровень)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; "Warning message";</span> (Уровень предупреждения)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; "Error message";</span> (Уровень ошибки)</li>
<li><span class="tt"><a class="el" href="logger_8h.html#ac4c513cbda38bfa3bace1f2420511271">LOGF</a> &lt;&lt; "Fatal message";</span> (Фатальный уровень)</li>
</ul>
<p>Эти макросы создают временный объект потока лога. Вы можете передавать в них данные с помощью оператора <span class="tt">&lt;&lt;</span>, аналогично <span class="tt">std::cout</span>. Когда оператор завершается, сообщение лога автоматически форматируется и отправляется в настроенные приемники логов.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span> <span class="comment">// Основной заголовочный файл для логирования</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Базовая конфигурация (вывод в консоль по умолчанию) обычно настраивается, если не предоставлена пользовательская конфигурация.</span></div>
<div class="line">    <span class="comment">// Для большего контроля см. примеры конфигурации ниже.</span></div>
<div class="line">    <span class="comment">// iridium::logging::setConfig(iridium::logging::config::createDefault()); // Пример установки по умолчанию</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> count = 42;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;Application started. Current count: &quot;</span> &lt;&lt; count;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This is a debug message. It might not appear in release builds.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (count &gt; 100) {</div>
<div class="line">        <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;Count is higher than expected: &quot;</span> &lt;&lt; count;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// LOGE &lt;&lt; &quot;An example error occurred.&quot;;</span></div>
<div class="line">    <span class="comment">// LOGF &lt;&lt; &quot;A fatal error occurred, application might terminate.&quot;;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html"><div class="ttname"><a href="logger_8h.html">logger.h</a></div></div>
<div class="ttc" id="alogger_8h_html_a13fd5c842ec8d93baac58bb616497fe8"><div class="ttname"><a href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a></div><div class="ttdeci">#define LOGI</div><div class="ttdef"><b>Определения</b> logger.h:194</div></div>
<div class="ttc" id="alogger_8h_html_a62b5282578b939fd77b7bb1d00c4f15a"><div class="ttname"><a href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a></div><div class="ttdeci">#define LOGD</div><div class="ttdef"><b>Определения</b> logger.h:189</div></div>
<div class="ttc" id="alogger_8h_html_ac6f0b43ab85743ce5de50d53bda6de62"><div class="ttname"><a href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a></div><div class="ttdeci">#define LOGW</div><div class="ttdef"><b>Определения</b> logger.h:198</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_logger_configuration"></a>
Конфигурация логгера</h2>
<p>Логгер настраивается с помощью структуры <span class="tt">iridium::logging::config::TLogger</span>, которая определена в <span class="tt"><a class="el" href="logging_2config_8h.html">iridium/logging/config.h</a></span>. Эту структуру можно заполнить программно или потенциально загрузить из конфигурационного файла (если он разобран в дерево <span class="tt">INode</span>).</p>
<p>Ключевые поля в <span class="tt">iridium::logging::config::TLogger</span>:</p><ul>
<li><span class="tt">IsGmtTime</span> (bool): Если <span class="tt">true</span>, временные метки указаны в GMT/UTC; в противном случае используется местное время. По умолчанию <span class="tt">false</span>.</li>
<li><span class="tt">Level</span> (<span class="tt">iridium::logging::TEvent::TLevel</span>): Глобальный уровень логирования по умолчанию. Конкретные приемники могут переопределять это значение. По умолчанию <span class="tt">TRACE</span>.</li>
<li><span class="tt">Sink</span> (список объектов <span class="tt">TLogger::TSink</span>): Определяет одно или несколько мест назначения вывода для сообщений лога.</li>
</ul>
<p>Каждый объект <span class="tt">TLogger::TSink</span> в списке <span class="tt">Sink</span> имеет следующие ключевые поля:</p><ul>
<li><span class="tt">Type</span> (<span class="tt">iridium::logging::config::TLogger::TSink::TSinkType</span>): Указывает тип приемника. Распространенные значения:<ul>
<li><span class="tt">CONSOLE</span>: Вывод в стандартную консоль.</li>
<li><span class="tt">FILE</span>: Вывод в один файл.</li>
<li><span class="tt">FILE_DAILY</span>: Вывод в файл, который ротируется ежедневно.</li>
<li><span class="tt">FILE_TIMELY</span>: Вывод в новый файл каждый раз при запуске логгера.</li>
</ul>
</li>
<li><span class="tt">IsAsync</span> (bool): Если <span class="tt">true</span>, этот приемник обрабатывает сообщения лога асинхронно в отдельном потоке. По умолчанию <span class="tt">false</span>.</li>
<li><span class="tt">Uri</span> (std::string): Для файловых приемников (<span class="tt">FILE</span>, <span class="tt">FILE_DAILY</span>, <span class="tt">FILE_TIMELY</span>) это путь к файлу лога.</li>
<li><span class="tt">Level</span> (<span class="tt">iridium::logging::TEvent::TLevel</span>): Конкретный уровень логирования для этого приемника. Если установлено значение <span class="tt">UNKNOWN</span>, он наследует глобальный уровень логгера. В противном случае он переопределяет глобальный уровень для этого конкретного приемника.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_logger_config_example"></a>
Пример программной конфигурации</h2>
<p>Вот как настроить логгер программно:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logging_2config_8h.html">iridium/logging/config.h</a>&quot;</span> <span class="comment">// Для TLogger, TEvent::TLevel и т.д.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Создание объекта конфигурации TLogger</span></div>
<div class="line">    iridium::logging::config::TLogger loggerConfig;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Установка глобальных свойств</span></div>
<div class="line">    loggerConfig.IsGmtTime = <span class="keyword">false</span>;</div>
<div class="line">    loggerConfig.Level = iridium::logging::TEvent::TLevel::INFO; <span class="comment">// Глобальный уровень</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Конфигурация приемника для консоли</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink consoleSink;</div>
<div class="line">    consoleSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::CONSOLE;</div>
<div class="line">    consoleSink.IsAsync = <span class="keyword">false</span>;</div>
<div class="line">    consoleSink.Level = iridium::logging::TEvent::TLevel::DEBUG; <span class="comment">// Консоль будет показывать DEBUG и выше</span></div>
<div class="line">    loggerConfig.Sink.add(consoleSink); <span class="comment">// Добавление в список приемников</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Конфигурация файлового приемника</span></div>
<div class="line">    iridium::logging::config::TLogger::TSink fileSink;</div>
<div class="line">    fileSink.Type = iridium::logging::config::TLogger::TSink::TSinkType::FILE;</div>
<div class="line">    fileSink.IsAsync = <span class="keyword">true</span>; <span class="comment">// Асинхронное логирование в файл</span></div>
<div class="line">    fileSink.Uri = <span class="stringliteral">&quot;application.log&quot;</span>;</div>
<div class="line">    fileSink.Level = iridium::logging::TEvent::TLevel::WARNING; <span class="comment">// Файл будет получать только WARNING и выше</span></div>
<div class="line">    loggerConfig.Sink.add(fileSink);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Применение конфигурации</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a>(loggerConfig);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Теперь логгер настроен.</span></div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a> &lt;&lt; <span class="stringliteral">&quot;This TRACE message will not appear on console or file.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a62b5282578b939fd77b7bb1d00c4f15a">LOGD</a> &lt;&lt; <span class="stringliteral">&quot;This DEBUG message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; <span class="stringliteral">&quot;This INFO message will appear on the console only.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ac6f0b43ab85743ce5de50d53bda6de62">LOGW</a> &lt;&lt; <span class="stringliteral">&quot;This WARNING message will appear on console AND in application.log.&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a> &lt;&lt; <span class="stringliteral">&quot;This ERROR message will also appear on console AND in application.log.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alogger_8h_html_a4f7814d1bd32cecccb2f3fafbb3ade58"><div class="ttname"><a href="logger_8h.html#a4f7814d1bd32cecccb2f3fafbb3ade58">LOGT</a></div><div class="ttdeci">#define LOGT</div><div class="ttdef"><b>Определения</b> logger.h:180</div></div>
<div class="ttc" id="alogger_8h_html_ae08358ff7da64345ad674296a5957823"><div class="ttname"><a href="logger_8h.html#ae08358ff7da64345ad674296a5957823">LOGE</a></div><div class="ttdeci">#define LOGE</div><div class="ttdef"><b>Определения</b> logger.h:202</div></div>
<div class="ttc" id="alogging_2config_8h_html"><div class="ttname"><a href="logging_2config_8h.html">config.h</a></div></div>
<div class="ttc" id="anamespaceiridium_1_1logging_html_a4fff5fa51c4d1b05c97ae08faf5efd18"><div class="ttname"><a href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18">iridium::logging::setConfig</a></div><div class="ttdeci">void setConfig(config::TLogger const &amp;config)</div><div class="ttdoc">Устанавливает глобальную конфигурацию логгера.</div><div class="ttdef"><b>Определения</b> logger.cpp:169</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_default_config"></a>
Конфигурация по умолчанию</h2>
<p>Библиотека предоставляет вспомогательную функцию для получения простой конфигурации по умолчанию: <span class="tt">iridium::logging::config::TLogger defaultConfig = <a class="el" href="namespaceiridium_1_1logging_1_1config.html#a57a36466c8a3545a48ab706922b86672">iridium::logging::config::createDefault()</a>;</span></p>
<p>Эта конфигурация по умолчанию обычно настраивает синхронный консольный приемник с уровнем логирования <span class="tt">TRACE</span>. Вы можете изменить этот объект конфигурации по умолчанию перед его применением с помощью <span class="tt"><a class="el" href="namespaceiridium_1_1logging.html#a4fff5fa51c4d1b05c97ae08faf5efd18" title="Устанавливает глобальную конфигурацию логгера.">iridium::logging::setConfig()</a></span>.</p>
<p>Помните, что конфигурацию логгера в идеале следует выполнять на ранних этапах жизненного цикла вашего приложения, до того, как произойдет какое-либо значительное логирование.</p>
<h1 class="doxsection"><a class="anchor" id="sec_custom_type_conversion"></a>
Интеграция пользовательских типов с <span class="tt">iridium::convertion::convert</span></h1>
<p>Библиотека Iridium предоставляет гибкий способ интеграции ваших пользовательских типов данных с ее системами, такими как логирование и макросы сериализации. Это достигается путем предоставления специализаций для шаблонной функции <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a>&lt;TargetType, SourceType&gt;</span> для вашего пользовательского типа.</p>
<p>Библиотека предлагает пару макросов для объявления и реализации этих специализаций:</p><ul>
<li><b><span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Макрос для определения преобразования между двумя типами.">DEFINE_CONVERT(TTo, TFrom)</a></span></b>: Этот макрос следует использовать в вашем заголовочном файле (например, рядом с определением вашего пользовательского типа). Он объявляет компилятору, что будет доступна конкретная специализация преобразования.</li>
<li><b><span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Макрос для реализации преобразования между двумя типами с помощью функции.">IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</a></span></b>: Этот макрос используется в исходном файле (.cpp) для предоставления фактической реализации преобразования. <span class="tt">TFunc</span> должен быть функцией, функтором или лямбда-выражением, которое принимает аргумент <span class="tt">TFrom const&amp;</span> и возвращает <span class="tt">TTo</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_custom_convert_example_fn"></a>
Пример: Пользовательский тип <span class="tt">Point</span></h2>
<p>Проиллюстрируем это на примере пользовательской структуры <span class="tt">Point</span>.</p>
<p><b>1. Определение типа и объявление преобразований (например, в <span class="tt">Point.h</span>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once </span><span class="comment">// Пример защитного включения заголовка</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для DEFINE_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span> <span class="comment">// Требуется для использования std::string</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пользовательская структура</span></div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Необязательно: для прямого сравнения в примерах или тестах</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> x == other.x &amp;&amp; y == other.y;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Объявление того, что мы предоставим специализации для преобразования</span></div>
<div class="line"><span class="comment">// Point в std::string и std::string в Point.</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(std::string, Point);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a>(Point, std::string);</div>
<div class="ttc" id="aconvert_8h_html_ab6323540b384b64371e62ea6e910317b"><div class="ttname"><a href="convert_8h.html#ab6323540b384b64371e62ea6e910317b">DEFINE_CONVERT</a></div><div class="ttdeci">#define DEFINE_CONVERT(TTo, TFrom)</div><div class="ttdoc">Макрос для определения преобразования между двумя типами.</div><div class="ttdef"><b>Определения</b> convert.h:67</div></div>
</div><!-- fragment --><p><b>2. Реализация преобразований (например, в <span class="tt">Point.cpp</span>)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Предполагается, что здесь находятся определения структуры Point и объявления DEFINE_CONVERT</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для IMPLEMENT_CONVERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// Для std::invalid_argument, std::out_of_range</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Вспомогательная функция для преобразования Point в std::string</span></div>
<div class="line"><span class="keyword">static</span> std::string localPointToString(<span class="keyword">const</span> Point&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + std::to_string(p.x) + <span class="stringliteral">&quot;,&quot;</span> + std::to_string(p.y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Вспомогательная функция для преобразования std::string в Point</span></div>
<div class="line"><span class="keyword">static</span> Point localStringToPoint(<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s.length() &lt; 3 || s.front() != <span class="charliteral">&#39;(&#39;</span> || s.back() != <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing parentheses. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    std::string content = s.substr(1, s.length() - 2); <span class="comment">// Удаление скобок</span></div>
<div class="line">    <span class="keywordtype">size_t</span> commaPos = content.find(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (commaPos == std::string::npos) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid Point string format: Missing comma. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordtype">int</span> xVal = std::stoi(content.substr(0, commaPos));</div>
<div class="line">        <span class="keywordtype">int</span> yVal = std::stoi(content.substr(commaPos + 1));</div>
<div class="line">        <span class="keywordflow">return</span> {xVal, yVal};</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; eIa) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid integer in Point string: &quot;</span> + std::string(eIa.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; eOor) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Integer out of range in Point string: &quot;</span> + std::string(eOor.what()) + <span class="stringliteral">&quot;. Input: &quot;</span> + s);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Реализация объявленных специализаций преобразования с использованием вспомогательных функций</span></div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(std::string, Point, localPointToString);</div>
<div class="line"><a class="code hl_define" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a>(Point, std::string, localStringToPoint);</div>
<div class="ttc" id="aconvert_8h_html_aa14ff619763935045ee893f7f1e8668f"><div class="ttname"><a href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f">IMPLEMENT_CONVERT</a></div><div class="ttdeci">#define IMPLEMENT_CONVERT(TTo, TFrom, TFunc)</div><div class="ttdoc">Макрос для реализации преобразования между двумя типами с помощью функции.</div><div class="ttdef"><b>Определения</b> convert.h:78</div></div>
</div><!-- fragment --><p><b>3. Пример использования (например, в <span class="tt">main.cpp</span> или тестах)</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Point.h&quot;</span> <span class="comment">// Заголовочный файл вашего пользовательского типа</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="logger_8h.html">iridium/logging/logger.h</a>&quot;</span>   <span class="comment">// Для LOGI (пример использования)</span></div>
<div class="line"><span class="comment">// Для примера макросов сериализации (концептуально)</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/serialization/node.h&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/parsing/implementation/parser_json.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// Для std::cout</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main_custom_convert_demo() { <span class="comment">// Переименовано, чтобы избежать конфликтов, если mainpage.md компилируется</span></div>
<div class="line">    Point p1 = {7, 14};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример логирования:</span></div>
<div class="line">    <span class="comment">// iridium::logging::LogStream обычно использует iridium::convertion::convert&lt;std::string&gt;(value)</span></div>
<div class="line">    <span class="comment">// для типов, у которых нет прямой перегрузки оператора std::ostream&amp; operator&lt;&lt;.</span></div>
<div class="line">    <span class="comment">// Таким образом, после определения преобразования это должно работать:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;My custom point: &quot; &lt;&lt; p1;</span></div>
<div class="line">    <span class="comment">// Для этого примера мы продемонстрируем преобразование явно:</span></div>
<div class="line">    std::string p1AsString = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(p1);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Point p1 converted to string: &quot;</span> &lt;&lt; p1AsString &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример десериализации (например, из строки конфигурации):</span></div>
<div class="line">    std::string inputString = <span class="stringliteral">&quot;(100,-200)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        Point p2 = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;Point&gt;</a>(inputString);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;String &#39;&quot;</span> &lt;&lt; inputString &lt;&lt; <span class="stringliteral">&quot;&#39; converted to Point: (&quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; p2.y &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error converting string to Point: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Как это применяется к макросам сериализации:</span></div>
<div class="line">    <span class="comment">// Если вы определяете сериализуемую структуру следующим образом:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyStructure)</span></div>
<div class="line">    <span class="comment">//   DEFINE_ATTRIBUTE(Point, Position) // Использует Point</span></div>
<div class="line">    <span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// MyStructure data;</span></div>
<div class="line">    <span class="comment">// data.Position = {5,5}; // Установка Point</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // При сериализации:</span></div>
<div class="line">    <span class="comment">// // auto jsonParser = iridium::parsing::implementation::CJSONParser::create();</span></div>
<div class="line">    <span class="comment">// // std::string json_output = jsonParser-&gt;compose(data.getNode());</span></div>
<div class="line">    <span class="comment">// // ...значением узла &#39;Position&#39; будет &quot;(5,5)&quot; благодаря Convert&lt;std::string, Point&gt;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// // При десериализации:</span></div>
<div class="line">    <span class="comment">// // std::string json_input = R&quot;({ &quot;position&quot;: &quot;(10,20)&quot; })&quot;;</span></div>
<div class="line">    <span class="comment">// // MyStructure loaded_data(jsonParser-&gt;parse(json_input));</span></div>
<div class="line">    <span class="comment">// // ...строка &quot;(10,20)&quot; будет преобразована в объект Point для &#39;Position&#39;</span></div>
<div class="line">    <span class="comment">// //    благодаря Convert&lt;Point, std::string&gt;.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceiridium_1_1convertion_html_aaf31a5335a6afae5d2fdffcdd0b83483"><div class="ttname"><a href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert</a></div><div class="ttdeci">TResult convert(TValue const &amp;value)</div><div class="ttdoc">Преобразует значение из исходного типа в целевой.</div><div class="ttdef"><b>Определения</b> convert.h:37</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_custom_convert_fn_impact"></a>
Влияние пользовательских специализаций <span class="tt">convert</span></h2>
<p><b>Для логирования:</b> После того, как вы предоставите специализацию <span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Макрос для определения преобразования между двумя типами.">DEFINE_CONVERT(std::string, YourCustomType)</a></span> и ее реализацию, ваши пользовательские объекты часто можно будет напрямую использовать в операторах логирования (например, <span class="tt"><a class="el" href="logger_8h.html#a13fd5c842ec8d93baac58bb616497fe8">LOGI</a> &lt;&lt; yourCustomObject;</span>). Система логирования обычно вызывает <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a>&lt;std::string&gt;(yourCustomObject)</span> для получения строкового представления, если не найдена или не предпочтительна прямая перегрузка <span class="tt">operator&lt;&lt;(std::ostream&amp;, const YourCustomType&amp;)</span>.</p>
<p><b>Для макросов сериализации:</b> При использовании макросов сериализации, таких как <span class="tt"><a class="el" href="serialization_2node_8h.html#a6ae6809e071cbeb286389a6ea722e126">DEFINE_ATTRIBUTE(YourCustomType, myField)</a></span>:</p><ul>
<li>Специализация для <span class="tt">Convert&lt;std::string, YourCustomType&gt;</span> (реализованная через <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Макрос для реализации преобразования между двумя типами с помощью функции.">IMPLEMENT_CONVERT</a></span>) используется для преобразования члена <span class="tt">myField</span> в его строковое представление при сериализации родительской структуры. Эта строка затем сохраняется как значение соответствующего узла (например, строковый атрибут JSON или текстовый узел XML).</li>
<li>Специализация для <span class="tt">Convert&lt;YourCustomType, std::string&gt;</span> (реализованная через <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Макрос для реализации преобразования между двумя типами с помощью функции.">IMPLEMENT_CONVERT</a></span>) используется во время десериализации. Если парсер считывает строковое значение из входных данных (например, из атрибута JSON), которое необходимо преобразовать в <span class="tt">YourCustomType</span> для <span class="tt">myField</span>, будет вызвана эта специализация.</li>
</ul>
<p>Предоставляя эти специализации функции <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">convert</a></span>, вы позволяете вашим пользовательским типам данных плавно интегрироваться с различными частями библиотеки Iridium, которые полагаются на преобразование типов, особенно для строковых представлений. Не забудьте объявить специализации с помощью <span class="tt"><a class="el" href="convert_8h.html#ab6323540b384b64371e62ea6e910317b" title="Макрос для определения преобразования между двумя типами.">DEFINE_CONVERT</a></span> в заголовочном файле и реализовать их с помощью <span class="tt"><a class="el" href="convert_8h.html#aa14ff619763935045ee893f7f1e8668f" title="Макрос для реализации преобразования между двумя типами с помощью функции.">IMPLEMENT_CONVERT</a></span> и вашей логики преобразования в исходном файле.</p>
<h1 class="doxsection"><a class="anchor" id="sec_define_enum"></a>
Обработка перечислений с помощью DEFINE_ENUM</h1>
<p>Библиотека Iridium часто предоставляет служебный макрос <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span> (обычно ожидаемый в заголовочном файле, таком как <span class="tt"><a class="el" href="enum_8h.html" title="Предоставляет макросы для определения и реализации типобезопасных перечислений с возможностями рефлек...">iridium/enum.h</a></span> или общем заголовочном файле утилит), чтобы упростить определение типов C++ <span class="tt">enum class</span> и автоматически интегрировать их с системой <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a></span>. Эта интеграция имеет решающее значение для простого логирования значений перечислений в виде удобочитаемых строк и для их сериализации/десериализации в конфигурационных файлах или форматах обмена данными.</p>
<p><b>Ключевая функциональность <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span>:</b></p>
<p>Когда вы используете <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span>, он обычно выполняет следующие действия:</p><ol type="1">
<li><b>Определяет <span class="tt">enum class</span></b>: Создает фактический C++ <span class="tt">enum class</span> с указанным именем и перечислителями.</li>
<li><b>Генерирует преобразования строк</b>: Что наиболее важно, он автоматически генерирует необходимые специализации для <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a></span>, чтобы разрешить:<ul>
<li>Преобразование значения перечисления в его строковое представление (например, <span class="tt">MyEnum::ValueOne</span> становится <span class="tt">"ValueOne"</span>).</li>
<li>Преобразование строкового представления обратно в значение перечисления (например, <span class="tt">"ValueOne"</span> становится <span class="tt">MyEnum::ValueOne</span>).</li>
</ul>
</li>
</ol>
<p><b>Типичный синтаксис:</b></p>
<p>Хотя точный синтаксис может незначительно отличаться в зависимости от конкретной реализации макроса, распространенным шаблоном является:</p>
<p><span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM(EnumTypeName, Enumerator1, Enumerator2, ..., [OptionalDefaultOrUnknownEnumerator])</a></span></p>
<ul>
<li><span class="tt">EnumTypeName</span>: Желаемое имя для вашего <span class="tt">enum class</span>.</li>
<li><span class="tt">Enumerator1, Enumerator2, ...</span>: Список имен перечислителей.</li>
<li><span class="tt">[OptionalDefaultOrUnknownEnumerator]</span>: Часто последний перечислитель может быть назначен (например, назван <span class="tt">Unknown</span> или <span class="tt">Default</span>) для использования в качестве резервного значения, если строка не может быть успешно проанализирована в один из других определенных перечислителей. Если не указано, попытка преобразовать недопустимую строку в тип перечисления может привести к возврату первого перечислителя или, возможно, к ошибке, в зависимости от конструкции макроса.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_define_enum_example"></a>
Пример использования</h2>
<p>Проиллюстрируем это парой примеров. (Убедитесь, что вы включили заголовочный файл, предоставляющий <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span>, например, <span class="tt">#include "<a class="el" href="enum_8h.html" title="Предоставляет макросы для определения и реализации типобезопасных перечислений с возможностями рефлек...">iridium/enum.h</a>"</span>)</p>
<div class="fragment"><div class="line"><span class="comment">// Примечание: Макрос DEFINE_ENUM предоставляется библиотекой Iridium.</span></div>
<div class="line"><span class="comment">// Обычно для его использования вы бы включили заголовочный файл типа &lt;iridium/enum.h&gt;.</span></div>
<div class="line"><span class="comment">// mainpage_example_define_enum.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Предполагается, что &quot;iridium/enum.h&quot; или аналогичный заголовочный файл, определяющий DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// и &quot;iridium/convertion/convert.h&quot;, доступны.</span></div>
<div class="line"><span class="comment">// Для этого примера мы при необходимости имитируем ожидаемое поведение макроса для демонстрации,</span></div>
<div class="line"><span class="comment">// но в идеале он поступает из библиотеки.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример 1: Простое перечисление цветов</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(MyColor,</div>
<div class="line">    Red,    <span class="comment">// Сопоставляется с &quot;Red&quot;</span></div>
<div class="line">    Green,  <span class="comment">// Сопоставляется с &quot;Green&quot;</span></div>
<div class="line">    Blue    <span class="comment">// Сопоставляется с &quot;Blue&quot;</span></div>
<div class="line">) <span class="comment">// MyColor будет иметь MyColor::Red, MyColor::Green, MyColor::Blue</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример 2: Статус операции с явным значением Unknown/Default</span></div>
<div class="line"><a class="code hl_define" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a>(OperationStatus,</div>
<div class="line">    Success,</div>
<div class="line">    Pending,</div>
<div class="line">    Failed,</div>
<div class="line">    Unknown <span class="comment">// Это может служить значением по умолчанию, если парсинг строки завершается неудачно</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/logging/logger.h&quot; // Для LOGI (концептуально)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_define_enum_usage() {</div>
<div class="line">    MyColor favoriteColor = MyColor::Green;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Преобразование перечисления в строку (например, для логирования или сериализации)</span></div>
<div class="line">    <span class="comment">// Ожидается, что макрос DEFINE_ENUM создал необходимую</span></div>
<div class="line">    <span class="comment">// специализацию iridium::convertion::convert&lt;std::string, MyColor&gt;.</span></div>
<div class="line">    std::string colorStr = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(favoriteColor);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Favorite color: &quot;</span> &lt;&lt; colorStr &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Green&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Концептуальное логирование:</span></div>
<div class="line">    <span class="comment">// LOGI &lt;&lt; &quot;Current status: &quot; &lt;&lt; OperationStatus::Pending; // Выведет &quot;Pending&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Преобразование строки в перечисление (например, для десериализации из файла конфигурации)</span></div>
<div class="line">    std::string inputColorStr = <span class="stringliteral">&quot;Blue&quot;</span>;</div>
<div class="line">    MyColor parsedColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;MyColor&gt;</a>(inputColorStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed color from string &#39;&quot;</span> &lt;&lt; inputColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(parsedColor) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Blue&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример парсинга недопустимой строки для MyColor</span></div>
<div class="line">    std::string invalidColorStr = <span class="stringliteral">&quot;Purple&quot;</span>;</div>
<div class="line">    MyColor defaultOrFirstColor = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;MyColor&gt;</a>(invalidColorStr);</div>
<div class="line">    <span class="comment">// Поведение для недопустимой строки зависит от реализации DEFINE_ENUM.</span></div>
<div class="line">    <span class="comment">// Оно может по умолчанию использовать первый перечислитель (Red) или указанное значение &#39;Unknown&#39;, если макрос это поддерживает.</span></div>
<div class="line">    <span class="comment">// Наш концептуальный заполнитель по умолчанию использует &#39;Unknown&#39;, если доступно, или первый, если нет.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid color string &#39;&quot;</span> &lt;&lt; invalidColorStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(defaultOrFirstColor) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Пример с OperationStatus, у которого есть значение по умолчанию &#39;Unknown&#39;</span></div>
<div class="line">    std::string invalidStatusStr = <span class="stringliteral">&quot;NonExistentStatus&quot;</span>;</div>
<div class="line">    OperationStatus status = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;OperationStatus&gt;</a>(invalidStatusStr);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed invalid status string &#39;&quot;</span> &lt;&lt; invalidStatusStr &lt;&lt; <span class="stringliteral">&quot;&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(status) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Unknown&quot;</span></div>
<div class="line"> </div>
<div class="line">    OperationStatus goodStatus = <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;OperationStatus&gt;</a>(<span class="stringliteral">&quot;Success&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Parsed valid status string &#39;Success&#39;: &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(goodStatus) &lt;&lt; std::endl; <span class="comment">// Ожидается: &quot;Success&quot;</span></div>
<div class="line">}</div>
<div class="ttc" id="aenum_8h_html_acf1825d3b8e6ea6b7e5f4dbc5bacae6d"><div class="ttname"><a href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d">DEFINE_ENUM</a></div><div class="ttdeci">#define DEFINE_ENUM(TEnum,...)</div><div class="ttdoc">Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...</div><div class="ttdef"><b>Определения</b> enum.h:57</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_define_enum_impact"></a>
Влияние <span class="tt">DEFINE_ENUM</span></h2>
<p><b>Упрощенное логирование:</b> Поскольку <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span> обычно обрабатывает создание <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a>&lt;std::string, YourEnumType&gt;</span>, значения перечислений могут напрямую использоваться в операторах логирования, и они будут автоматически преобразованы в их удобочитаемые строковые имена: </p><div class="fragment"><div class="line"><span class="comment">// MyColor color = MyColor::Blue;</span></div>
<div class="line"><span class="comment">// LOGI &lt;&lt; &quot;Current color selection: &quot; &lt;&lt; color; // Залогирует &quot;Current color selection: Blue&quot;</span></div>
</div><!-- fragment --><p><b>Бесшовная сериализация:</b> Перечисления, определенные с помощью <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span>, плавно интегрируются с макросами сериализации Iridium. Если вы используете такое перечисление в качестве типа для атрибута: </p><div class="fragment"><div class="line"><span class="comment">// // Предполагая, что MyColor определен с использованием DEFINE_ENUM</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_BEGIN(MyWidgetConfig)</span></div>
<div class="line"><span class="comment">//   DEFINE_ATTRIBUTE(MyColor, WidgetColor)</span></div>
<div class="line"><span class="comment">// DEFINE_ROOT_NODE_END()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MyWidgetConfig config;</span></div>
<div class="line"><span class="comment">// config.WidgetColor = MyColor::Red;</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// // Сериализация &#39;config&#39; сохранит &quot;Red&quot; для атрибута &#39;widget-color&#39;.</span></div>
<div class="line"><span class="comment">// // Десериализация структуры, где &#39;widget-color&#39; равен &quot;Green&quot;, установит config.WidgetColor в MyColor::Green.</span></div>
</div><!-- fragment --><p> Система сериализации использует автоматически сгенерированные специализации <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">convert</a></span> для обработки преобразования между значениями перечислений и их строковыми представлениями в сериализованных данных (например, JSON, XML).</p>
<p>Таким образом, использование <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span> уменьшает количество шаблонного кода, обеспечивает согласованность и делает работу с перечислениями в Iridium намного удобнее. Всегда обращайтесь к конкретному заголовочному файлу <span class="tt"><a class="el" href="enum_8h.html" title="Предоставляет макросы для определения и реализации типобезопасных перечислений с возможностями рефлек...">iridium/enum.h</a></span> или эквивалентному в вашей версии библиотеки для получения точных возможностей и синтаксиса макроса <span class="tt"><a class="el" href="enum_8h.html#acf1825d3b8e6ea6b7e5f4dbc5bacae6d" title="Определяет класс, который инкапсулирует перечисление с областью видимости, обеспечивая строгую типиза...">DEFINE_ENUM</a></span>.</p>
<h1 class="doxsection"><a class="anchor" id="sec_threading"></a>
Примитивы многопоточности</h1>
<p>Библиотека Iridium предоставляет несколько примитивов для помощи в разработке многопоточных приложений. К ним относятся инструменты для прямого управления потоками, синхронизации данных и обработки задач с помощью рабочих потоков и пулов.</p>
<p>Примечание: Некоторые конкретные классы, такие как <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>, <span class="tt"><a class="el" href="class_c_worker.html" title="&quot;Работник&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.">CWorker</a></span> и <span class="tt"><a class="el" href="class_c_worker_pool.html" title="Пул &quot;работников&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.">CWorkerPool</a></span>, находятся в пространстве имен <span class="tt"><a class="el" href="namespaceiridium_1_1threading_1_1implementation.html">iridium::threading::implementation</a></span>. Хотя у них могут быть фабричные методы <span class="tt">::create()</span>, предполагающие удобство использования, это пространство имен обычно указывает на то, что они являются фундаментальными блоками, возможно, предназначенными для обертывания высокоуровневыми абстракциями в некоторых случаях. Однако их прямое использование документируется здесь в соответствии с общими потребностями.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_cthread"></a>
Использование CThread для прямого управления потоками</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_thread.html">iridium::threading::implementation::CThread</a></span> позволяет создавать и управлять выделенным потоком. Он выполняет задачу, определенную объектом, реализующим интерфейс <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html" title="Интерфейс для объектов, которые могут быть запущены в отдельном потоке.">iridium::threading::IRunnable</a></span>.</p>
<p><b>Интерфейс <span class="tt">IRunnable</span>:</b> Чтобы определить работу для <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>, вы создаете класс, который наследуется от <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_runnable.html" title="Интерфейс для объектов, которые могут быть запущены в отдельном потоке.">iridium::threading::IRunnable</a></span>. Этот интерфейс требует реализации следующих методов:</p><ul>
<li><span class="tt">void initialize()</span>: Вызывается один раз после запуска потока для настройки.</li>
<li><span class="tt">void finalize()</span>: Вызывается один раз перед присоединением потока для очистки.</li>
<li><span class="tt">void run(std::atomic&lt;bool&gt;&amp; is_running)</span>: Это основная функция, выполняемая потоком. Она должна содержать логику вашей задачи и периодически проверять флаг <span class="tt">is_running</span>. Когда <span class="tt">is_running</span> становится <span class="tt">false</span>, метод <span class="tt">run</span> должен вернуться, чтобы позволить потоку корректно завершиться.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cthread.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2thread_8h.html">iridium/threading/implementation/thread.h</a>&quot;</span> <span class="comment">// Для CThread</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="runnable_8h.html">iridium/threading/runnable.h</a>&quot;</span>       <span class="comment">// Для IRunnable</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span>         <span class="comment">// Для iridium::threading::sleep, IThread (для getNameStatic)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span> <span class="comment">// Для std::chrono::milliseconds</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// Для std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Реализация IRunnable</span></div>
<div class="line"><span class="keyword">class </span>MyPeriodicTask : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Initializing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">run</a>(std::atomic&lt;bool&gt;&amp; is_running)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (is_running) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;): Working, count: &quot;</span> &lt;&lt; ++counter &lt;&lt; std::endl;</div>
<div class="line">            <span class="comment">// Имитация работы путем сна</span></div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 5 &amp;&amp; is_running; ++i) { <span class="comment">// Проверяйте is_running чаще во время &quot;работы&quot;</span></div>
<div class="line">                 <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(200);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Exiting run loop.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyPeriodicTask (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>()</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Finalizing.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cthread() {</div>
<div class="line">    <span class="comment">// 2. Создание экземпляра вашего IRunnable</span></div>
<div class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;MyPeriodicTask&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Создание и управление CThread</span></div>
<div class="line">    <span class="comment">// CThread::create принимает (имя, IRunnable::TSharedPtr)</span></div>
<div class="line">    <span class="keyword">auto</span> threadObj = iridium::threading::implementation::CThread::create(<span class="stringliteral">&quot;MyWorker1&quot;</span>, task);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Initializing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        threadObj-&gt;initialize(); <span class="comment">// Запускает поток и ожидает его запуска</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Sleeping for 3 seconds while thread runs...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(3000);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Finalizing thread...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        threadObj-&gt;finalize(); <span class="comment">// Сигнализирует потоку остановиться и ожидает его присоединения</span></div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Thread finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Thread operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a5b8c613423cd12e98327a9279d8b9d64"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">iridium::pattern::IInitializable::initialize</a></div><div class="ttdeci">virtual void initialize()=0</div><div class="ttdoc">Выполняет логику инициализации объекта.</div></div>
<div class="ttc" id="aclassiridium_1_1pattern_1_1_i_initializable_html_a93a1fb6f89e1e1f125455a8682e9ae59"><div class="ttname"><a href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">iridium::pattern::IInitializable::finalize</a></div><div class="ttdeci">virtual void finalize()=0</div><div class="ttdoc">Выполняет логику финализации объекта.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a></div><div class="ttdoc">Интерфейс для объектов, которые могут быть запущены в отдельном потоке.</div><div class="ttdef"><b>Определения</b> runnable.h:20</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_runnable_html_a8849596ba04c14d98b200c24491dcd97"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">iridium::threading::IRunnable::run</a></div><div class="ttdeci">virtual void run(std::atomic&lt; bool &gt; &amp;is_running)=0</div><div class="ttdoc">Основная функция, которая будет выполняться в отдельном потоке.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_aebf89ec3258e418ee6141cb9a5adb285"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a></div><div class="ttdeci">static std::string const &amp; getNameStatic()</div><div class="ttdoc">Возвращает имя текущего потока.</div><div class="ttdef"><b>Определения</b> thread.cpp:50</div></div>
<div class="ttc" id="aimplementation_2thread_8h_html"><div class="ttname"><a href="implementation_2thread_8h.html">thread.h</a></div><div class="ttdoc">Определяет класс CThread, конкретную реализацию интерфейса IThread. Этот класс управляет std::thread ...</div></div>
<div class="ttc" id="anamespaceiridium_1_1threading_html_a77efc83dba79715684b3890184b31992"><div class="ttname"><a href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a></div><div class="ttdeci">void sleep(int const &amp;milliseconds)</div><div class="ttdoc">Приостанавливает выполнение текущего потока на указанную продолжительность.</div><div class="ttdef"><b>Определения</b> thread.cpp:40</div></div>
<div class="ttc" id="arunnable_8h_html"><div class="ttname"><a href="runnable_8h.html">runnable.h</a></div></div>
<div class="ttc" id="athread_8h_html"><div class="ttname"><a href="thread_8h.html">thread.h</a></div><div class="ttdoc">Определяет интерфейс IThread и связанные служебные функции для работы с потоками. Включает основной и...</div></div>
</div><!-- fragment --><p> В этом примере <span class="tt">MyPeriodicTask::run</span> будет выполняться в новом потоке, управляемом <span class="tt"><a class="el" href="class_c_thread.html">CThread</a></span>. <span class="tt"><a class="el" href="class_c_thread.html#a39b985df9f70f9502198035353b1eedc" title="Выполняет логику инициализации объекта.">CThread::initialize()</a></span> запускает его, а <span class="tt"><a class="el" href="class_c_thread.html#a66a1d7c2cba19611a23b645843b61474" title="Выполняет логику финализации объекта.">CThread::finalize()</a></span> устанавливает <span class="tt">is_running</span> в <span class="tt">false</span> и присоединяет поток.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_synchronized"></a>
Использование Synchronized для защиты данных</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">iridium::threading::Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</span> — это шаблонный класс, предназначенный для защиты общих данных от одновременного доступа. Обычно он служит базовым классом для классов, содержащих данные, нуждающиеся в защите. Он использует мьютекс (например, <span class="tt">std::mutex</span>) и условную переменную.</p>
<p><b>Ключевой механизм: <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span></b> Макрос <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span> является основным способом взаимодействия с <span class="tt"><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></span>. При размещении внутри метода класса, наследующего от <span class="tt"><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></span>, он создает блокировку с ограниченной областью действия (экземпляр <span class="tt"><a class="el" href="class_synchronized_1_1_locker.html" title="Класс для области видимости блокировки, который захватывает мьютекс объекта Synchronized при создании...">Synchronized::Locker</a></span>). Мьютекс захватывается при обнаружении <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span> и автоматически освобождается при выходе из области действия (благодаря RAII).</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span>    <span class="comment">// Для std::mutex</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span>   <span class="comment">// Для std::chrono</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/threading/implementation/thread.h&quot; // Для более сложной демонстрации с реальными потоками</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс, методы которого будут синхронизированы</span></div>
<div class="line"><span class="keyword">class </span>SafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::string&gt; mItems;</div>
<div class="line">    <span class="keywordtype">int</span> mAccessCount = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addItem(<span class="keyword">const</span> std::string&amp; item) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Блокировка захвачена для этой области</span></div>
<div class="line">        mItems.push_back(item);</div>
<div class="line">        mAccessCount++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItem: Added &#39;&quot; &lt;&lt; item &lt;&lt; &quot;&#39;. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// Мьютекс автоматически освобождается здесь деструктором _____locked_scope_____</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> addItems(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; itemsToAdd) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; itemToAdd : itemsToAdd) { <span class="comment">// Исправлено имя переменной</span></div>
<div class="line">            mItems.push_back(itemToAdd);</div>
<div class="line">        }</div>
<div class="line">        mAccessCount++;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;addItems: Added multiple items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; getItems() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// Возврат по значению гарантирует, что копия будет сделана, пока блокировка удерживается.</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;getItems: Returning copy of items. Lock released upon exiting scope.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">return</span> mItems;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getAccessCount() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="keywordflow">return</span> mAccessCount;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> waitUntilItemCountReaches(<span class="keywordtype">size_t</span> targetCount, std::chrono::milliseconds timeout) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Waiting for item count &quot; &lt;&lt; target_count &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">while</span> (mItems.size() &lt; targetCount) {</div>
<div class="line">            <span class="keywordflow">if</span> (!<a class="code hl_define" href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816">LOCK_SCOPE_TRY_WAIT</a>(timeout)) {</div>
<div class="line">                <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Wait timed out or was interrupted.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Woke up, current count &quot; &lt;&lt; mItems.size() &lt;&lt; std::endl;</span></div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// if (mItems.size() &gt;= targetCount) {</span></div>
<div class="line">        <span class="comment">//     std::cout &lt;&lt; &quot;waitUntilItemCountReaches: Target count reached.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> notifyDataAdded() {</div>
<div class="line">        <span class="comment">// Деструктор Synchronized::Locker автоматически вызывает notify_one.</span></div>
<div class="line">        <span class="comment">// Для явного уведомления (например, всех) потребуется доступ к самой условной переменной.</span></div>
<div class="line">        <span class="comment">// Для этого шаблона вы обычно добавляете данные (что захватывает и освобождает блокировку),</span></div>
<div class="line">        <span class="comment">// и освобождение блокировки уведомляет одного ожидающего.</span></div>
<div class="line">        <span class="comment">// Если вам нужен notify_all, он не предоставляется напрямую только через LOCK_SCOPE для этого простого шаблона.</span></div>
<div class="line">        <span class="comment">// Класс Synchronized имеет m_cv.notify_all() в своем методе interrupt().</span></div>
<div class="line">        <span class="comment">// Этот пример полагается на неявное notify_one при уничтожении Locker.</span></div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Захват блокировки для обеспечения согласованности данных перед потенциальным уведомлением</span></div>
<div class="line">        <span class="comment">// (здесь нет изменения данных, но обычно вы изменяете данные перед уведомлением)</span></div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;notifyDataAdded: Change occurred. Locker destruction will notify one waiter.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized() {</div>
<div class="line">    SafeDataContainer container;</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Apple&quot;</span>);</div>
<div class="line">    container.addItem(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; currentItems = container.getItems();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : currentItems) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Item: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Access count: &quot;</span> &lt;&lt; container.getAccessCount() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Концептуально: поток может ожидать условия</span></div>
<div class="line">    <span class="comment">// std::thread waiter([&amp;](){</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: waiting for 3 items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.waitUntilItemCountReaches(3, std::chrono::seconds(2));</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Waiter thread: finished waiting. Items: &quot; &lt;&lt; container.getItems().size() &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// std::thread adder([&amp;](){</span></div>
<div class="line">    <span class="comment">//    iridium::threading::sleep(500);</span></div>
<div class="line">    <span class="comment">//    std::cout &lt;&lt; &quot;Adder thread: adding &#39;Cherry&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="comment">//    container.addItem(&quot;Cherry&quot;); // Это уведомит одного ожидающего через деструктор Locker</span></div>
<div class="line">    <span class="comment">// });</span></div>
<div class="line">    <span class="comment">// adder.join();</span></div>
<div class="line">    <span class="comment">// waiter.join();</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_synchronized_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a></div><div class="ttdoc">Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...</div><div class="ttdef"><b>Определения</b> synchronized.h:52</div></div>
<div class="ttc" id="asynchronized_8h_html"><div class="ttname"><a href="synchronized_8h.html">synchronized.h</a></div><div class="ttdoc">Определяет шаблон класса Synchronized для создания синхронизированных блоков кода и связанные вспомог...</div></div>
<div class="ttc" id="asynchronized_8h_html_a0286bc5b797a5f1a2ba5c8a832572816"><div class="ttname"><a href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816">LOCK_SCOPE_TRY_WAIT</a></div><div class="ttdeci">#define LOCK_SCOPE_TRY_WAIT(timeout)</div><div class="ttdoc">Вызывает метод wait(timeout) для экземпляра Synchronized::Locker с именем _____locked_scope_____....</div><div class="ttdef"><b>Определения</b> synchronized.h:250</div></div>
<div class="ttc" id="asynchronized_8h_html_aa07286a6c9966cc562c16a85887533fc"><div class="ttname"><a href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a></div><div class="ttdeci">#define LOCK_SCOPE()</div><div class="ttdoc">Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....</div><div class="ttdef"><b>Определения</b> synchronized.h:234</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_synchronized_wait"></a>
Ожидание по условию и прерывание</h2>
<p>Помимо простого взаимного исключения, <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">iridium::threading::Synchronized</a></span> предоставляет механизм, позволяющий потокам ожидать выполнения определенного условия, используя комбинацию блокировки и <span class="tt">std::condition_variable</span>. Это крайне важно для сценариев "производитель-потребитель", где потоку-потребителю необходимо дождаться появления данных.</p>
<ul>
<li><b>Ожидание</b>: Объект <span class="tt"><a class="el" href="class_synchronized_1_1_locker.html" title="Класс для области видимости блокировки, который захватывает мьютекс объекта Synchronized при создании...">Synchronized::Locker</a></span> (создаваемый макросом <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span>) имеет метод <span class="tt">wait()</span>. При его вызове он атомарно освобождает мьютекс и переводит поток в спящий режим. Поток проснётся только тогда, когда другой поток уведомит его (обычно после изменения условия) или если он будет прерван. После пробуждения он автоматически снова захватывает блокировку. В <span class="tt">wait(timeout)</span> можно передать таймаут, чтобы избежать бесконечного ожидания.</li>
<li><b>Уведомление</b>: Когда поток-производитель изменяет общее состояние (например, добавляет элемент в очередь), уничтожение его <span class="tt"><a class="el" href="class_synchronized_1_1_locker.html" title="Класс для области видимости блокировки, который захватывает мьютекс объекта Synchronized при создании...">Synchronized::Locker</a></span> в конце области видимости автоматически вызывает <span class="tt">notify_one()</span> для условной переменной. Это пробуждает <em>один</em> из ожидающих потоков.</li>
<li><b>Прерывание</b>: Базовый класс <span class="tt"><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></span> предоставляет метод <span class="tt">interrupt()</span>. Его вызов пробуждает <em>все</em> ожидающие потоки. Когда ожидающий поток пробуждается из-за прерывания, его вызов <span class="tt">wait()</span> или <span class="tt">wait(timeout)</span> вернёт <span class="tt">false</span>, позволяя потоку понять, что он был прерван, а не уведомлен должным образом. Это чистый способ сигнализировать потокам о необходимости завершить работу.</li>
</ul>
<p>Макрос <span class="tt"><a class="el" href="synchronized_8h.html#a0286bc5b797a5f1a2ba5c8a832572816" title="Вызывает метод wait(timeout) для экземпляра Synchronized::Locker с именем _____locked_scope_____....">LOCK_SCOPE_TRY_WAIT(timeout)</a></span> является удобным помощником. Он захватывает блокировку и немедленно начинает ожидать по условию, возвращая <span class="tt">true</span> при уведомлении и <span class="tt">false</span>, если время ожидания истекло или произошло прерывание.</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized_wait.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2thread_8h.html">iridium/threading/implementation/thread.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Потокобезопасная очередь для сценария &quot;производитель-потребитель&quot;</span></div>
<div class="line"><span class="keyword">class </span>SafeMessageQueue : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::queue&lt;std::string&gt; mQueue;</div>
<div class="line">    <span class="keywordtype">bool</span> mIsFinished = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Производитель добавляет сообщение в очередь</span></div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Блокировка освобождается в конце области видимости, уведомляя одного ожидающего</span></div>
<div class="line">        mQueue.push(msg);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Производитель: Добавлено сообщение &#39;&quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Потребитель пытается получить сообщение, ожидая, если очередь пуста</span></div>
<div class="line">    <span class="keywordtype">bool</span> pop(std::string&amp; msg, std::chrono::milliseconds timeout) {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Захват блокировки</span></div>
<div class="line">        <span class="keywordflow">while</span> (mQueue.empty() &amp;&amp; !mIsFinished) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Потребитель: Очередь пуста, ожидание...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">if</span> (!_____locked_scope_____.wait(timeout)) {</div>
<div class="line">                <span class="comment">// Время ожидания истекло или произошло прерывание</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Потребитель: Ожидание завершено. Прервано: &quot;</span> &lt;&lt; isInterrupted() &lt;&lt; <span class="stringliteral">&quot;, Истекло время: &quot;</span> &lt;&lt; !isInterrupted() &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!mQueue.empty()) {</div>
<div class="line">            msg = mQueue.front();</div>
<div class="line">            mQueue.pop();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Очередь пуста и работа завершена</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Сигнал о том, что больше элементы добавляться не будут</span></div>
<div class="line">    <span class="keywordtype">void</span> finish() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>();</div>
<div class="line">        mIsFinished = <span class="keyword">true</span>;</div>
<div class="line">        <span class="comment">// Примечание: уничтожение locker&#39;а уведомит один поток.</span></div>
<div class="line">        <span class="comment">// Чтобы разбудить все потоки, лучше использовать явное прерывание.</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Производитель: Сигнал о завершении.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- Runnable для потока-потребителя ---</span></div>
<div class="line"><span class="keyword">class </span>ConsumerTask : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_runnable.html">iridium::threading::IRunnable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> ConsumerTask(SafeMessageQueue&amp; queue) : m_queue(queue) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1threading_1_1_i_runnable.html#a8849596ba04c14d98b200c24491dcd97">run</a>(std::atomic&lt;bool&gt;&amp; is_running)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">while</span> (is_running) {</div>
<div class="line">            std::string msg;</div>
<div class="line">            <span class="keywordflow">if</span> (m_queue.pop(msg, std::chrono::milliseconds(500))) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Потребитель: Получено сообщение &#39;&quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Если pop возвращает false, это может быть таймаут, прерывание,</span></div>
<div class="line">                <span class="comment">// или завершение работы очереди. Проверяем is_running, чтобы решить, нужно ли выходить.</span></div>
<div class="line">                <span class="keywordflow">if</span> (!is_running) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Потребитель: Завершение работы.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SafeMessageQueue&amp; m_queue;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized_wait() {</div>
<div class="line">    SafeMessageQueue queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Запуск потока-потребителя</span></div>
<div class="line">    <span class="keyword">auto</span> consumerRunnable = std::make_shared&lt;ConsumerTask&gt;(queue);</div>
<div class="line">    <span class="keyword">auto</span> consumerThread = iridium::threading::implementation::CThread::create(<span class="stringliteral">&quot;Consumer&quot;</span>, consumerRunnable);</div>
<div class="line">    consumerThread-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Логика производителя (в основном потоке)</span></div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(100); <span class="comment">// Даем потребителю время запуститься и начать ожидание</span></div>
<div class="line">    queue.push(<span class="stringliteral">&quot;Привет&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(100);</div>
<div class="line">    queue.push(<span class="stringliteral">&quot;Мир&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(800); <span class="comment">// Позволяем потребителю один раз выйти по таймауту</span></div>
<div class="line">    queue.push(<span class="stringliteral">&quot;И доброй ночи&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="namespaceiridium_1_1threading.html#a77efc83dba79715684b3890184b31992">iridium::threading::sleep</a>(200);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Остановка потока-потребителя</span></div>
<div class="line">    <span class="comment">// CThread::finalize() установит atomic&lt;bool&gt; в false,</span></div>
<div class="line">    <span class="comment">// и pop() в конечном итоге выйдет по таймауту или будет разблокирован, увидит флаг и завершится.</span></div>
<div class="line">    <span class="comment">// для более немедленного завершения мы могли бы вызвать queue.interrupt().</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Завершение потока потребителя.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    consumerThread-&gt;finalize();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Демонстрация завершена.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">int main() {</span></div>
<div class="line"><span class="comment">    demo_synchronized_wait();</span></div>
<div class="line"><span class="comment">    return 0;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_synchronized_logging"></a>
Логирование операций мьютекса</h2>
<p>Второй шаблонный параметр <span class="tt">is_tracable</span> в <span class="tt"><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a>&lt;TMutex, bool is_tracable = false&gt;</span> можно установить в <span class="tt">true</span> для включения диагностического логирования операций мьютекса. Это может быть полезно для отладки проблем, связанных с блокировками, или для понимания поведения синхронизации в вашем приложении.</p>
<p>Когда трассировка включена, операции захвата и освобождения мьютекса, выполняемые через <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span>, будут выводить диагностическую информацию.</p>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_synchronized_traceable.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synchronized_8h.html">iridium/threading/synchronized.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">iridium/threading/thread.h</a>&quot;</span> <span class="comment">// Для IThread::getNameStatic для контекста в выводе</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span> <span class="comment">// Для std::thread для демонстрации вывода</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс с возможностью трассировки операций мьютекса</span></div>
<div class="line"><span class="keyword">class </span>TraceableSafeDataContainer : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_synchronized.html">iridium::threading::Synchronized</a>&lt;std::mutex, true&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> doSomething() {</div>
<div class="line">        <a class="code hl_define" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc">LOCK_SCOPE</a>(); <span class="comment">// Операции блокировки и разблокировки будут залогированы</span></div>
<div class="line">        <span class="comment">// ... какая-то работа с защищенными данными ...</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;TraceableSafeDataContainer (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Executing doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_synchronized_traceable() {</div>
<div class="line">    TraceableSafeDataContainer container;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main thread (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;): Calling doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    container.doSomething();</div>
<div class="line"> </div>
<div class="line">    std::thread t1([&amp;]() {</div>
<div class="line">        <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a>(<span class="stringliteral">&quot;WorkerThread1&quot;</span>); <span class="comment">// Устанавливаем имя потока для лога</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;WorkerThread1 (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;): Calling doSomething.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        container.doSomething();</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    t1.join();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Main thread (&quot;</span> &lt;&lt; <a class="code hl_function" href="classiridium_1_1threading_1_1_i_thread.html#aebf89ec3258e418ee6141cb9a5adb285">iridium::threading::IThread::getNameStatic</a>() </div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;): WorkerThread1 finished.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">int main() {</span></div>
<div class="line"><span class="comment">    demo_synchronized_traceable();</span></div>
<div class="line"><span class="comment">    return 0;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_thread_html_a065f967a26a86efde891ec209094560d"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d">iridium::threading::IThread::setNameStatic</a></div><div class="ttdeci">static void setNameStatic(std::string const &amp;name)</div><div class="ttdoc">Устанавливает имя текущего потока.</div><div class="ttdef"><b>Определения</b> thread.cpp:57</div></div>
</div><!-- fragment --><p>Когда используется <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span> с включенной трассировкой, операторы <span class="tt">printf</span> (или аналогичный механизм логирования низкого уровня, используемый реализацией) будут выводить информацию о захвате (<span class="tt">LM</span>) и освобождении (<span class="tt">UM</span>) мьютекса. Этот вывод обычно включает имя текущего потока (если установлено через <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_thread.html#a065f967a26a86efde891ec209094560d" title="Устанавливает имя текущего потока.">iridium::threading::IThread::setNameStatic()</a></span>), исходный файл и номер строки, где была выполнена операция блокировки/разблокировки.</p>
<p>Пример ожидаемого формата вывода: </p><div class="fragment"><div class="line">ThreadName LM</div>
<div class="line">path/to/source.cpp:LINE_NUMBER</div>
<div class="line">TraceableSafeDataContainer (ThreadName): Executing doSomething.</div>
<div class="line">ThreadName UM</div>
<div class="line">path/to/source.cpp:LINE_NUMBER</div>
</div><!-- fragment --><p> Здесь <span class="tt">ThreadName</span> — это имя потока, <span class="tt">LM</span> означает "Lock Mutex" (захват мьютекса), а <span class="tt">UM</span> — "Unlock Mutex" (освобождение мьютекса). <span class="tt">path/to/source.cpp:LINE_NUMBER</span> указывает точное место в коде, где был вызван <span class="tt"><a class="el" href="synchronized_8h.html#aa07286a6c9966cc562c16a85887533fc" title="Создает экземпляр Synchronized::Locker с именем _____locked_scope_____ для текущей области видимости....">LOCK_SCOPE()</a></span>.</p>
<p>Операции ожидания на объекте <span class="tt">Locker</span> (например, <span class="tt">wait()</span> или <span class="tt">wait(timeout)</span>) также логируются с маркером "WM" (Wait Mutex), предоставляя аналогичную контекстную информацию. Это помогает отслеживать, когда потоки начинают ожидать по условной переменной и когда они пробуждаются.</p>
<p>Класс <span class="tt"><a class="el" href="class_synchronized.html" title="Шаблонный класс, предоставляющий примитивы синхронизации (мьютекс и условная переменная) для защиты о...">Synchronized</a></span> делает методы <span class="tt">SafeDataContainer</span> потокобезопасными. Деструктор <span class="tt">Locker</span> также вызывает <span class="tt">notify_one()</span> для внутренней условной переменной, которая может использоваться с методами <span class="tt">Locker::wait()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_cworker"></a>
Использование CWorker для обработки задач</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html" title="&quot;Работник&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.">iridium::threading::implementation::CWorker</a>&lt;TInputItem, TOutputItem&gt;</span> предоставляет один рабочий поток, который обрабатывает элементы из входной очереди и может помещать результаты в выходную очередь.</p>
<p><b>Интерфейс <span class="tt"><a class="el" href="class_i_worker_1_1_i_handler.html" title="Интерфейс для обработчика, который обрабатывает элементы.">IWorker::IHandler</a></span>:</b> Вы определяете класс-обработчик, наследующий от <span class="tt"><a class="el" href="classiridium_1_1threading_1_1_i_worker.html" title="Интерфейс для &quot;работника&quot;, который обрабатывает элементы, принимая входные данные и производя выходны...">iridium::threading::IWorker</a>&lt;TInputItem, TOutputItem&gt;::IHandler</span>. Его основной метод:</p><ul>
<li><span class="tt">TOutputItems handle(const TInputItems&amp; items)</span>: Получает список элементов из входной очереди и должен возвращать список выходных элементов.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworker.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="implementation_2worker_8h.html">iridium/threading/implementation/worker.h</a>&quot;</span> <span class="comment">// Для CWorker</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// Для IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Для std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// Для toupper</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// Для std::make_shared</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Определение обработчика</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandler : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Initializing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/* std::cout &lt;&lt; &quot;Handler: Finalizing&quot; &lt;&lt; std::endl; */</span> }</div>
<div class="line"> </div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Handler: Received &quot; &lt;&lt; items.size() &lt;&lt; &quot; items to process.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); }); <span class="comment">// Обеспечение приведения к char</span></div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_worker&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworker() {</div>
<div class="line">    <span class="keyword">auto</span> handler = std::make_shared&lt;ToUpperStringHandler&gt;();</div>
<div class="line">    <span class="keyword">auto</span> worker = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyStringToUpperWorker&quot;</span>, handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &#39;alpha&#39; and &#39;beta&#39;.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;push(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">        worker-&gt;push(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;gamma&quot;</span>});</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker&lt;std::string, std::string&gt;::TOutputItems</a> processed_batch;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// CWorkerRunnable обрабатывает по одному элементу из входной очереди за раз,</span></div>
<div class="line">        <span class="comment">// вызывает обработчик (который получает список из 1 элемента),</span></div>
<div class="line">        <span class="comment">// и обработчик возвращает список выходных элементов.</span></div>
<div class="line">        <span class="comment">// Таким образом, каждый вызов pop() будет извлекать результаты одного вызова handle().</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;alpha&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;<a class="code hl_function" href="classiridium_1_1threading_1_1_i_async_queue_popper.html#aa693ab6107a6faca36d0db9a5a30a044">pop</a>(<span class="keyword">true</span>); <span class="comment">// true означает ожидание</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;beta&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Результаты для &quot;gamma&quot;</span></div>
<div class="line">        processed_batch = worker-&gt;pop(<span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : processed_batch) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Popped CWorker result: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        worker-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: CWorker operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_async_queue_popper_html_aa693ab6107a6faca36d0db9a5a30a044"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_async_queue_popper.html#aa693ab6107a6faca36d0db9a5a30a044">iridium::threading::IAsyncQueuePopper::pop</a></div><div class="ttdeci">virtual TItems pop(bool const &amp;is_wait_required=true)=0</div><div class="ttdoc">Извлекает элементы из очереди.</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1_i_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a></div><div class="ttdoc">Интерфейс для &quot;работника&quot;, который обрабатывает элементы, принимая входные данные и производя выходны...</div><div class="ttdef"><b>Определения</b> worker.h:74</div></div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker.html">iridium::threading::implementation::CWorker</a></div><div class="ttdoc">&quot;Работник&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.</div><div class="ttdef"><b>Определения</b> worker.h:93</div></div>
<div class="ttc" id="aimplementation_2worker_8h_html"><div class="ttname"><a href="implementation_2worker_8h.html">worker.h</a></div></div>
<div class="ttc" id="aworker_8h_html"><div class="ttname"><a href="worker_8h.html">worker.h</a></div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="subsec_cworkerpool"></a>
Использование CWorkerPool для параллельной обработки задач</h2>
<p><span class="tt"><a class="el" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html" title="Пул &quot;работников&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.">iridium::threading::implementation::CWorkerPool</a>&lt;TInputItem, TOutputItem&gt;</span> управляет пулом из нескольких рабочих потоков для параллельной обработки элементов из общей входной очереди в общую выходную очередь.</p>
<p><b>Ключевые аспекты:</b></p><ul>
<li>Конструктор принимает список общих указателей <span class="tt">IHandler</span> (<span class="tt">THandlers</span>).</li>
<li>Помещенные элементы распределяются между рабочими потоками.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// mainpage_example_cworkerpool.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker__pool_8h.html">iridium/threading/implementation/worker_pool.h</a>&quot;</span> <span class="comment">// Для CWorkerPool</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="worker_8h.html">iridium/threading/worker.h</a>&quot;</span> <span class="comment">// Для IWorker::IHandler</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>    <span class="comment">// Для std::make_shared</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Для std::transform</span></div>
<div class="line"><span class="preprocessor">#include &lt;cctype&gt;</span>    <span class="comment">// Для toupper</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO </span><span class="comment">// Защита, если включено несколько раз</span></div>
<div class="line"><span class="preprocessor">#define TOUPPERSTRINGHANDLER_DEFINED_FOR_POOL_DEMO</span></div>
<div class="line"><span class="keyword">class </span>ToUpperStringHandlerForPool : <span class="keyword">public</span> <a class="code hl_class" href="classiridium_1_1threading_1_1_i_worker.html">iridium::threading::IWorker</a>&lt;std::string, std::string&gt;::IHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string handler_id_;</div>
<div class="line">    ToUpperStringHandlerForPool(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>) : handler_id_(id) {}</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a5b8c613423cd12e98327a9279d8b9d64">initialize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Init&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="classiridium_1_1pattern_1_1_i_initializable.html#a93a1fb6f89e1e1f125455a8682e9ae59">finalize</a>()<span class="keyword"> override </span>{ <span class="comment">/*std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Final&quot; &lt;&lt; std::endl;*/</span> }</div>
<div class="line">    TOutputItems handle(<span class="keyword">const</span> TInputItems&amp; items)<span class="keyword"> override </span>{</div>
<div class="line">        TOutputItems results;</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; handler_id_ &lt;&lt; &quot;: Handling &quot; &lt;&lt; items.size() &lt;&lt; &quot; items.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            std::string upper_item = item;</div>
<div class="line">            std::transform(upper_item.begin(), upper_item.end(), upper_item.begin(),</div>
<div class="line">                           [](<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c){ return static_cast&lt;char&gt;(std::toupper(c)); });</div>
<div class="line">            results.push_back(upper_item + <span class="stringliteral">&quot;_processed_by_pool_&quot;</span> + handler_id_);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> demo_cworkerpool() {</div>
<div class="line">    <span class="keywordtype">int</span> num_pool_threads = 2;</div>
<div class="line">    std::list&lt;iridium::threading::IWorker&lt;std::string, std::string&gt;::IHandler::TSharedPtr&gt; handlers_list;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_pool_threads; ++i) {</div>
<div class="line">        handlers_list.push_back(std::make_shared&lt;ToUpperStringHandlerForPool&gt;(<span class="stringliteral">&quot;H&quot;</span> + std::to_string(i)));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> pool = <a class="code hl_class" href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool&lt;std::string, std::string&gt;::create</a>(<span class="stringliteral">&quot;MyDemoPool&quot;</span>, handlers_list);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Initializing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;initialize();</div>
<div class="line"> </div>
<div class="line">        std::vector&lt;std::string&gt; all_tasks = {<span class="stringliteral">&quot;task1&quot;</span>, <span class="stringliteral">&quot;task2&quot;</span>, <span class="stringliteral">&quot;task3&quot;</span>, <span class="stringliteral">&quot;task4&quot;</span>, <span class="stringliteral">&quot;task5&quot;</span>};</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Pushing &quot; &lt;&lt; all_tasks.size() &lt;&lt; &quot; tasks to the pool.&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;push(all_tasks); <span class="comment">// Помещение пакета. Они будут добавлены в общую входную очередь.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Сбор результатов. Каждый рабочий поток обрабатывает по одному элементу из входной очереди за раз,</span></div>
<div class="line">        <span class="comment">// его обработчик создает список выходных элементов, которые добавляются в выходную очередь пула.</span></div>
<div class="line">        <span class="comment">// Таким образом, мы ожидаем извлечь &#39;all_tasks.size()&#39; списков результатов.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; all_tasks.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> results_batch = pool-&gt;pop(<span class="keyword">true</span>); <span class="comment">// Ожидание пакета результатов от одного вызова обработчика</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; res : results_batch) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Main: Pool result: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Finalizing worker pool...&quot; &lt;&lt; std::endl;</span></div>
<div class="line">        pool-&gt;finalize();</div>
<div class="line">        <span class="comment">// std::cout &lt;&lt; &quot;Main: Worker pool finished.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Main: Worker Pool operation failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassiridium_1_1threading_1_1implementation_1_1_c_worker_pool_html"><div class="ttname"><a href="classiridium_1_1threading_1_1implementation_1_1_c_worker_pool.html">iridium::threading::implementation::CWorkerPool</a></div><div class="ttdoc">Пул &quot;работников&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.</div><div class="ttdef"><b>Определения</b> worker_pool.h:119</div></div>
<div class="ttc" id="aworker__pool_8h_html"><div class="ttname"><a href="worker__pool_8h.html">worker_pool.h</a></div></div>
</div><!-- fragment --><p> <span class="tt"><a class="el" href="class_c_worker_pool.html" title="Пул &quot;работников&quot;, который обрабатывает элементы из входной очереди и добавляет их в выходную очередь.">CWorkerPool</a></span> эффективен для распараллеливания независимых задач. Порядок результатов из <span class="tt">pop</span> может не строго соответствовать порядку <span class="tt">push</span>.</p>
<p>Эти примитивы предоставляют фундаментальные инструменты для создания параллельных и многопоточных приложений с использованием Iridium.</p>
<h1 class="doxsection"><a class="anchor" id="sec_testing"></a>
Тестирование с Iridium</h1>
<p>Библиотека Iridium предоставляет встроенный фреймворк для написания и запуска модульных тестов, а также для создания мок-объектов для изоляции тестируемого кода. Этот фреймворк помогает обеспечить качество и надежность кода, разработанного с использованием Iridium.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_core_concepts"></a>
Основные концепции</h2>
<p>Фундаментом системы тестирования Iridium являются два ключевых интерфейса/класса:</p>
<ul>
<li><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Интерфейс для запускаемого тестового случая. Конкретные тестовые классы должны реализовывать этот инт...">iridium::testing::ITest</a></span> (определен в <span class="tt"><a class="el" href="test_8h.html">iridium/testing/test.h</a></span>): Это базовый интерфейс для любого запускаемого тестового случая. Каждый класс, представляющий собой тест, должен реализовывать метод <span class="tt">virtual void run() = 0;</span>. В этом методе заключается логика самого теста, включая вызовы тестируемого кода и проверки утверждений (assertions).</li>
<li><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="Базовый класс для модульных тестов, предоставляющий методы утверждений.">iridium::testing::UnitTest</a></span> (определен в <span class="tt"><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></span>): Этот класс служит базовым классом для ваших тестов (обычно неявно через макрос <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST</a></span>). Он предоставляет набор методов для выполнения различных утверждений, таких как проверка равенства, сравнения, истинности условий или выбрасывания ожидаемых исключений. В случае провала утверждения, эти методы генерируют специальное исключение, которое сигнализирует о неудаче теста.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_writing_tests"></a>
Написание тестов</h2>
<p>Основным инструментом для создания тестовых случаев в Iridium является макрос <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST</a></span>.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_test_macro"></a>
Макрос TEST</h3>
<p>Макрос <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST(TestCaseName)</a></span> (определенный в <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>) используется для определения тестового случая. <span class="tt">TestCaseName</span> должно быть уникальным идентификатором для вашего теста. Этот макрос автоматически создает класс, наследующий <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test.html" title="Интерфейс для запускаемого тестового случая. Конкретные тестовые классы должны реализовывать этот инт...">iridium::testing::ITest</a></span> и <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="Базовый класс для модульных тестов, предоставляющий методы утверждений.">iridium::testing::UnitTest</a></span>, и регистрирует его в системе тестирования. Вам нужно только предоставить тело для метода <span class="tt">run()</span>, где будет содержаться логика теста.</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для TEST и макроса ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span>                   <span class="comment">// Для std::string в примере</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span>                <span class="comment">// Для std::runtime_error в примере</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="convert_8h.html">iridium/convertion/convert.h</a>&quot;</span> <span class="comment">// Для iridium::convertion::convert (если нужны свои типы в ASSERT)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример пользовательского типа для демонстрации вывода в ASSERT</span></div>
<div class="line"><span class="keyword">struct </span>MyCustomType {</div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line">    std::string value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Для сравнения в тестах</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyCustomType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> == other.id &amp;&amp; value == other.value;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Специализация convert для MyCustomType, чтобы ASSERT мог ее печатать</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">std::string <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert</a>(MyCustomType <span class="keyword">const</span> &amp;obj) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyCustomType(id=&quot;</span> + <a class="code hl_function" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483">iridium::convertion::convert&lt;std::string&gt;</a>(obj.id) + <span class="stringliteral">&quot;, value=&quot;</span><span class="stringliteral">&quot; + obj.value + &quot;</span><span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Пример тестируемого класса (замените на свой)</span></div>
<div class="line"><span class="keyword">class </span>MyClassToTest {</div>
<div class="line">    std::string param_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassToTest(<span class="keyword">const</span> std::string&amp; p = <span class="stringliteral">&quot;&quot;</span>) : param_(p) {}</div>
<div class="line">    std::string getParameter()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> param_; }</div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
<div class="line">    MyCustomType getCustomType(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; val) { <span class="keywordflow">return</span> {id, val}; }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatThrows() { <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Expected exception&quot;</span>); }</div>
<div class="line">    <span class="keywordtype">void</span> doSomethingThatDoesNotThrow() { <span class="comment">/* No-op */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassConstruction) {</div>
<div class="line">    MyClassToTest obj(<span class="stringliteral">&quot;test_param&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getParameter(), equal, <span class="stringliteral">&quot;test_param&quot;</span>); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassAddsNumbers) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(2, 3), equal, 5);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), greaterEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), lessEqual, 2);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(5, 5), greater, 9);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.add(1, 1), less, 3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyCustomTypeAssertion) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    MyCustomType expected = {1, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.getCustomType(1, <span class="stringliteral">&quot;hello&quot;</span>), equal, expected);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(BooleanAssertions) {</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">true</span>); <span class="comment">// Проверка истинности</span></div>
<div class="line">    <span class="keywordtype">bool</span> my_flag = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(!my_flag); <span class="comment">// Проверка ложности через отрицание</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassThrowsException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(obj.doSomethingThatThrows(), std::runtime_error);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassDoesNotThrowException) {</div>
<div class="line">    MyClassToTest obj;</div>
<div class="line">    <span class="keywordtype">bool</span> did_not_throw = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        obj.doSomethingThatDoesNotThrow();</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        did_not_throw = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(did_not_throw);</div>
<div class="line">}</div>
<div class="ttc" id="atester_8h_html"><div class="ttname"><a href="tester_8h.html">tester.h</a></div></div>
<div class="ttc" id="atester_8h_html_a45feb1f37ce559e49baf8655d769ef85"><div class="ttname"><a href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a></div><div class="ttdeci">#define TEST(name)</div><div class="ttdoc">Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...</div><div class="ttdef"><b>Определения</b> tester.h:150</div></div>
<div class="ttc" id="atester_8h_html_a821326052e3e2bf1fb2d678e9e9a6004"><div class="ttname"><a href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a></div><div class="ttdeci">#define ASSERT(...)</div><div class="ttdoc">Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...</div><div class="ttdef"><b>Определения</b> tester.h:215</div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="subsubsec_testing_assertions"></a>
Макрос утверждений ASSERT</h3>
<p>Класс <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="Базовый класс для модульных тестов, предоставляющий методы утверждений.">iridium::testing::UnitTest</a></span> (от которого неявно наследуются тесты, созданные макросом <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST</a></span>) предоставляет различные методы для проверки условий. Основным способом их использования в тестах является макрос <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(...)</a></span> (определенный в <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>). Если утверждение не выполняется, выбрасывается исключение, и тест помечается как проваленный.</p>
<p>Макрос <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a></span> является вариативным (принимает разное количество аргументов) и используется следующим образом:</p>
<ol type="1">
<li><b>Проверка булева условия: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(condition)</a></span></b><ul>
<li>Используется для проверки истинности (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(true_condition)</a>;</span>) или ложности (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a>(!false_condition);</span>).</li>
<li>Технически, это вызов <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Макрос утверждения для проверки истинности булева условия. Если is_true вычисляется как ложь,...">ASSERT_1</a></span>, который передает <span class="tt">condition</span> в метод <span class="tt">UnitTest::assert_()</span>.</li>
<li>Пример: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a>(x &gt; 5);</span></li>
</ul>
</li>
<li><b>Проверка на сравнение: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, comparison_symbol, value2)</a></span></b><ul>
<li>Используется для различных видов сравнений, где <span class="tt">value1</span> представляет ожидаемое значение, а <span class="tt">value2</span> — фактическое (полученное) значение. <span class="tt">comparison_symbol</span> — это имя метода сравнения из класса <span class="tt">UnitTest</span>.</li>
<li>При сравнении (<span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, comparison_symbol, value2)</a></span>), ожидаемое значение (<span class="tt">value1</span>) приводится к типу фактического значения (<span class="tt">value2</span>). Например, в шаблонных методах <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_unit_test.html" title="Базовый класс для модульных тестов, предоставляющий методы утверждений.">iridium::testing::UnitTest</a></span> (см. <span class="tt"><a class="el" href="unit__test_8h.html">iridium/testing/unit_test.h</a></span>) используется конструкция вида <span class="tt">TRight left_(left);</span> или <span class="tt">static_cast&lt;TRight&gt;(left)</span>, где <span class="tt">left</span> — это <span class="tt">value1</span> (ожидаемое), а <span class="tt">TRight</span> — это тип <span class="tt">value2</span> (фактическое). Таким образом, фактическое сравнение (<span class="tt">left_ == right</span>, <span class="tt">left_ &lt; right</span> и т.д.) происходит между значениями одного типа — типа <span class="tt">TRight</span>. Для преобразования значений в строки при выводе сообщений об ошибках используется <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a></span>.</li>
<li>Технически, это вызов <span class="tt"><a class="el" href="tester_8h.html#add09cced0f90a8f1b3f5af6bb20c423e" title="Макрос утверждения для бинарных условий (например, равенство, неравенство, меньше чем)....">ASSERT_3</a></span>, который вызывает <span class="tt">UnitTest::comparison_symbol(value1, value2, "value1 symbol value2", "<a href="file:line">file:line</a>")</span>.</li>
<li>Доступные <span class="tt">comparison_symbol</span>:<ul>
<li><span class="tt">equal</span>: Проверяет, что <span class="tt">value1 == value2</span>.</li>
<li><span class="tt">less</span>: Проверяет, что <span class="tt">value1 &lt; value2</span>.</li>
<li><span class="tt">lessEqual</span>: Проверяет, что <span class="tt">value1 &lt;= value2</span>.</li>
<li><span class="tt">greater</span>: Проверяет, что <span class="tt">value1 &gt; value2</span>.</li>
<li><span class="tt">greaterEqual</span>: Проверяет, что <span class="tt">value1 &gt;= value2</span>.</li>
</ul>
</li>
<li>Примеры: <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(sum, equal, 10);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(count, less, max_count);</div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(actual_value, greaterEqual, expected_minimum);</div>
</div><!-- fragment --></li>
<li>Примечание: Хотя вы также можете написать <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a>(value1 == value2);</span> (используя <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Макрос утверждения для проверки истинности булева условия. Если is_true вычисляется как ложь,...">ASSERT_1</a></span>), использование <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(value1, equal, value2)</a>;</span> предпочтительнее для сравнений, так как это позволяет фреймворку потенциально выводить значения <span class="tt">value1</span> и <span class="tt">value2</span> при ошибке более информативно.</li>
</ul>
</li>
<li><b>Проверка на выбрасывание исключения: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(expression, ExpectedExceptionType)</a></span></b><ul>
<li>Технически, это вызов <span class="tt"><a class="el" href="tester_8h.html#aca9c4ab6285fc7229020bdeb3c10d50d" title="Макрос утверждения для проверки того, выбрасывает ли данный вызов функции определенное исключение....">ASSERT_2</a></span>, который передает лямбда-функцию с <span class="tt">expression</span> и <span class="tt">ExpectedExceptionType</span> в метод <span class="tt">UnitTest::assert_&lt;TFunction, TException&gt;()</span>.</li>
<li>Проверяет, что выполнение <span class="tt">expression</span> приводит к выбрасыванию исключения типа <span class="tt">ExpectedExceptionType</span> (или его наследника).</li>
<li>Пример: <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a>(myObject.methodThatThrows(), std::runtime_error);</span></li>
</ul>
</li>
<li><b>Безусловный провал теста:</b><ul>
<li>Прямого макроса <span class="tt">FAIL(message)</span> нет. Для безусловного провала теста используйте <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT(false)</a>;</span>. Вы можете добавить комментарий для пояснения причины. <div class="fragment"><div class="line"><a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(<span class="keyword">false</span>); <span class="comment">// Тест провален, так как условие X не выполнено</span></div>
</div><!-- fragment --></li>
</ul>
</li>
</ol>
<p><b>Вывод значений при ошибках и <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a></span>:</b> Очень важной особенностью макроса <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a></span> (особенно при сравнениях) является то, как он отображает значения при сбое утверждения. Чтобы вывести значения <span class="tt">value1</span> и <span class="tt">value2</span> (или значение из <span class="tt">condition</span> для <span class="tt"><a class="el" href="tester_8h.html#a284fe1499ac88d714195dfd772372c44" title="Макрос утверждения для проверки истинности булева условия. Если is_true вычисляется как ложь,...">ASSERT_1</a></span>) в читаемом виде, система тестирования использует <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a>&lt;std::string&gt;(your_value)</span>. Если вы используете в <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a></span> пользовательские типы, убедитесь, что для них существует специализация <span class="tt"><a class="el" href="namespaceiridium_1_1convertion.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">iridium::convertion::convert</a></span> в <span class="tt">std::string</span>. В противном случае, вы можете увидеть неинформативный вывод (например, только имя типа или адрес). Подробнее о создании специализаций <span class="tt"><a class="el" href="factory_8cpp.html#aaf31a5335a6afae5d2fdffcdd0b83483" title="Преобразует значение из исходного типа в целевой.">convert</a></span> см. в разделе <a class="el" href="#sec_custom_type_conversion">Интеграция пользовательских типов с <span class="tt">iridium::convertion::convert</span></a>.</p>
<p>Макрос <span class="tt"><a class="el" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004" title="Макрос-переключатель, который диспетчеризует вызов в ASSERT_1, ASSERT_2 или ASSERT_3 на основе количе...">ASSERT</a></span> автоматически включает имя файла и номер строки в информацию об ошибке, что помогает быстро найти место провала теста.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_running_tests"></a>
Запуск тестов</h2>
<p>После написания тестов их необходимо скомпилировать и запустить. Фреймворк Iridium упрощает этот процесс.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_main"></a>
Макрос IMPLEMENT_TEST_MAIN</h3>
<p>Для создания исполняемого файла, который запустит все определенные тесты, используется макрос <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></span> (определенный в <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>). Этот макрос генерирует стандартную функцию <span class="tt">main()</span>, которая инициализирует и запускает тестовый фреймворк.</p>
<p>Обычно вы создаете отдельный <span class="tt">.cpp</span> файл (например, <span class="tt">tests_main.cpp</span>), который включает все ваши тестовые файлы (или заголовки, если тесты определены в них) и затем вызывает <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></span>.</p>
<p>Пример (<span class="tt">tests_main.cpp</span>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для IMPLEMENT_TEST_MAIN</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Включите здесь ваши тестовые файлы или файлы, где определены тесты TEST(...)</span></div>
<div class="line"><span class="comment">// Например:</span></div>
<div class="line"><span class="comment">// #include &quot;my_class_tests.cpp&quot; </span></div>
<div class="line"><span class="comment">// #include &quot;another_module_tests.cpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a>()</div>
<div class="ttc" id="atester_8h_html_ae18dbf9ed64402b9c94239f90547eceb"><div class="ttname"><a href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb">IMPLEMENT_TEST_MAIN</a></div><div class="ttdeci">#define IMPLEMENT_TEST_MAIN()</div><div class="ttdoc">Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...</div><div class="ttdef"><b>Определения</b> tester.h:227</div></div>
</div><!-- fragment --><p> При компиляции этого файла вместе с вашими тестами и библиотекой Iridium вы получите исполняемый файл, который при запуске выполнит все обнаруженные тесты.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_tester"></a>
Роль класса Tester</h3>
<p>Класс <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_tester.html" title="Класс-одиночка, отвечающий за регистрацию, управление и запуск всех тестов в рамках фреймворка....">iridium::testing::Tester</a></span> (определенный в <span class="tt"><a class="el" href="tester_8h.html">iridium/testing/tester.h</a></span>) является центральным компонентом системы тестирования. Это синглтон, который:</p><ul>
<li>Регистрирует все тестовые случаи, определенные с помощью макроса <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST</a></span>.</li>
<li>Управляет выполнением тестов. Метод <span class="tt">Tester::run(argc, argv, main_cpp_path)</span> вызывается из сгенерированной <span class="tt">main()</span> функции.</li>
<li>Позволяет фильтровать тесты на основе аргументов командной строки (эта функциональность может быть не полностью детализирована здесь, но <span class="tt">Tester</span> ее предусматривает).</li>
<li>Собирает результаты тестов.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_itestrunner"></a>
Интерфейс ITestRunner (для продвинутых сценариев)</h3>
<p>Для более гибкого управления процессом выполнения тестов существует интерфейс <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">iridium::testing::ITestRunner</a></span> (определенный в <span class="tt"><a class="el" href="test__runner_8h.html">iridium/testing/test_runner.h</a></span>). Этот интерфейс абстрагирует способ запуска тестов. Библиотека Iridium предоставляет как минимум две его реализации:</p><ul>
<li><span class="tt">iridium::testing::implementation::TestRunnerRaw</span>: Запускает тесты в том же процессе.</li>
<li><span class="tt">iridium::testing::implementation::TestRunnerFork</span>: Может запускать тесты в отдельных процессах (форках), что обеспечивает лучшую изоляцию (обычно на POSIX-системах).</li>
</ul>
<p>Хотя прямое взаимодействие с <span class="tt"><a class="el" href="class_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">ITestRunner</a></span> обычно не требуется для написания и запуска тестов, знание о его существовании полезно для понимания архитектуры фреймворка и для возможных расширений или кастомизации процесса тестирования. Класс <span class="tt">Tester</span> использует реализацию <span class="tt"><a class="el" href="class_i_test_runner.html" title="Представляет общий результат выполнения тестового прогона. Эта структура обычно сериализуется в/из фа...">ITestRunner</a></span> для фактического выполнения тестов.</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_cli"></a>
Аргументы командной строки</h3>
<p>Исполняемый файл тестов, созданный с помощью <span class="tt"><a class="el" href="tester_8h.html#ae18dbf9ed64402b9c94239f90547eceb" title="Генерирует функцию main() для исполняемого файла тестов. Эта функция main инициализирует Tester singl...">IMPLEMENT_TEST_MAIN()</a></span>, поддерживает следующие аргументы командной строки для управления процессом тестирования. Предположим, ваше приложение для тестов называется <span class="tt">ваше_приложение_тестов</span>.</p>
<ol type="1">
<li><b><span class="tt">help</span></b>: Выводит справочную информацию по использованию. <div class="fragment"><div class="line">./ваше_приложение_тестов help</div>
</div><!-- fragment --> Пример вывода: <div class="fragment"><div class="line">main thread: 281473424756000</div>
<div class="line">2025-06-06 10:30:56.839 I 281473424756000 </div>
<div class="line">usage:</div>
<div class="line">./ваше_приложение_тестов help</div>
<div class="line">./ваше_приложение_тестов list</div>
<div class="line">./ваше_приложение_тестов run [ --mode=raw|serial|parallel ] [ --print-result=json ] [ --timeout=seconds ] [ include_path ] [ exclude_path ] ... [ exclude_path ]</div>
<div class="line">example:</div>
<div class="line">./ваше_приложение_тестов run / </div>
</div><!-- fragment --> (Примечание: фактический номер потока и временная метка в вашем выводе будут отличаться.)</li>
<li><b><span class="tt">list</span></b>: Отображает иерархический список (дерево) всех тестовых случаев, обнаруженных фреймворком. Тесты группируются по пути к файлу и затем по имени теста, определенному в макросе <span class="tt"><a class="el" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85" title="Определяет тестовый случай и регистрирует его в Tester singleton. Этот макрос генерирует уникальный к...">TEST()</a></span>. <div class="fragment"><div class="line">./ваше_приложение_тестов list</div>
</div><!-- fragment --> Это полезно для просмотра структуры тестов и их полных путей, которые могут использоваться в качестве <span class="tt">путь_включения</span> или <span class="tt">путь_исключения</span> для команды <span class="tt">run</span>. Пример вывода: <div class="fragment"><div class="line">main thread: 281473794346272</div>
<div class="line">2025-06-06 10:30:22.166 I 281473794346272 </div>
<div class="line"><span class="stringliteral">&#39;root&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;convertion&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;convert.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;enum_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;strings&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;types&#39;</span></div>
<div class="line">  <span class="stringliteral">&#39;testing&#39;</span></div>
<div class="line">    <span class="stringliteral">&#39;example.cpp&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;bool_&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;comparing_equal&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;exception&#39;</span></div>
<div class="line">      <span class="stringliteral">&#39;mock&#39;</span></div>
<div class="line"><span class="preprocessor">  # ... (и так далее для других модулей и тестов)</span></div>
</div><!-- fragment --> (Примечание: фактический номер потока, временная метка и полный список тестов в вашем выводе будут отличаться.)</li>
<li><p class="startli"><b><span class="tt">run</span></b>: Запускает тесты. Это команда по умолчанию, если не указана другая. </p><div class="fragment"><div class="line">./ваше_приложение_тестов run [опции] [путь_включения] [путь_исключения_1] [путь_исключения_2] ...</div>
</div><!-- fragment --><p> Стандартный вывод при запуске тестов (без <span class="tt">--print-result=json</span>) включает логирование каждого запускаемого теста и его результата: </p><div class="fragment"><div class="line">main thread: 281473243745568</div>
<div class="line">2025-06-06 10:30:39.744 I 281473243745568 RUN  /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/bool_</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 RUN  /testing/example.cpp/comparing_equal</div>
<div class="line">2025-06-06 10:30:39.745 I 281473243745568 OK   /testing/example.cpp/comparing_equal</div>
<div class="line"><span class="preprocessor"># ... (и так далее для других тестов)</span></div>
<div class="line"><span class="preprocessor"># ... (в случае ошибки будет FAILED вместо OK и сообщение об ошибке)</span></div>
<div class="line">2025-06-06 10:30:39.747 I 281473243745568 </div>
<div class="line">passed: 8</div>
<div class="line">failed: 0</div>
<div class="line">total:  51 </div>
</div><!-- fragment --><p> (Примечание: фактические номера потоков, временные метки и результаты в вашем выводе будут отличаться.)</p>
<p class="startli">Доступные опции для команды <span class="tt">run</span>:</p><ul>
<li><span class="tt">--mode=РЕЖИМ</span>: Определяет режим запуска тестов. Возможные значения для <span class="tt">РЕЖИМ</span>:<ul>
<li><span class="tt">raw</span> (по умолчанию): Тесты запускаются в том же процессе.</li>
<li><span class="tt">serial</span>: Тесты запускаются последовательно, каждый в отдельном процессе.</li>
<li><span class="tt">parallel</span>: Тесты запускаются параллельно в отдельных процессах.</li>
</ul>
</li>
<li><span class="tt">--print-result=ФОРМАТ</span>: Управляет форматом вывода результатов.<ul>
<li>Если не указана, используется стандартный текстовый формат (см. пример выше).</li>
<li><span class="tt">json</span>: Результаты выводятся в формате JSON.</li>
</ul>
</li>
<li><span class="tt">--timeout=СЕКУНДЫ</span>: Устанавливает максимальное время ожидания для тестов в секундах (по умолчанию 60).</li>
</ul>
<p class="startli">Параметры команды <span class="tt">run</span>:</p><ul>
<li><span class="tt">путь_включения</span> (необязательный): Если указан, запускаются только тесты, чей путь (как в выводе <span class="tt">list</span>) начинается с <span class="tt">путь_включения</span>. По умолчанию <span class="tt">/</span> (все тесты).</li>
<li><span class="tt">путь_исключения_...</span> (необязательные): Один или несколько путей для исключения. Тесты, чей путь начинается с одного из этих путей, не будут запущены.</li>
</ul>
</li>
</ol>
<p>Примеры использования команды <span class="tt">run</span>:</p>
<ul>
<li>Запустить все тесты: <div class="fragment"><div class="line">./ваше_приложение_тестов run</div>
</div><!-- fragment --> (или просто <span class="tt">./ваше_приложение_тестов</span>)</li>
<li>Запустить все тесты в параллельном режиме с таймаутом 120 секунд: <div class="fragment"><div class="line">./ваше_приложение_тестов run --mode=parallel --timeout=120</div>
</div><!-- fragment --></li>
<li>Запустить только тесты из модуля <span class="tt">testing</span> и файла <span class="tt">example.cpp</span>: <div class="fragment"><div class="line">./ваше_приложение_тестов run /testing/example.cpp/</div>
</div><!-- fragment --></li>
<li>Запустить все тесты из модуля <span class="tt">parsing</span>, но исключить те, что находятся в <span class="tt">node.cpp</span> внутри <span class="tt">parsing</span>: <div class="fragment"><div class="line">./ваше_приложение_тестов run /parsing/ /parsing/node.cpp/</div>
</div><!-- fragment --></li>
<li>Запустить все тесты и вывести результат в формате JSON: <div class="fragment"><div class="line">./ваше_приложение_тестов run --print-result=json</div>
</div><!-- fragment --></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_mocking"></a>
Мокирование зависимостей</h2>
<p>Мокирование (от англ. mocking) — это процесс создания объектов-заменителей (моков или мок-объектов) для имитации поведения реальных зависимостей тестируемого компонента. Это позволяет изолировать тестируемый код и сделать тесты более предсказуемыми и стабильными. Фреймворк тестирования Iridium предоставляет инструменты для создания моков (определенные в <span class="tt"><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></span>).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_defining_mocks"></a>
Определение мок-классов</h3>
<p>Для создания мока для интерфейса или класса используется макрос <span class="tt"><a class="el" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee" title="Определяет &quot;мок&quot;-класс для заданного интерфейса.">DEFINE_MOCK_CLASS(InterfaceName)</a></span>. Этот макрос создает новый класс с именем <span class="tt">InterfaceNameMock</span>, который наследует ваш <span class="tt">InterfaceName</span> и <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для &quot;мок&quot;-объектов.">iridium::testing::Mock</a>&lt;InterfaceName&gt;</span>.</p>
<p>Внутри этого мок-класса вы объявляете, какие методы интерфейса вы хотите мокировать, используя макросы <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span> (для неконстантных методов) и <span class="tt"><a class="el" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530" title="Вариативный макрос для определения &quot;мок&quot;-метода для константной функции-члена.">DEFINE_MOCK_METHOD_CONST</a></span> (для константных методов).</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Предположим, это интерфейс, который мы хотим мокировать</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    <span class="comment">// Конструктор с аргументами для демонстрации DEFINE_MOCK_CONSTRUCTOR</span></div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; <span class="comment">// Добавим конструктор по умолчанию, если он тоже нужен</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Определение мок-класса для IMyDependency</span></div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Если базовый класс IMyDependency имеет конструктор с аргументами,</span></div>
<div class="line">    <span class="comment">// и вы хотите его вызывать из мока:</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Мокирование методов интерфейса</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)          <span class="comment">// int getValue(int key)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)  <span class="comment">// std::string getName() const</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;) <span class="comment">// void processData(const std::vector&lt;int&gt;&amp; data)</span></div>
<div class="line">};</div>
<div class="ttc" id="amock_8h_html"><div class="ttname"><a href="mock_8h.html">mock.h</a></div></div>
<div class="ttc" id="amock_8h_html_a1aa823f3557d4e07d5a6cce9bb497aee"><div class="ttname"><a href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a></div><div class="ttdeci">#define DEFINE_MOCK_CLASS(Interface)</div><div class="ttdoc">Определяет &quot;мок&quot;-класс для заданного интерфейса.</div><div class="ttdef"><b>Определения</b> mock.h:461</div></div>
<div class="ttc" id="amock_8h_html_a45da68ed3f119848c88d8ef01622bcec"><div class="ttname"><a href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD(...)</div><div class="ttdef"><b>Определения</b> mock.h:411</div></div>
<div class="ttc" id="amock_8h_html_a4d8f3f37a1da67b31d455e5086be40f3"><div class="ttname"><a href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a></div><div class="ttdeci">#define DEFINE_MOCK_CONSTRUCTOR(Interface)</div><div class="ttdoc">Определяет конструктор для &quot;мок&quot;-класса.</div><div class="ttdef"><b>Определения</b> mock.h:466</div></div>
<div class="ttc" id="amock_8h_html_ae47eed5af62161b8cb04261fded66530"><div class="ttname"><a href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_METHOD_CONST(...)</div><div class="ttdoc">Вариативный макрос для определения &quot;мок&quot;-метода для константной функции-члена.</div><div class="ttdef"><b>Определения</b> mock.h:456</div></div>
</div><!-- fragment --><p> Макросы <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span> принимают тип возвращаемого значения, имя метода и в круглых скобках типы аргументов метода (без имен переменных).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_mock_behavior"></a>
Определение поведения моков</h3>
<p>После создания экземпляра мок-объекта вы можете определить его поведение с помощью макроса <span class="tt"><a class="el" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576" title="Определяет поведение &quot;мок&quot;-метода.">DEFINE_MOCK_BEHAVIOR</a></span> (для неконстантных методов) или <span class="tt"><a class="el" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15" title="Определяет поведение константного &quot;мок&quot;-метода.">DEFINE_MOCK_BEHAVIOR_CONST</a></span> (для константных методов). Этот макрос позволяет присвоить лямбда-функцию, которая будет вызываться при обращении к мокированному методу.</p>
<p>Пример: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span> <span class="comment">// Для ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span>   <span class="comment">// Для макросов мокирования</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span> <span class="comment">// Для std::runtime_error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Для полноты примера, скопируем определения IMyDependency и IMyDependencyMock сюда</span></div>
<div class="line"><span class="comment">// В реальном коде они были бы в заголовочных файлах</span></div>
<div class="line"><span class="keyword">class </span>IMyDependency {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMyDependency() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> getValue(<span class="keywordtype">int</span> key) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string getName() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> processData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) = 0;</div>
<div class="line">    IMyDependency(<span class="keyword">const</span> std::string&amp; <span class="comment">/* initial_config */</span>) {} </div>
<div class="line">    IMyDependency() = <span class="keywordflow">default</span>; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(IMyDependency) {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(IMyDependency)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">int</span>, getValue, <span class="keywordtype">int</span>)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#ae47eed5af62161b8cb04261fded66530">DEFINE_MOCK_METHOD_CONST</a>(std::string, getName)</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(<span class="keywordtype">void</span>, processData, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;)</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Конец скопированных определений</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Класс, который использует IMyDependency</span></div>
<div class="line"><span class="keyword">class </span>MyClassUsesDependency {</div>
<div class="line">    IMyDependency* dependency_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClassUsesDependency(IMyDependency* dep) : dependency_(dep) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> fetchValue(<span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Key cannot be negative&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getValue(key);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string getDepName()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> dependency_-&gt;getName();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> sendData(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; data) {</div>
<div class="line">        dependency_-&gt;processData(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(MyClassUsesDependency_Behavior) {</div>
<div class="line">    IMyDependencyMock mockDep; <span class="comment">// Создаем экземпляр мока</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем поведение для getValue</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">int</span>, getValue, mockDep, <span class="keywordtype">int</span> key) {</div>
<div class="line">        <span class="comment">// Это лямбда-функция: [=](int key_param) -&gt; int { ... }</span></div>
<div class="line">        <span class="comment">// Имена параметров в лямбде могут быть любыми, но типы должны совпадать с объявленными в DEFINE_MOCK_METHOD</span></div>
<div class="line">        <span class="keywordflow">if</span> (key == 1) <span class="keywordflow">return</span> 100;</div>
<div class="line">        <span class="keywordflow">if</span> (key == 42) <span class="keywordflow">return</span> 420;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Определяем поведение для getName (константный метод)</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a>(std::string, getName, mockDep) {</div>
<div class="line">        <span class="comment">// Лямбда для метода без аргументов: [=]() -&gt; std::string { ... }</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;MockedName&quot;</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Определяем поведение для processData (void метод)</span></div>
<div class="line">    std::vector&lt;int&gt; received_data;</div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(<span class="keywordtype">void</span>, processData, mockDep, <span class="keyword">const</span> std::vector&lt;int&gt; &amp;data) {</div>
<div class="line">        <span class="comment">// Лямбда для void метода: [=](const std::vector&lt;int&gt;&amp; data_param) -&gt; void { ... }</span></div>
<div class="line">        received_data = data; <span class="comment">// Копируем данные для проверки</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClassUsesDependency mainObj(&amp;mockDep);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(1),   equal, 100);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(42),  equal, 420);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(10),  equal, -1);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.getDepName(),    equal, <span class="stringliteral">&quot;MockedName&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int&gt; data_to_send = {1, 2, 3};</div>
<div class="line">    mainObj.sendData(data_to_send);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data.size(),    equal, 3);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(received_data[0],        equal, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Проверка вызова исключения из основного класса, не из мока</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(mainObj.fetchValue(-1), std::runtime_error);</div>
<div class="line">}</div>
<div class="ttc" id="amock_8h_html_a8178900fca49688815d093d8c46b1c15"><div class="ttname"><a href="mock_8h.html#a8178900fca49688815d093d8c46b1c15">DEFINE_MOCK_BEHAVIOR_CONST</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR_CONST(result_type, method_name, mock_object,...)</div><div class="ttdoc">Определяет поведение константного &quot;мок&quot;-метода.</div><div class="ttdef"><b>Определения</b> mock.h:485</div></div>
<div class="ttc" id="amock_8h_html_aed1edc22e98dd2dc94c0368764223576"><div class="ttname"><a href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a></div><div class="ttdeci">#define DEFINE_MOCK_BEHAVIOR(result_type, method_name, mock_object,...)</div><div class="ttdoc">Определяет поведение &quot;мок&quot;-метода.</div><div class="ttdef"><b>Определения</b> mock.h:473</div></div>
</div><!-- fragment --><p> В лямбда-функции, определяющей поведение, вы можете получить доступ к аргументам, с которыми был вызван мокированный метод, и вернуть соответствующее значение или выполнить необходимые действия. Типы аргументов в лямбде должны совпадать с типами, указанными в <span class="tt"><a class="el" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a></span>.</p>
<p>Использование <span class="tt"><a class="el" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3" title="Определяет конструктор для &quot;мок&quot;-класса.">DEFINE_MOCK_CONSTRUCTOR</a></span> необходимо, если ваш исходный интерфейс/класс имеет конструкторы с параметрами, которые вы хотите вызывать при создании мок-объекта (например, если мок наследует от класса, а не чистого интерфейса, и конструктор базового класса должен быть вызван).</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_mock_auto_creation"></a>
Автоматическое создание и предоставление мок-объектов через <span class="tt">create()</span></h3>
<p>Фреймворк Iridium предоставляет механизм, позволяющий статическим методам <span class="tt">create()</span> возвращать мок-объекты вместо реальных во время тестирования. Это особенно полезно, когда тестируемый класс создает свои зависимости внутри себя. Понимание этого механизма требует рассмотрения нескольких макросов и пользовательских соглашений.</p>
<p><b>Ключевые макросы и их взаимодействие:</b></p>
<ol type="1">
<li><b><span class="tt">DEFINE_MOCK_CREATE</span> (символ препроцессора):</b><ul>
<li>Это <b>символ препроцессора</b>, который пользователи должны определять для своих тестовых сборок. Это можно сделать, например, добавив <span class="tt">#define DEFINE_MOCK_CREATE</span> в начале тестового файла (до включения заголовочных файлов Iridium, таких как <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></span>) или через опцию компилятора (например, <span class="tt">-DDEFINE_MOCK_CREATE</span>).</li>
<li>Макрос Iridium <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE(TClass)</a></span> (находящийся в <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></span>) использует директиву препроцессора <span class="tt">#ifdef DEFINE_MOCK_CREATE</span> для условной компиляции статического метода <span class="tt">TClass::create(...)</span>.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE(TClass)</a></span> (макрос Iridium из <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>Этот макрос генерирует статический метод <span class="tt">TClass::create(...)</span>.</li>
<li>Благодаря проверке <span class="tt">#ifdef DEFINE_MOCK_CREATE</span> внутри <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE</a></span>:<ul>
<li>Если <span class="tt">DEFINE_MOCK_CREATE</span> определен на момент обработки <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE(TClass)</a></span>, то результирующий метод <span class="tt">TClass::create(...)</span> будет вызывать <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для &quot;мок&quot;-объектов.">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</span>.</li>
<li>Если <span class="tt">DEFINE_MOCK_CREATE</span> <em>не</em> определен, то <span class="tt">TClass::create(...)</span> будет вызывать <span class="tt">std::make_shared&lt;TClass&gt;(...)</span> для создания реального объекта.</li>
</ul>
</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для &quot;мок&quot;-объектов.">iridium::testing::Mock</a>&lt;TClass&gt;::create(...)</span> (из <span class="tt"><a class="el" href="mock_8h.html">iridium/testing/mock.h</a></span>):</b><ul>
<li>Этот метод вызывается, когда <span class="tt">TClass::create(...)</span> был сгенерирован в "мок-режиме" (благодаря <span class="tt">DEFINE_MOCK_CREATE</span>).</li>
<li>Он проверяет внутренний статический флаг <span class="tt">Mock&lt;TClass&gt;::m_is_mocked</span>.</li>
<li>Если <span class="tt">m_is_mocked == true</span> (этот флаг устанавливается при создании экземпляра мок-класса, например, <span class="tt">TClassMock</span>), то <span class="tt">Mock&lt;TClass&gt;::create(...)</span> пытается вернуть ранее зарегистрированный экземпляр <span class="tt">TClassMock</span>. Если подходящих моков нет, выбрасывается исключение.</li>
<li>Если <span class="tt">m_is_mocked == false</span>, то <span class="tt">Mock&lt;TClass&gt;::create(...)</span> пытается создать реальный объект через <span class="tt">std::make_shared&lt;TClass&gt;(...)</span>. <b>Важно:</b> если <span class="tt">TClass</span> является абстрактным интерфейсом, эта попытка приведет к ошибке компиляции.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...">DEFINE_IMPLEMENTATION(TClass)</a></span> (из <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>Этот макрос Iridium используется для конкретных классов. Он внутри себя вызывает <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE(TClass)</a></span>.</li>
<li>Следовательно, статический метод <span class="tt">create()</span> для классов, определенных с <span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...">DEFINE_IMPLEMENTATION</a></span>, будет автоматически поддерживать переключение между реальным созданием и мок-созданием в зависимости от наличия <span class="tt">DEFINE_MOCK_CREATE</span>.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE(Interface)</a></span> (из <span class="tt"><a class="el" href="smart__ptr_8h.html" title="Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...">iridium/smart_ptr.h</a></span>):</b><ul>
<li>Этот макрос Iridium используется для определения интерфейсов. Он определяет typedef-ы для умных указателей и виртуальный деструктор.</li>
<li><b>Важно:</b> <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE</a></span> <b>не использует</b> <span class="tt"><a class="el" href="smart__ptr_8h.html#a7b255e639c04a37d3f29607a6b35422f" title="Определяет статический фабричный метод create для класса. Если DEFINE_MOCK_CREATE не определен,...">DEFINE_CREATE</a></span>. Таким образом, интерфейсы, определенные только с <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE</a></span>, не получают автоматически статический метод <span class="tt">create()</span>, управляемый <span class="tt">DEFINE_MOCK_CREATE</span>.</li>
</ul>
</li>
</ol>
<p><b>Сценарии использования:</b></p>
<ul>
<li><b>Мокирование конкретного класса:</b> Если у вас есть конкретный класс <span class="tt">CMyImpl</span>, определенный с <span class="tt"><a class="el" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280" title="Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...">DEFINE_IMPLEMENTATION(CMyImpl)</a></span>, и вы определяете <span class="tt">DEFINE_MOCK_CREATE</span> в вашем тесте, то вызов <span class="tt">CMyImpl::create(...)</span> автоматически перенаправится на <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для &quot;мок&quot;-объектов.">iridium::testing::Mock</a>&lt;CMyImpl&gt;::create(...)</span>. Затем, если вы создали экземпляр <span class="tt">CMyImplMock</span>, он будет предоставлен.</li>
<li><b>Мокирование через интерфейс:</b> Если вы хотите, чтобы <span class="tt">IMyInterface::create(...)</span> возвращал мок, а <span class="tt">IMyInterface</span> определен только с <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE</a></span>, вам нужно <b>самостоятельно реализовать</b> статический метод <span class="tt">IMyInterface::create(...)</span>. В этой вашей реализации вы можете использовать <span class="tt">DEFINE_MOCK_CREATE</span> (или другой ваш флаг) для выбора между <span class="tt">std::make_shared&lt;CMyRealImpl&gt;(...)</span> и <span class="tt"><a class="el" href="classiridium_1_1testing_1_1_mock.html" title="Базовый класс для &quot;мок&quot;-объектов.">iridium::testing::Mock</a>&lt;IMyInterface&gt;::create(...)</span>.</li>
</ul>
<p><b>Пример (мокирование конкретной реализации, как в <span class="tt">iridium-test/testing/example.cpp</span>):</b></p>
<div class="fragment"><div class="line"><span class="comment">// --- Начало примера кода ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Включаем заголовки Iridium. Порядок важен, если `DEFINE_MOCK_CREATE` влияет на них.</span></div>
<div class="line"><span class="comment">// В данном случае, `DEFINE_MOCK_CREATE` должен быть определен до smart_ptr.h, где находится DEFINE_CREATE.</span></div>
<div class="line"><span class="comment">// Для этого примера, мы разместим DEFINE_MOCK_CREATE прямо в &quot;тестовом файле&quot;.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: IDataService.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// Для DEFINE_INTERFACE</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IDataService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a>(IDataService); <span class="comment">// Не создает IDataService::create()</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: CDataServiceImpl.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;IDataService.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="smart__ptr_8h.html">iridium/smart_ptr.h</a>&quot;</span> <span class="comment">// Для DEFINE_IMPLEMENTATION</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CDataServiceImpl : <span class="keyword">public</span> IDataService {</div>
<div class="line">    std::string m_serviceName;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Конструктор для реальной реализации</span></div>
<div class="line">    CDataServiceImpl(<span class="keyword">const</span> std::string&amp; name) : m_serviceName(name) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// DEFINE_IMPLEMENTATION включает DEFINE_CREATE, который будет учитывать DEFINE_MOCK_CREATE</span></div>
<div class="line">    <a class="code hl_define" href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a>(CDataServiceImpl);</div>
<div class="line"> </div>
<div class="line">    std::string fetchData(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Real data for id &quot;</span> + std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot; from &quot;</span> + m_serviceName;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: CDataServiceImplMock.h (или прямо в тестовом .cpp)</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Мокируем конкретный класс</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mock_8h.html">iridium/testing/mock.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="mock_8h.html#a1aa823f3557d4e07d5a6cce9bb497aee">DEFINE_MOCK_CLASS</a>(CDataServiceImpl) { <span class="comment">// Создает CDataServiceImplMock</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Так как CDataServiceImpl имеет конструктор с параметрами,</span></div>
<div class="line">    <span class="comment">// мок должен его вызвать через DEFINE_MOCK_CONSTRUCTOR.</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a4d8f3f37a1da67b31d455e5086be40f3">DEFINE_MOCK_CONSTRUCTOR</a>(CDataServiceImpl)</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#a45da68ed3f119848c88d8ef01622bcec">DEFINE_MOCK_METHOD</a>(std::string, fetchData, <span class="keywordtype">int</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: DataConsumer.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;CDataServiceImpl.h&quot;</span> <span class="comment">// Зависит от конкретной реализации для вызова CDataServiceImpl::create()</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataConsumer {</div>
<div class="line">    std::shared_ptr&lt;CDataServiceImpl&gt; m_dataService; <span class="comment">// Использует конкретный класс</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataConsumer() {</div>
<div class="line">        <span class="comment">// Вызываем CDataServiceImpl::create(), который будет управляться DEFINE_MOCK_CREATE</span></div>
<div class="line">        m_dataService = CDataServiceImpl::create(<span class="stringliteral">&quot;MyRealService&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string processData(<span class="keywordtype">int</span> recordId) {</div>
<div class="line">        <span class="keywordflow">if</span> (!m_dataService) <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error: Service not created&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Consumed: &quot;</span> + m_dataService-&gt;fetchData(recordId);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Файл: test_main.cpp (или ваш тестовый файл)</span></div>
<div class="line"><span class="comment">// ЭТО КЛЮЧЕВОЙ МОМЕНТ: DEFINE_MOCK_CREATE должен быть определен ПЕРЕД включением</span></div>
<div class="line"><span class="comment">// iridium/smart_ptr.h, если он должен повлиять на DEFINE_CREATE в нем.</span></div>
<div class="line"><span class="comment">// В данном случае, для простоты, мы предполагаем, что заголовки CDataServiceImpl.h</span></div>
<div class="line"><span class="comment">// (который тянет smart_ptr.h) будут обработаны компилятором уже после этого дефайна.</span></div>
<div class="line"><span class="preprocessor">#define DEFINE_MOCK_CREATE</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tester_8h.html">iridium/testing/tester.h</a>&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;DataConsumer.h&quot;       // Уже включены концептуально выше</span></div>
<div class="line"><span class="comment">// #include &quot;CDataServiceImplMock.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="tester_8h.html#a45feb1f37ce559e49baf8655d769ef85">TEST</a>(DataConsumer_UsesMockService) {</div>
<div class="line">    <span class="comment">// 1. Создаем экземпляр мока CDataServiceImplMock.</span></div>
<div class="line">    <span class="comment">//    Это действие установит Mock&lt;CDataServiceImpl&gt;::m_is_mocked = true;</span></div>
<div class="line">    <span class="comment">//    и зарегистрирует данный mockService в списке доступных моков.</span></div>
<div class="line">    <span class="comment">//    Передаем аргумент конструктора, как и для реального CDataServiceImpl.</span></div>
<div class="line">    CDataServiceImplMock mockService(<span class="stringliteral">&quot;MockedServiceInstance&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Задаем поведение для мок-метода fetchData</span></div>
<div class="line">    <a class="code hl_define" href="mock_8h.html#aed1edc22e98dd2dc94c0368764223576">DEFINE_MOCK_BEHAVIOR</a>(std::string, fetchData, mockService, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 101) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;mocked_payload_for_101&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;generic_mock_payload&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Создаем DataConsumer. Его конструктор вызовет CDataServiceImpl::create(&quot;MyRealService&quot;).</span></div>
<div class="line">    <span class="comment">//    Поскольку DEFINE_MOCK_CREATE активен, CDataServiceImpl::create() был сгенерирован так,</span></div>
<div class="line">    <span class="comment">//    чтобы вызвать iridium::testing::Mock&lt;CDataServiceImpl&gt;::create(...).</span></div>
<div class="line">    <span class="comment">//    Так как mockService (типа CDataServiceImplMock) был создан и зарегистрирован,</span></div>
<div class="line">    <span class="comment">//    он будет возвращен (аргумент &quot;MyRealService&quot; будет использован конструктором мока, если он его принимает,</span></div>
<div class="line">    <span class="comment">//    или проигнорирован, если Mock&lt;T&gt;::create так решит для моков).</span></div>
<div class="line">    DataConsumer consumer;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Проверяем, что DataConsumer получил и использует мокированные данные</span></div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(101), equal, <span class="stringliteral">&quot;Consumed: mocked_payload_for_101&quot;</span>);</div>
<div class="line">    <a class="code hl_define" href="tester_8h.html#a821326052e3e2bf1fb2d678e9e9a6004">ASSERT</a>(consumer.processData(200), equal, <span class="stringliteral">&quot;Consumed: generic_mock_payload&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// --- Конец примера кода ---</span></div>
<div class="ttc" id="asmart__ptr_8h_html"><div class="ttname"><a href="smart__ptr_8h.html">smart_ptr.h</a></div><div class="ttdoc">Предоставляет вспомогательные макросы для определения стандартных typedef-ов умных указателей и стати...</div></div>
<div class="ttc" id="asmart__ptr_8h_html_a5314379c214998b38c9b5d50b1e1ac9d"><div class="ttname"><a href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d">DEFINE_INTERFACE</a></div><div class="ttdeci">#define DEFINE_INTERFACE(TClass)</div><div class="ttdoc">Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...</div><div class="ttdef"><b>Определения</b> smart_ptr.h:96</div></div>
<div class="ttc" id="asmart__ptr_8h_html_ad4d8992039d0faf9ae66c4f596277280"><div class="ttname"><a href="smart__ptr_8h.html#ad4d8992039d0faf9ae66c4f596277280">DEFINE_IMPLEMENTATION</a></div><div class="ttdeci">#define DEFINE_IMPLEMENTATION(TClass)</div><div class="ttdoc">Вспомогательный макрос для определения классов реализации. Объединяет DEFINE_CREATE(TClass) для объяв...</div><div class="ttdef"><b>Определения</b> smart_ptr.h:110</div></div>
</div><!-- fragment --><p><b>Итог по интерфейсам:</b></p>
<p>Если вы хотите получить мок для интерфейса <span class="tt">IExample</span> через вызов <span class="tt">IExample::create()</span>, то, поскольку <span class="tt"><a class="el" href="smart__ptr_8h.html#a5314379c214998b38c9b5d50b1e1ac9d" title="Вспомогательный макрос для определения интерфейсов. Объединяет DEFINE_SMART_PTR(TClass) для объявлени...">DEFINE_INTERFACE</a></span> не предоставляет <span class="tt">create()</span>, вы должны написать этот метод сами. Например:</p>
<div class="fragment"><div class="line"><span class="comment">// В IExample.h или IExample.cpp</span></div>
<div class="line"><span class="comment">// #include &quot;CRealExampleImpl.h&quot; // Ваша реальная реализация</span></div>
<div class="line"><span class="comment">// #include &quot;iridium/testing/mock.h&quot; // Для Mock&lt;IExample&gt;::create()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::shared_ptr&lt;IExample&gt; IExample::create() { // Предполагаем, что вы объявили static create() в IExample</span></div>
<div class="line"><span class="comment">// #ifdef USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</span></div>
<div class="line"><span class="comment">//     return iridium::testing::Mock&lt;IExample&gt;::create();</span></div>
<div class="line"><span class="comment">// #else</span></div>
<div class="line"><span class="comment">//     return std::make_shared&lt;CRealExampleImpl&gt;();</span></div>
<div class="line"><span class="comment">// #endif</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><p> В этом случае, <span class="tt">DEFINE_MOCK_CREATE</span> напрямую не используется Iridium для <span class="tt">IExample::create()</span>, но вы можете использовать его или аналогичный флаг (<span class="tt">USER_TEST_FLAG_FOR_IEXAMPLE_MOCK</span>) в вашей собственной реализации <span class="tt">IExample::create()</span>.</p>
<p>Эта детальная информация должна корректно отражать механизм мокирования при использовании <span class="tt">create()</span> в Iridium.</p>
<h2 class="doxsection"><a class="anchor" id="subsec_testing_sequences"></a>
Тестирование последовательностей вызовов</h2>
<p>Иногда важно не только то, какие методы мок-объекта вызываются, но и в каком порядке это происходит. Фреймворк мокирования Iridium предоставляет средства для определения и проверки последовательностей вызовов.</p>
<p>***Примечание:** Эта функциональность может быть неполной или находиться в разработке. Макросы, представленные в коде, могут не соответствовать полной реализации класса <span class="tt">MockSequence</span>.*</p>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_defining_sequences"></a>
Определение последовательности (DEFINE_MOCK_SEQUENCE)</h3>
<p>Макрос <span class="tt"><a class="el" href="mock_8h.html#ace4b22cc417f51770cfce95652a56f27" title="Определяет последовательность &quot;мок&quot;-вызовов.">DEFINE_MOCK_SEQUENCE(name)</a></span> используется для создания объекта последовательности.</p><ul>
<li><span class="tt">name</span>: Имя, которое вы даете этой последовательности (будет создана переменная <span class="tt">sequence_&lt;name&gt;</span>).</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="subsubsec_testing_sequence_expectations"></a>
Ожидания в последовательности (DEFINE_MOCK_SEQUENCE_EXPECTATION)</h3>
<p>После определения объекта последовательности, вы добавляете в нее ожидаемые вызовы с помощью макроса <span class="tt"><a class="el" href="mock_8h.html#aae10d30862b8ed496a69f53cc93d7c57" title="Определяет ожидание для последовательности &quot;мок&quot;-вызовов.">DEFINE_MOCK_SEQUENCE_EXPECTATION(sequence_name, mock, method)</a></span>.</p><ul>
<li><span class="tt">sequence_name</span>: Имя ранее определенной последовательности.</li>
<li><span class="tt">mock</span>: Мок-объект.</li>
<li><span class="tt">method</span>: Имя мокированного метода, который должен быть вызван.</li>
</ul>
<p>В текущей реализации этот макрос не позволяет указывать ожидаемые аргументы для вызова метода. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
